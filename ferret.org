#+title: Ferret: Clojure to C++ Compiler
#+tags: clojure c++ arduino avr-gcc gcc
#+STARTUP: hidestars
#+TAGS: noexport(e)
#+EXPORT_EXCLUDE_TAGS: noexport
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-dark.min.css" />
#+OPTIONS: toc:nil
#+TOC: headlines 3

* License

Copyright 2015 Nurullah Akkaya

This file is part of Ferret.

Ferret is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. 

Ferret is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details. 

You should have received a copy of the GNU General Public License
along with Foobar. If not, see http://www.gnu.org/licenses/.

* Compiler

Compilation happens by taking the /form/ and running it through several
transformations. Each transformation turns the form into more and more
C++ written with s-expressions. This intermediate language is then run
through code generation to produce the C++ file.

** Compilation

Forms go through nine transformations before they are passed to the
code generation phase.

#+name: core-compilation-process
#+begin_src clojure :tangle no
  (defn compile [form options]
    (->> (import-modules-all form)
         (process-reader-macros)
         (add-built-in)
         (expand-macros-all)
         (let->fn)
         (do->fn)
         (closure-conversion)
         (replace-fn-call-sites options)
         (escape-analysis)
         (symbol-conversion)))
#+end_src

*** Import Modules

Import other ferret files using,

#+BEGIN_SRC clojure :tangle no
  (require '[package.io :as io])
#+END_SRC

Compiler will look for a file under current working directory called,
/package/io.clj/ all expression in the that file will be added to the
front of the current form with symbols renamed to /some-fn/ =>
/io/some-function/.

#+name: core-compilation-add-built-in
#+begin_src clojure :tangle no
  (defn import-modules-select-require [form]
    (->> (select-form form (is-form? 'require))
         (map #(->> % rest first rest first))
         (map (fn [[mod _ as]] [mod as]))
         (reduce (fn[h [mod as]]
                   (if (h mod)
                     (assoc h mod (conj (h mod) as))
                     (assoc h mod [as]))) {})))
#+end_src

Extract the list of packages and aliases from the form. Returns a map
of mod -> aliases pairs.

#+name: core-compilation-add-built-in
#+begin_src clojure :tangle no
  (defn import-modules-load-modules [package-list]
    (reduce (fn[h [m aliases]]
              (let [mod (read-clojure-file
                         (str (.replace (str m) "." "/") ".clj"))
                    macro-symbols (->> (select-form mod (is-form? 'defmacro))
                                       (map second)
                                       (into #{}))
                    def-symbols (->> (select-form (expand-macros-all mod) (is-form? 'def))
                                     (map second)
                                     (into #{}))
                    replace? (set/union macro-symbols def-symbols)
                    mod (morph-form mod symbol?
                                    (fn [f]
                                      (if (replace? f)
                                        (symbol (str (.replace (str m) "." "_") "_" f))
                                        f)))]
                (reduce (fn [h v] (conj h v)) h mod)))
            (list ) package-list))
#+end_src

Loads all modules listed in the package list. When a module is loaded
all its symbols are replaces with its module name except /core/
functions. Module name acts as namespaces. Returns a form that the is
concatenation of all modules listed in form.

#+name: core-compilation-add-built-in
#+begin_src clojure :tangle no
  (defn import-modules-convert-alias-to-module [package-list form]
    (let [alias-to-mod (reduce (fn[h [mod aliases]]
                                 (reduce (fn[h v] (assoc h v mod)) h aliases))
                               {} package-list)
          form (morph-form form symbol?
                           (fn [f]
                             (if-let [[_ alias fn] (re-find #"(.*?)/(.*)" (str f))]
                               (if-let [mod-sym (alias-to-mod (symbol alias))]
                                 (symbol (str (.replace (str mod-sym) "." "_") "_" fn))
                                 f)
                               f)))]
      form))
#+end_src

Convert all aliased symbols in the form to their fully qualified
modules names. So /helper-a/ defined in module /util.db/ becomes
/util_db_helper-a/. 

#+name: core-compilation-add-built-in
#+begin_src clojure :tangle no
  (defn import-modules [form]
    (let [package-list (import-modules-select-require form)
          form (remove-form form (is-form? 'require))
          modules (import-modules-load-modules package-list)
          form (import-modules-convert-alias-to-module package-list form)]
      (shake-concat modules form)))

  (defn import-modules-all [form]
    (loop [f form]
      (let [expanded (import-modules f)]
        (if (= f expanded)
          expanded
          (recur expanded)))))
#+end_src

Import all modules in the given form.

**** Tests

Create some dummy libs under /test/modules/,

#+begin_src clojure :mkdirp yes :tangle src/test/modules/module-a.clj
  (defn helper-a []
    (print "Module A"))

  (defmacro ten-fn []
    (list 'fn [] 10))

  (defmacro helper-b []
    (reduce (fn [a b] (+ a b)) (list 1 2 3))
    1)

  (defn helper-c []
    (helper-b))
#+end_src 

#+begin_src clojure :mkdirp yes :tangle src/test/modules/module-b.clj
  (require '[test.modules.module-c :as mod-c])

  (defn helper-b []
    (mod-c/helper-c))

  (defn eleven-fn []
    (mod-c/eleven-fn))
#+end_src 

#+begin_src clojure :mkdirp yes :tangle src/test/modules/module-c.clj
  (defn helper-c []
    (print "Module C"))

  (defmacro eleven-fn []
    (list 'fn [] 11))
#+end_src 

Run import tests,

#+name: compiler-import-module-test
#+begin_src clojure :tangle no
  (deftest import-module-test
    (is (= "Module AModule C 10 11 1"
           (capture-output '((require '[test.modules.module-a :as mod-a])
                             (require '[test.modules.module-b :as mod-b])
                             (mod-a/helper-a)
                             (mod-b/helper-b)
                             (print " ")
                             (print ((mod-a/ten-fn))
                                    ((mod-b/eleven-fn))
                                    (mod-a/helper-c)))))))
#+end_src

*** Process Reader Macros

Process some supported reader macros, /@/ and /#(some-fn)/ forms.

#+name: core-compilation-reader-macros
#+begin_src clojure :tangle no
  (defn process-reader-macros [form]
    (morph-form form
                (is-form? 'clojure.core/deref)
                (fn [f] (cons 'deref (rest f)))))
#+end_src

#+name: compiler-reader-macro-test
#+begin_src clojure :tangle no
  (deftest compiler-reader-macro-test
    (is (= "1 3"
           (capture-output '((print @(atom 1))
                             (print " ")
                             (print (#(+ 1 2))))))))
#+end_src

*** Add Runtime

/resources/runtime.clj/ contains the ferret core runtime when
tangled.

#+name: core-compilation-add-built-in
#+begin_src clojure :tangle no
  (defn add-built-in
    ([form]
     (let [runtime (-> (read-string (str \( (read-from-url "runtime.clj") \)))
                       (remove-form (is-form? 'defmacro)))]
       (shake-concat runtime form))))
#+end_src

*** Expand Macros

First we read all the macros present in /resources/runtime.clj/ then
add to that  user defined macros, they are evaluated in a temporary
namespace, using /morph-form/ we iterate all the macros used in the
code that we are compiling and expand them in the temporary namespace
then the node is replaced with its expanded form.

#+name: core-compilation-expand-macros
#+begin_src clojure :tangle no
  (declare expand-macros-all)

  (defn expand-macros [form]
    (let [build-in-macros (->> (read-string (str \( (read-from-url "runtime.clj") \)))
                               (filter (is-form? 'defmacro)))
          build-in-macro-symbols (into #{} (map second build-in-macros))
          form-macros (->> (filter (is-form? 'defmacro) form)
                           (filter (fn [[_ name]]
                                     (not (build-in-macro-symbols name)))))
          form-macro-symbols (map second form-macros)
          form (remove-form form (is-form? 'defmacro))
          temp-ns (gensym)]
      (create-ns temp-ns)
      (binding [*ns* (the-ns temp-ns)]
        (refer 'clojure.core :exclude (concat build-in-macro-symbols form-macro-symbols ['fn 'def]))
        (use '[ferret.core :only [symbol-conversion]])
        
        (doseq [m build-in-macros]
          (eval m))
        
        (doseq [m form-macros]
          (eval m)))
      
      (let [form (morph-form form
                             (is-form? 'let)
                             (fn [[_ bindings & body]]
                               (let [bindings (map #(if (list? %)
                                                      (expand-macros-all %) %) bindings)
                                     form (cons 'let* (cons bindings (expand-macros-all body)))]
                                 (expand-macros-all form))))
            form (morph-form form
                             (apply is-form? (concat build-in-macro-symbols form-macro-symbols))
                             (fn [f]
                               (binding [*ns* (the-ns temp-ns)]
                                 (walk/macroexpand-all f))))]
        (remove-ns temp-ns)
        form)))

  (defn expand-macros-all [form]
    (loop [f form]
      (let [expanded (expand-macros f)]
        (if (= f expanded)
          expanded
          (recur expanded)))))
#+end_src

*** let->fn

/let/ forms are transformed into nested functions which are then
called immediately, bindings are setup in the outer function,
expressions are placed in the inner function which takes the bindings
as arguments.

So following form,

#+begin_src clojure :tangle no
  (let->fn '(let [a 1
                  b 2]
              (+ a b)))
#+end_src

after transformation becomes,

#+begin_src clojure :tangle no
  (define_lambda G__2708 (b a) () (_plus_ a b))
  (define_lambda G__2709 (a) (b) ((lambda_object G__2708 b a)))
  (define_lambda G__2710 () (a) ((lambda_object G__2709 a) 2))
  ((lambda_object G__2710) 1)
#+end_src

#+name: core-compilation-let-fn
#+begin_src clojure :tangle no
  (defn let->fn [form]
    (morph-form form
                (is-form? 'let*)
                (fn [[_ bindings & body]]
                  (let [bindings (->> (partition 2 bindings)
                                      (map-indexed (fn [idx [args val]]
                                                     [idx args val])))
                        vars (map first bindings)]
                    (if (empty? vars)
                      (list (concat (list 'fn* []) body))
                      (let [closure-fn (fn close [[idx arg vals] & more]
                                         (let [body (if (empty? more)
                                                      (list (concat ['fn* []] body))
                                                      (apply close more))]
                                           (list (list 'fn* (list arg) body)
                                                 (last (nth bindings idx)))))]
                        (apply closure-fn bindings)))))))
#+end_src

*** do->fn

A similar method is used for the do form, expressions are wrapped in a fn
that takes no parameters and executed in place.

#+begin_src clojure :tangle no
  (do->fn '(do (+ 1 1)))
#+end_src

#+begin_src clojure :tangle no
  ((fn [] (+ 1 1)))
#+end_src

#+name: core-compilation-do-fn
#+begin_src clojure :tangle no
  (defn do->fn [form]
    (morph-form form
                (is-form? 'do)
                #(list (concat ['fn* []] (rest %)))))
#+end_src

*** Closure Conversion

/closure-conversion/ handles the problem of free variables, 

#+begin_src clojure :tangle no
  (defn make-adder [x]
    (fn [n] (+ x n)))
#+end_src

in the above snippet x is a free variable, the function /make-adder/
returns, has to have a way of referencing that variable when it is
used. The way we do this is that, every function will pass its arguments to
inner functions (if any) it contains.

#+begin_src clojure :tangle no
  (closure-conversion '(fn [x]
                          (fn [n] (+ x n))))
#+end_src

Above form will be converted to,

#+begin_src clojure :tangle no
  (define_lambda G__3154 (x) (n) (_plus_ x n))
  (define_lambda G__3155 () (x) (lambda_object G__3154 x))
  (lambda_object G__3155)
#+end_src

What this means is, define a functor named /G__3154/ that holds a
reference to /x/, and another functor /G__3155/ that has no state. When
we create an instance of /G__3154/ we pass /x/ to its
constructor. Since every thing is already converted to fns this
mechanism allows variables to be referenced down the line and solves
the free variable problem.

#+name: core-compilation-closure-conversion 
#+begin_src clojure :tangle no
  (defn lambda-defined? [fns env args body]
    (let [f (concat [env args] body)
          name (reduce (fn[h v]
                         (let [[_ n & r] v]
                           (if (= r f) n))) nil @fns)]
      (when name
        (apply list 'lambda-object name env))))

  (defn define-lambda [fns env args body]
    (let [n (gensym)]
      (dosync (alter fns conj (concat ['define-lambda n env args] body)))
      (apply list 'lambda-object n env)))

  (defn closure-conversion
    ([form]
     (let [fns (ref [])
           form (closure-conversion form fns)]
       (concat form @fns)))
    ([form fns & env]
     (morph-form form
                 (is-form? 'fn*)
                 (fn [[_ args & body]]
                   (let [env (if (nil? env) '() (first env))
                         fn-env (->> args
                                     (remove #(and (seq? %)
                                                   (= 'ferret-compiler-no-closure (first %)))))
                         fn-args (->> args
                                      (map #(if (and (seq? %)
                                                     (= 'ferret-compiler-no-closure (first %)))
                                              (second %)
                                              %)))
                         body (closure-conversion body fns (concat fn-env env))]
                     (if-let [n (lambda-defined? fns env args body)]
                       n
                       (define-lambda fns env fn-args body)))))))
#+end_src

*** Symbol Conversion

Some symbols valid in Clojure are not valid C++ identifiers. This
transformation converts all symbols that are not legal C++ identifiers
into valid ones.

#+name: core-compilation-symbol-conversion
#+begin_src clojure :tangle no
  (defn symbol-conversion [form]
    (let [c (comp #(symbol (clojure.string/escape
                            (str %)
                            {\- \_ \* "_star_" \+ "_plus_" \/ "_slash_"
                             \< "_lt_" \> "_gt_" \= "_eq_" \? "_QMARK_"
                             \! "_BANG_"}))
                  #(cond (= 'not %) '_not_
                         :default %))]
      (morph-form form symbol? c)))

#+end_src

*** Optimizations
**** Replace Fn Call Sites

Final step replaces all functions calls with new function
objects /define_lambda/ are renamed to /fn/. This removes all globals
variables unless the /fn/ defined is a closure. In which case it is
left as a global variable and the class implementation is prepended
with the global name for readability.

#+BEGIN_EXAMPLE
  (compile '((let [a 1]
               (defn adder [x]
                 (+ a x)))
             (defn my-inc [x] (+ 1 x))))

  (replace-fn-call-sites
   '((define_lambda G__3885 (a) (x) (_plus_ a x))
     (define_lambda G__3886 () (a) (def adder (lambda_object G__3885 a)))
     (define_lambda G__3887 () () (define_var a 1) ((lambda_object G__3886) a))
     (define_lambda G__3888 () (x) (_plus_ 1 x))
     ((lambda_object G__3887))
     (def my_inc (lambda_object G__3888))))

  ((define_lambda adder_G__3885 (a) (x) (_plus_ a x))
   (define_lambda G__3886 () (a) (def adder (lambda_object adder_G__3885 a)))
   (define_lambda G__3887 () () (define_var a 1) ((lambda_object G__3886) a))
   (define_lambda my_inc () (x) (_plus_ 1 x))
   ((lambda_object G__3887)))
#+END_EXAMPLE

#+name: core-compilation-symbol-conversion
#+begin_src clojure :tangle no
  (defn select-def-fn [form]
    (->> (select-form form (is-form? 'def))
         (filter (fn [[_ name val]]
                   (and (seq? val)
                        (= 'lambda-object (first val)))))))

  (defn replace-fn-call-sites-pure [form fn-defs fn-table]
    (let [no-global-fn (reduce (fn[h v]
                                 (remove-form h (fn [f]
                                                  (and (seq? f)
                                                       (= 'def (first f))
                                                       (every? true? (map = f v))))))
                               form fn-defs)        
          embeded-fn-calls (reduce (fn[h [name gensym]]
                                     (morph-form h symbol?
                                                 (fn [f]
                                                   (if (= f name)
                                                     (list 'lambda-object gensym)
                                                     f))))
                                   no-global-fn fn-table)
          embed-fn-names (reduce (fn[h [name gensym]]
                                   (morph-form h symbol?
                                               (fn [f]
                                                 (if (= f gensym)
                                                   name
                                                   f))))
                                 embeded-fn-calls fn-table)]
      embed-fn-names))

  (defn replace-fn-call-sites [options form]
    (if (:global-functions options)
      form
      (let [pure-fn-defs (->> (select-def-fn form)
                              (filter #(= 2 (-> % last count))))
            pure-fn-table (map (fn [[_ name [_ gensym]]] [name gensym]) pure-fn-defs)
            form (replace-fn-call-sites-pure form pure-fn-defs pure-fn-table)
            closure-fn-defs (->> (select-def-fn form)
                                 (filter #(not= 2 (-> % last count))))
            closure-fn-table (map (fn [[_ name [_ gensym]]] [name gensym]) closure-fn-defs)]
        (reduce (fn[h [name gensym]]
                  (morph-form h symbol?
                              (fn [f]
                                (if (= f gensym)
                                  (symbol (str name "_" gensym))
                                  f))))
                form closure-fn-table))))
#+end_src

**** Tree Shaking

Concats two forms. Shakes the first form by removing any symbols not
present in second form.

In order to keep the generated C++ code compact only the functions used
will be present in the generated source file. Which means if you don't
use /println/ anywhere in the code it won't be defined in the final
C++ file, but if you use it, it and everything it uses will be
defined, in the case of /println/ it will pull /apply/, /print/ and
/newline/ with it.

#+name: core-compilation-shake-concat
#+begin_src clojure
  (defn shake-concat
    ([header form]
     (let [header-no-macro (expand-macros-all header)
           header-symbols (->> (select-form header-no-macro (is-form? 'def))
                               (map second))
           header-fns (reduce (fn[h v] (assoc h (second v) v)) {} header-no-macro)
           fns (atom {})
           _ (shake-concat (expand-macros-all form) header-fns fns)
           include-fns (->> @fns
                            (sort-by #(.indexOf header-symbols (key %)))
                            (map #(second %)))
           objects (select-form header (is-form? 'defobject))
           macros (select-form header (is-form? 'defmacro))
           requires (select-form header (is-form? 'require))]
       (concat requires objects include-fns macros form)))
    ([form built-in fns]
     (morph-form form symbol?
                 #(do (if-let [f (built-in %)]
                        (when (not (@fns %))
                          (swap! fns assoc % f)
                          (shake-concat f built-in fns))) %))))
#+end_src

****  Escape Analysis

      Determines that a certain allocation never escapes the local
      function. This means that allocation can
      be done on the stack.

#+name: core-compilation-shake-concat
#+begin_src clojure
  (defn escape-analysis [form]
    (let [stack-lambda-pred (fn [f]
                              (and (seq? f)
                                   (is-special-form? 'lambda-object (first f))))
          ;;espace lambda classes
          escapeable-lambdas (->> (collect-form
                                   form
                                   (fn [f]
                                     (and (stack-lambda-pred f)
                                          (let [fn-symbol (-> f first second)
                                                non-stack-allocations (-> (morph-form form stack-lambda-pred #(rest %))
                                                                          (select-form symbol?))]
                                            (->> non-stack-allocations
                                                 (filter #(= % fn-symbol))
                                                 rest ;; skip class definition
                                                 count ;; when pos it is used somewhere else as a symbol
                                                 zero?))))
                                   #(-> % first second))
                                  (into #{}))
          form (morph-form form
                           (fn [f]
                             (and (seq? f)
                                  (= (first f) 'define-lambda)
                                  (escapeable-lambdas (second f))))
                           #(cons 'define-lambda-stack (rest %)))
          ;;espace lambda objects
          form (morph-form form stack-lambda-pred (fn [f] (cons 'invoke-lambda-stack f)))]
      form))
#+end_src

*** Helpers

During each pass we iterate over the nodes in the form using
/morph-form/ and /remove-form/, they both take a s-expression and a
predicate if the predicate returns true, morph-form will call /f/
passing the current node as an argument and replace that node with
/f/'s return value, remove-form on the other hand does what its name
suggests and removes the node when predicate returns true.

#+name: core-compilation-form-fns
#+begin_src clojure :tangle no
  (defn morph-form [tree pred f]
    (walk/prewalk (fn [x]
                    (if (pred x)
                      (f x)
                      x)) tree))

  (defn collect-form [tree pred f]
    (let [acc (atom [])]
      (doall (morph-form tree pred (fn [x] (swap! acc conj (f x)))))
      @acc))

  (defn remove-form [tree pred]
    (if (and (= (count tree) 1)
             (pred (first tree)))
      (list )
      (loop [loc (zip/seq-zip tree)]
        (if (zip/end? loc)
          (zip/root loc)
          (recur
           (zip/next
            (if (pred (zip/node loc))
              (zip/remove loc)
              loc)))))))

  (defn select-form [tree pred]
    (loop [loc (zip/seq-zip tree)
           nodes []]
      (if (zip/end? loc)
        nodes
        (recur
         (zip/next loc)
         (if (pred (zip/node loc))
           (conj nodes (zip/node loc))
           nodes)))))

  (defn is-form? [& s]
    (fn [f]
      (and (seq? f)
           (some true? (map #(= % (first f)) s)))))
#+end_src

*** Tests

#+name: compiler-transformation-tests
#+begin_src clojure :tangle no
  (deftest transformation-test
    (is (= (symbol-conversion '(make-adder 2)) '(make_adder 2)))
    (is (= (symbol-conversion '(make-adder* 2)) '(make_adder_star_ 2)))

    (let [form (->> '((def make-adder (fn [n] (fn [x] (+ x n)))))
                    expand-macros-all
                    closure-conversion)]
      (is (= (first (second form)) 'define-lambda))
      (is (= (last (second form)) '(+ x n)))
      (is (= (second (first form)) 'make-adder))
      (is (= (first (first form)) 'def))))

  (deftest transformation-macro-test
    (is (= "1 1 1 true false true true true (3 3)012343 5"
           (capture-output '((defmacro my-when [test & body]
                               (list 'if test (cons 'do body)))

                             (defmacro some-list [a]
                               (let [a (inc a)]
                                 (list 'list a a)))
                             
                             (print (my-when (< 2 3) 1)

                                    (when (< 2 3) 1)

                                    (when (< 2 3) 1)
                                    
                                    (let [a 1]
                                      (and (> a 0)
                                           (< a 10)))

                                    (let [a 11]
                                      (and (> a 0)
                                           (< a 10)))
                                    
                                    (and true true)

                                    (or true false)

                                    (let [a 11]
                                      (or (> a 0)
                                          (< a 10)))

                                    (some-list 2))
                             
                             (dotimes [i 5] (print i))
                             (let [a 1]
                               (defn adder [x]
                                 (+ a x)))
                             (defn my-inc [x] (+ 1 (adder x)))
                             (print (my-inc 1))

                             (print " ")
                             (let [x 2
                                   y (->> x
                                          (+ 1)
                                          (+ 2))]
                               (print y)))))))

  (deftest transformation-special-forms-test
    (is (= "10 89 11 3 1 5 51111111111"
           (capture-output '((def make-adder
                               (fn [n] (fn [x] (+ x n))))
                             (def adder
                               (make-adder 1))

                             (def fibo (fn [n]
                                         (if (< n 2)
                                           1
                                           (+ (fibo (- n 1))
                                              (fibo (- n 2))))))

                             (def adder-let (let [a 1
                                                  b 2]
                                              (fn [n] (+ a b n))))

                             (def adder-let-2 (fn [n]
                                                (let [a 1
                                                      b 2]
                                                  (+ a b n))))

                             (native-declare "int i = 0;")
                             (defn inc-int [] "__result =  NewNumber(i++);")
                             
                             (print (adder 9)

                                    (fibo 10)

                                    ((fn [n] (+ n 1)) 10)

                                    (((fn [n] (fn [n] n)) 3) 3)

                                    (if (< 2 3 4 5 6)
                                      (do 1)
                                      (do 2))

                                    (adder-let 2)

                                    (adder-let-2 2))
                             
                             (while (< (inc-int) 10)
                               (print 1)))))))
#+end_src

** Code Generation

 Once compilation is complete the form is in a form that is very
 close to C++. running /emit/ on the form converts the form into C++.

#+name: core-code-generation-emit
#+begin_src clojure :tangle no  
  (defmulti emit (fn [form _]
                   (cond (is-special-form? 'defobject form) 'defobject
                         (is-special-form? 'define_lambda form) 'define_lambda
                         (is-special-form? 'define_lambda_stack form) 'define_lambda_stack
                         (is-special-form? 'dispatch_lambda form) 'dispatch_lambda
                         (is-special-form? 'lambda_object form) 'lambda_object
                         (is-special-form? 'define_var form) 'define_var
                         (is-special-form? 'native_declare form) 'native_declare
                         (is-special-form? 'native_define form) 'native_define
                         (is-special-form? 'if form) 'if
                         (is-special-form? 'def form) 'def
                         (is-special-form? 'invoke_lambda_stack form) 'invoke_lambda_stack
                         (to-str? form) :to-str
                         (keyword? form) :keyword
                         (number? form) :number
                         (nil? form) :nil
                         (char? form) :char
                         (string? form) :string
                         (or (true? form) (false? form)) :boolean
                         (seq? form) :sequence)))
#+end_src

Without preprocessing following forms,

#+begin_src clojure :tangle no
  (emit '(list 1 2 3) (ref {}))
  
  (emit '(+ 1 2) (ref {}))
  
  (emit '(if (< a b)
           b a)
        (ref {}))
#+end_src

would evaluate to,

#+begin_example
  "_i(list,NewNumber(1),NewNumber(2),NewNumber(3))"
  "_i(+,NewNumber(1),NewNumber(2))"
  "((<,b,a) ? a : b)"
#+end_example

So the actual compilation will just map emit to all forms passed and
/string-template/ will handle the job of putting them into an empty
C++ skeleton.

#+name: core-code-generation-emit-source
#+begin_src clojure :tangle no
  (defn emit-source [form options]
    (let [state (ref {:lambdas [] :symbol-table #{} :native-declarations [] :native-defines []})
          ast (compile form options)
          body (doall (map #(emit % state) ast))]
      (when (:ast options)
        (pprint/pprint ast))
      (assoc @state :body body)))
#+end_src

*** Code Emitting
**** Object Types

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit :to-str [form state] (str form))

  (defmethod emit :char [form state] (str "NewCharacter('" form "')"))

  (defmethod emit :string [form state] (str "NewString(\"" form "\")"))

  (defmethod emit :boolean [form state] (str "NewBoolean(" form ")"))

  (defmethod emit :nil [form state] "nil()")

  (defmethod emit :keyword [form state]
    (str "NewKeyword(" (reduce (fn[h v] (+ h (int v))) 0 (str form)) ")"))

  (defmethod emit :number [form state]
    (let [number (rationalize form)]
      (if (ratio? number)
        (let [num (numerator number)
              denom (denominator number)]
          (str "NewRatio(" num "," denom ")"))
        (str "NewNumber(" number ")"))))

  (defmethod emit :sequence [[fn & args] state]
    (invoke-lambda (emit fn state) (doall (map #(emit % state) args))))

  (defmethod emit 'invoke_lambda_stack [[_ lambda & args] state]
    (invoke-lambda (new-lambda-stack lambda)
                   (doall (map #(emit % state) args))))

  (defmethod emit 'define_var [[_ name form] state]
    (str "var " name " = " (emit form state)))

  (defmethod emit 'native_declare [[_ declaration] state]
    (append-to! state [:native-declarations] declaration) "")

  (defmethod emit 'native_define [[_ define] state]
    (append-to! state [:native-defines] define) "")
#+end_src

**** Lambdas

List Destructuring. Clojure style list structuring is supported on
lambda forms.

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defn destructure-set-var [val arg accesor]
    (str "var " val " = "
         (reduce (fn[h v] (str v "(" h ")")) arg accesor)))

  (defn destructure-arguments [args name]
    (let [[args va-args] (if (some #{'&} args)
                           (split-at (.indexOf args '&) args)
                           [args []])
          args (->> args
                    (map-indexed (fn [pos val]
                                   (vector pos val)))
                    (filter #(not= (second %) '_))
                    (reduce (fn[h [pos val]]
                              (let [accesor (flatten [(repeat pos "REST") "FIRST"])]
                                (if (coll? val)
                                  (conj h (destructure-arguments
                                           val (reduce (fn[h v] (str v "(" h ")")) name accesor)))
                                  (conj h (destructure-set-var val name accesor))))) []))]
      [args (if (empty? va-args)
              []
              (destructure-set-var
               (last va-args) name (repeat (count args) "REST")))]))

  (defn destructure-lambda [args]
    (flatten (destructure-arguments args "_args_")))
#+end_src

#+name: clojure-destructure-tests
#+begin_src clojure :tangle no
  (deftest destructure-test
    (is (= "(1 2 3) 2 3 ((1 2 3)) 1 2 (3 4) 1 2 4 (5) (3) 1 2 3 3 3 5 1 2 3 nil nil nil"
           (capture-output '((defn destructure-test-1 [[a b c]]
                               (list a b c))
                             (defn destructure-test-2 [[a [b] c]]
                               b)
                             (defn destructure-test-3 [[a [_ b] c]]
                               b)
                             (defn destructure-test-4 [& a]
                               a)
                             (defn destructure-test-5 []
                               (let [[a b c] (list 1 2 3)]
                                 (print a b c)))
                             (defn destructure-test-6 []
                               (let [[_ _ a] (list 1 2 3)]
                                 (print a)))
                             (print (destructure-test-1 (list 1 2 3))
                                    (destructure-test-2 (list 1 (list 2) 3))
                                    (destructure-test-3 (list 1 (list 2 3) 3))
                                    (destructure-test-4 (list 1 2 3)))
                             (print " ")
                             (let [a (list 1 2 3 4)
                                   [b c & r] a]

                               (print b c r))
                             (let [a 1 b 2
                                   [c & r] (list 4 5)]
                               (print " ")
                               (print a b c r))
                             (let [[a & r] (list 1 2 3)
                                   rr (rest r)]
                               (print " ")
                               (print rr))
                             (print " ")
                             (destructure-test-5)
                             (print " ")
                             (destructure-test-6)
                             (print " ")
                             (let [[_ _ a] (list 1 2 3)
                                   [_ b] (list 4 5 6)]
                               (print a b))
                             (print " ")
                             (let [a (list 1 2 3)
                                   [b c d e f g] a]
                               (print b c d e f g)))))))
#+end_src

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit 'lambda_object [l state]
    (new-lambda l))

  (defn emit-define-lambda-aux [name env args body state]
    (let [native-declarations (filter #(and (seq? %)
                                            (= (first %) 'native_declare)) body)
          body (filter #(not (and (seq? %)
                                  (= (first %) 'native_declare))) body)
          body (cond  (empty? body)
                      ["nil();"]
                      (and (= 1 (count body))
                           (seq? (first body))
                           (= 'dispatch_lambda (first (first body))))
                      [(emit (first body) state) "nil();"]
                      (and (= 1 (count body))
                           (string? (first body)))
                      (let [inline (first body) 
                            body (if (= (last inline) \;)
                                   inline
                                   (str inline \;))]
                        (if (neg? (.indexOf body "__result"))
                          [body "nil();"]
                          ["var __result;" body "__result;"]))
                      :default (doall (map #(str (emit % state) \;) body)))
          env (->> env
                   (flatten)
                   (filter #(and (not (= '& %))
                                 (not (= '_ %)))))]
      (doseq [dec native-declarations] 
        (emit dec state))
      [name env (destructure-lambda args) body]))

  (defmethod emit 'define_lambda [[_ name env args & body] state]
    (let [[name env args body] (emit-define-lambda-aux name env args body state)]
      (append-to! state [:lambdas]
                  {:name name :env env :args args :body body}) ""))

  (defmethod emit 'define_lambda_stack [[_ name env args & body] state]
    (let [[name env args body] (emit-define-lambda-aux name env args body state)]
      (append-to! state [:lambdas]
                  {:name name :env env :args args :body body :stack true}) ""))
#+end_src

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit 'dispatch_lambda [[_ args-symbol & fns] state]
    (let [fns (->> fns
                   (partition 2))
          nil-dispatch (filter #(= (first %) 0) fns)]
      (str
       (if (not (empty? nil-dispatch))
         (str "if (" args-symbol ".isNil())
                return " (new-lambda-stack
                          (->> nil-dispatch first second)) ".invoke(nil());")
         "")
       "switch(" args-symbol ".cast<ISeekable>()->count()) {"
       (->> fns
            (map (fn [[count fn]]
                   (if (= count 'true)
                     (str "default: "
                          " return " (new-lambda-stack fn) ".invoke(" args-symbol ");")
                     (str "case " count " : "
                          " return " (new-lambda-stack fn) ".invoke(" args-symbol ");"))))
            (apply str)) "}")))
#+end_src

**** Misc

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit 'defobject [[_ name & spec] state]
    (append-to! state [:native-declarations] (declare-object name spec))
    "")

  (defmethod emit 'if [[_ cond t f] state]
    (let [cond (emit cond state)
          t (emit t state)
          f (if (nil? f) "nil()" (emit f state))]
      (if-statement cond t f)))

  (defmethod emit 'def [[_ name & form] state]
    (append-to! state [:symbol-table] name)
    (str "(" name " = " (apply str (doall (map #(emit % state) form))) ")"))
#+end_src

*** Code Templates

**** Objects

#+name: code-templates
#+begin_src clojure :tangle no
  (defn declare-object [name body]
    (let [specs (into {} (map #(vector (first %) (rest %)) body))
          interface (if (nil? (specs 'interface))
                      "Object"
                      (apply str (rest (str (first (specs 'interface))))))
          interface-only (cond (specs 'interface) false
                               (empty? (specs 'new)) true
                               :defaul false)
          view (create-view "
      namespace ferret{

       $if(object_type)$
         const size_t $type$_TYPE = $type_val$;
       $endif$

       $if(template)$
         template<$template:{$it$} ;separator=\",\"$>
       $endif$
       class $name$ : public $interface$ {
       public:

         $data:{$it$} ;separator=\"\n\"$

         $interfaces:{virtual $it$ = 0;} ;separator=\"\n\"$

         $new:{it | $name$($first(it)$){
           $first(rest(it))$
         }} ;separator=\"\n\"$

         $if(object_type)$
          size_t getType(){ return $type$_TYPE;}
         $endif$

         $if(equals)$
          var equals(var o){
           $equals$
          }
         $endif$

         $if(toOutputStream)$
  #if !defined(DISABLE_OUTPUT_STREAM)
          var toOutputStream(){
           $toOutputStream$
          }
  #endif
         $endif$

         $fns:{it | $first(it)$($first(rest(it))$){
           $first(rest(rest(it)))$
         }} ;separator=\"\n\"$

         $ifdef_fns:{it | #$first(it)$
           $first(rest(it))$($first(rest(rest(it)))$){
           $first(rest(rest(rest(it))))$
         }
       #endif} ;separator=\"\n\"$
       };
       $post_code$
      }")]
      (fill-view! view "name" name)
      (fill-view! view "template" (specs 'template))
      (fill-view! view "interface" interface)
      (fill-view! view "interface_only" interface-only)
      (fill-view! view "object_type" (cond (specs 'force_type) true
                                           interface-only false
                                           :default true))
      (fill-view! view "type" (.toUpperCase (str name)))
      (fill-view! view "type_val" (gensym ""))
      (fill-view! view "data" (specs 'data))
      (fill-view! view "new" (specs 'new))
      (fill-view! view "equals" (first (specs 'equals)))
      (fill-view! view "toOutputStream" (first (specs 'toOutputStream)))
      (fill-view! view "interfaces" (specs 'interfaces))
      (fill-view! view "fns" (filter #(= 3 (count %)) (specs 'fns)))
      (fill-view! view "ifdef_fns" (filter #(= 4 (count %)) (specs 'fns)))
      (fill-view! view "post_code" (first (specs 'post_code)))
      (render-view view)))
#+end_src    

**** Lambdas

#+name: code-templates
#+begin_src clojure :tangle no
  (defn if-statement [cond t f]
    (apply str "(" cond " ? " t " : " f ")"))

  (let [env (fn [[_ _ & env]]
              (->> env
                   (flatten)
                   (filter #(and (not (= '& %))
                                 (not (= '_ %))))))]
    (defn new-lambda [l]
      (let [n (second l)
            e (env l)]
        (if (empty? e)
          (str "fn<" n ">()")
          (str "closure<" n ">(" (apply str (interpose \, e)) ")"))))

    (defn new-lambda-stack [l]
      (let [n (second l)
            e (env l)]
        (if (empty? e)
          (str n "()")
          (str n "(" (apply str (interpose \, e)) ")")))))

  (defn invoke-lambda [n args]
    (if (empty? args)
      (str "_i(" n ")")
      (str "_i(" n "," 
           (reduce (fn[h v]
                     (str h v))
                   (->> args
                        (interpose \,)))")")))

  (defn declare-lambda-classes [lambdas]
    (let [view (create-view
                "$lambdas: {lambda|
        $if(!lambda.stack)$
         class $lambda.name$  : public Lambda{
        $else$
         class $lambda.name$  \\{
        $endif$

        $lambda.env:{var $it$;} ;separator=\"\n\"$

        public:

        $if(lambda.env)$
          $lambda.name$ ($lambda.env:{var $it$} ;separator=\",\"$){ 
             $lambda.env:{this->$it$ = $it$;} ;separator=\"\n\"$
          }
        $endif$

        $if(lambda.args)$
            var invoke (var _args_);
        $else$
            var invoke (var);
        $endif$
        };};separator=\"\n\n\"$")]
      (fill-view! view "lambdas" lambdas)
      (render-view view)))

  (defn declare-lambda-bodies [lambdas]
    (let [view (create-view
                "$lambdas: {lambda|
        $if(lambda.args)$
            var $lambda.name$::invoke (var _args_)
        $else$
            var $lambda.name$::invoke (var)
        $endif$
            {
              $lambda.args:{args | $args$; } ;separator=\"\n\"$

              $trunc(lambda.body):{$it$} ;separator=\"\n\"$
              return $last(lambda.body):{$it$} ;separator=\"\n\"$
            }
        };separator=\"\n\n\"$")]
      (fill-view! view "lambdas" lambdas)
      (render-view view)))
#+end_src    

**** Program

#+name: code-templates
#+begin_src clojure :tangle no :noweb yes
  (defn solution-template [source]
    (let [{:keys [body lambdas symbol-table native-declarations native-defines]} source
          view (create-view "
        $native_defines:{$it$} ;separator=\"\n\"$

        $object_interface$

        <<runtime-native-program-misc>>
        <<runtime-native-iseekable-headers>>
        <<function-invocation-api-headers>>

        #if defined(STD_LIB) && !defined(DISABLE_COMMAND_LINE_ARGUMENTS) && !defined(DISABLE_MAIN_FUNCTION)
          ferret::var _star_command_line_args_star_;
        #endif

        namespace ferret{
         $symbols:{var $it$;} ;separator=\"\n\"$
        }

        $native_declarations:{$it$} ;separator=\"\n\"$      

        <<function-invocation-api>>
  
        namespace ferret{
          $lambda_classes:{$it$} ;separator=\"\n\"$
          $lambda_bodies:{$it$} ;separator=\"\n\"$
        }

        <<runtime-native-iseekable-functions>>

        namespace ferret{
          void ProgramRun(){
           $body:{$it$;} ;separator=\"\n\"$ 
          }
        }

      #if !defined(DISABLE_MAIN_FUNCTION)
        int main(int argc, char* argv[]){

        #if defined(STD_LIB) && !defined(DISABLE_COMMAND_LINE_ARGUMENTS)
          _star_command_line_args_star_ = ferret::NewSequence();
          for (int i = argc - 1; i > -1 ; i--)
            CONS(_star_command_line_args_star_,ferret::NewString(argv[i]));
        #endif

          ferret::ProgramRun();

          #if defined(PROGRAM_MAIN)
            _i(ferret::PROGRAM_MAIN);
          #endif

          return 0;
        }
      #endif

      #if defined(ARDUINO)
        void setup(){
          INIT_OUTPUT_STREAM

          #if defined(PROGRAM_MAIN)
            ferret::ProgramRun();
          #endif
        }
        void loop(){
          #if !defined(PROGRAM_MAIN)
            ferret::ProgramRun();
          #endif          

          #if defined(PROGRAM_MAIN)
            _i(ferret::PROGRAM_MAIN);
          #endif
        }
      #endif\n")]
      (fill-view! view "object_interface" (read-from-url "Object.cpp"))
      (fill-view! view "body" (filter #(not (empty? %)) body))
      (fill-view! view "lambda_classes" (declare-lambda-classes lambdas))
      (fill-view! view "lambda_bodies" (declare-lambda-bodies lambdas))
      (fill-view! view "symbols" symbol-table)
      (fill-view! view "native_declarations" native-declarations)
      (fill-view! view "native_defines" native-defines)
      (render-view view)))
#+end_src

* Runtime
** Native

On the C++ side we define our own object system.

Locking macros, See Program Header for more information.

#+name: runtime-native-object-casting-macros
#+begin_src c++ :tangle no
  #if defined(STD_LIB) && !defined(SINGLE_THREADED)
   #define NEW_LOCK(symbol) pthread_mutex_t symbol;
   #define INIT_LOCK(symbol) pthread_mutex_init(&symbol, NULL);
   #define DELETE_LOCK(symbol) pthread_mutex_destroy(&symbol);
   #define WITH_LOCK(lock,code) \
     pthread_mutex_lock(&lock); \
     code;                      \
     pthread_mutex_unlock(&lock);
  #else
   #define NEW_LOCK(symbol)
   #define INIT_LOCK(symbol)
   #define DELETE_LOCK(symbol)
   #define WITH_LOCK(lock,code) code;
  #endif
#+end_src

*** Memory Pool

    When,

#+BEGIN_EXAMPLE
  MEMORY_POOL_SIZE
#+END_EXAMPLE

    is defined ferret program will use a memory pool instead of
    /mallac/,/free/, depending on the pool size ferret will allocate 
    /N/ bytes of memory on stack and all object creation
    happens in this memory pool useful when working with very limited
    amount of memory, such as micro controllers where you want
    complete control over the memory and you need deterministic timing
    requirements. Memory pooling also prevents heap fragmentation.

    (This should not be used in a multi threaded program.)

    For every page of memory allocated there is overhead of one
    /byte/ and one memory page is used for book keeping.

    When /allocate/ is called the pool will scan the memory pool using
    the /used/ array to find a block of memory big enough to
    satisfy the request. If found, it will the mark the region as used and
    return a pointer from /pool/ array to the user which points to
    the memory block. First page of the memory block is used for book
    keeping information, it holds the amount of memory allocated.

    When a free request is received, we resolve the pointer in to the
    memory pool read the book keeping information on how much memory
    is allocated to this pointer and set these pages to unused.

    Memory pool has several advantages, it will avoid fragmentation,
    function related to each other will always keep their data close
    to each other in the array which improves data locality.

#+name: runtime-native-memory-pool
#+begin_src c++ :tangle no
  #ifdef MEMORY_POOL_SIZE
  template<typename PageSize, size_t poolSize, typename UsedArrayType>
  class MemoryPool{
  public:
    UsedArrayType used[poolSize];
    PageSize pool[poolSize];
    size_t lastAllocationIndex;
    
    inline size_t calculateNeededPages(size_t size){
      size_t d = (size / sizeof(PageSize));
      size_t f = (size % sizeof(PageSize));

      if (f == 0)
        return d;
      else
        return (d + 1);
    }
      
    MemoryPool(){
      lastAllocationIndex = 0;
      for(size_t i = 0; i < poolSize; i++){
        pool[i] = 0;
        used[i] = 0;
      }
    }
    
    inline bool isPageRangeUsable(size_t begin,size_t end){
      for(size_t i=begin; i < end; i++)
        if (used[i] != 0)
          return false;
      return true;
    }
    
    inline size_t nextAvaliblePage(size_t offset){
      for(size_t i=offset; i < poolSize; i++)
        if (used[i] == 0)
          return i;
      return poolSize;
    }
      
    inline int findPage(size_t pagesNeeded, size_t os = 0){
      size_t offset = os;
    
      for(;;){
        int page = nextAvaliblePage(offset);
    
        if ((page + pagesNeeded) > poolSize)
          break;
          
        if (isPageRangeUsable(page,(page + pagesNeeded)) == true)
          return page;

        offset = (page + pagesNeeded);
      }
        
      return -1;
    }
      
    void *allocate(size_t reqSize){
      size_t length = calculateNeededPages(reqSize);
      int page = findPage(length,lastAllocationIndex);
      
      if ( page == -1){
        page = findPage(length,0);
        if (page == -1 )
          return NULL;
      }
      
      used[page] = reqSize;
      for(size_t i = page + 1; i < (page+length); i++)
        used[i] = 1;
        
      lastAllocationIndex = page + length;
      return &pool[page];
    }
    
    void free(void *p){
      PageSize* ptr = static_cast<PageSize*>(p);
      ptrdiff_t index = (ptr - pool);
      size_t length = calculateNeededPages(used[index]);
        
      for(size_t i = index ; i < (index+length); i++)
        used[i] = 0;
    }
  };

   #if !defined(MEMORY_POOL_PAGE_TYPE)
    MemoryPool<long,(MEMORY_POOL_SIZE/sizeof(long)),unsigned char> ProgramMemory;
   #else
    MemoryPool<MEMORY_POOL_PAGE_TYPE,MEMORY_POOL_SIZE,MEMORY_POOL_USED_ARRAY_TYPE> ProgramMemory;
   #endif
  #endif
#+end_src

#+name: runtime-clojure-memory-pool-tests
#+begin_src clojure :tangle no
  (deftest memory-pool-test
    (is (= "0 2 6 2 1 1 1 1 1 "
           (capture-output
            '((native-define "#define MEMORY_POOL_SIZE 2048")
              (native-declare "ferret::MemoryPool<size_t,10,size_t> mem;")
              (native-declare "void* ptr;")
              ((fn [] "std::cout << mem.nextAvaliblePage(0) << \" \";"))
              ((fn [] "mem.allocate(sizeof(size_t)*2);"))
              ((fn [] "std::cout << mem.nextAvaliblePage(0) << \" \";"))
              ((fn [] "ptr = mem.allocate(sizeof(size_t)*4);"))
              ((fn [] "std::cout << mem.nextAvaliblePage(2) << \" \";"))
              ((fn [] "mem.free(ptr);"))
              ((fn [] "std::cout << mem.nextAvaliblePage(2) << \" \";"))
              ((fn [] "std::cout << (NULL == mem.allocate(sizeof(size_t)*40)) << \" \";"))
              ((fn [] "std::cout << (NULL != mem.allocate(sizeof(size_t)*6)) << \" \";"))
              ((fn [] "std::cout << (NULL != mem.allocate(sizeof(size_t)*1)) << \" \";"))
              ((fn [] "std::cout << (NULL != mem.allocate(sizeof(size_t)*1)) << \" \";"))
              ((fn [] "std::cout << (NULL == mem.allocate(sizeof(size_t)*10)) << \" \";")))))))
#+end_src

*** Memory Allocation/Deallocation

Dispatch correct memory allocation/deallocation implementation,

#+name: runtime-native-memory-management-macros
#+begin_src c++ :tangle no
  #ifdef MEMORY_POOL_SIZE
    #define ALLOCATE(size) ProgramMemory.allocate(size)
    #define FREE(pre) ProgramMemory.free(ptr)
  #else
    #define ALLOCATE(size) malloc(size)
    #define FREE(ptr) free(ptr)
  #endif
#+end_src

#+name: runtime-native-memory-management-macros
#+begin_src c++ :tangle no
  #define NEW_REF() size_t refCount;
  #define INIT_REF() refCount = 0;
  #define INC_REF(this) refCount++;
  #define DEC_REF(this) (--refCount <= 0);
#+end_src

*** Object

All our types are derived from the base Object type,

#+name: runtime-native-object
#+begin_src c++ :tangle no
  class Object{
  public:
    Object(){
      INIT_REF();
      INIT_LOCK(lock);
    }
    
    virtual ~Object() {
      DELETE_LOCK(lock);
    };
    
    virtual size_t getType() = 0;
    
  #if !defined(DISABLE_OUTPUT_STREAM)
    virtual var toOutputStream() = 0;
  #endif
    
    virtual var equals(var o) = 0;
    
    void addRef() {
      WITH_LOCK(lock,{INC_REF(this)});
    }
    
    bool subRef() {
      bool ret;
      WITH_LOCK(lock,{
          ret = DEC_REF(this);
      });
      return ret;
    }
    
    void* operator new(size_t size){
      return ALLOCATE(size);
    }
    
    void  operator delete(void * ptr){
      FREE(ptr);
    }
    
  private:
    NEW_REF()
    NEW_LOCK(lock)
  };
#+end_src

*** Pointer

An object to hold a reference to a C++ pointer,

#+name: runtime-clojure-pointer-object
#+begin_src clojure :tangle no
  (defobject Pointer
    (data "void* ptr;")
    (new ("void* p" "ptr = p;"))
    (equals
     "return NewBoolean(ptr == o.cast<Pointer>()->ptr);")
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"Pointer<%p>\",ptr); return nil();")
    (post-code "var NewPointer(void * p) {
                  return var(new Pointer(p));
                }
                template<typename T>
                T* ToPointer(var p) {
                  return ((T *)p.cast<Pointer>()->ptr);
                }"))
#+end_src

*** Number

There is only one number type in ferret. All numbers are kept as
ratios. Default number size is /int/. A ratio is kept in memory as two
/NUMBER_DATA_TYPE/ size members named /numerator/ and /denominator/.

Math configuration,

#+name: runtime-native-math-config-macros
#+begin_src c++ :tangle no
  #define NUMBER_PRECISION 1000 //used when reading floats.
  #define NUMBER_DATA_TYPE int
  #define NUMBER_TYPE_FORMAT "%d"
#+end_src

Number Object,

#+name: runtime-clojure-number-object
#+begin_src clojure :tangle no
  (defobject Number
    (data "NUMBER_DATA_TYPE numerator;"
          "NUMBER_DATA_TYPE denominator;")
    (new ("NUMBER_DATA_TYPE x"
          "numerator = x; denominator = 1;")
         ("NUMBER_DATA_TYPE n, NUMBER_DATA_TYPE dn"
          "numerator = n; denominator = dn; simplificate();")
         ("float x"
          "float decimal = (x - (NUMBER_DATA_TYPE)x) * (float)NUMBER_PRECISION;
           NUMBER_DATA_TYPE integer = (NUMBER_DATA_TYPE)x;
           numerator = decimal + (integer * NUMBER_PRECISION);
           denominator = NUMBER_PRECISION;
           simplificate();"))
    (equals "size_t self_type = getType();
             size_t other_type = o.cast<Object>()->getType();
             if (self_type == NUMBER_TYPE && other_type == NUMBER_TYPE)
               if (getNumerator() == 0 && o.cast<Number>()->getNumerator() == 0)
                 return NewBoolean(true);
               else
                 return NewBoolean((getNumerator() == o.cast<Number>()->getNumerator()) &&
                                    (getDenominator() == o.cast<Number>()->getDenominator()));
             else
               return NewBoolean(false);")
    (toOutputStream
     "if (denominator == 1)
        fprintf(OUTPUT_STREAM, NUMBER_TYPE_FORMAT, numerator);
      else if (numerator == 0)
        fprintf(OUTPUT_STREAM, \"0\");
      else{
        fprintf(OUTPUT_STREAM, NUMBER_TYPE_FORMAT,numerator);
        fprintf(OUTPUT_STREAM, \"/\");
        fprintf(OUTPUT_STREAM, NUMBER_TYPE_FORMAT,denominator);
      }
      return nil();")
    
    (fns
     ("NUMBER_DATA_TYPE getNumerator" "" "return numerator;")
     ("NUMBER_DATA_TYPE getDenominator" "" "return denominator;")
     ("float floatValue" "" "return (float)numerator/(float)denominator;")
     ("int intValue" ""
      "if (denominator == 1)
          return (int)numerator;
        else
          return (int)floatValue();")
     ("void simplificate" ""
      "int commondivisor = 1;
        for(NUMBER_DATA_TYPE i=2;i<=runtime::min(runtime::abs(numerator), runtime::abs(denominator));i++)
          if( numerator%i == 0 && denominator%i == 0 )
            commondivisor = i;
        numerator /= commondivisor;
        denominator /= commondivisor;")
     ("~Number" "" ""))
    (post-code "var NewNumber(NUMBER_DATA_TYPE i) {
                  return var(new Number(i));
                }
                var NewRatio(NUMBER_DATA_TYPE n,NUMBER_DATA_TYPE dn) {
                  return var(new Number(n,dn));
                }
                int ToInt(var i) {
                  return (i.cast<Number>()->intValue());
                }"))
#+end_src

*** Keyword

Each keyword in the program is converted to an /Keyword/ object. A
/Keyword/ holds a simple hash of the keyword as an integer.

#+name: runtime-clojure-keyword-object
#+begin_src clojure :tangle no
  (defobject Keyword
    (data "int id;")
    (new ("int b" "id=b;")
         ("const char * str"
          "id = 0;
           for (int i = 0; str[i] != '\\0'; i++){
             id = id + (int)str[i];
           }"))
    (equals
     "if (!o.isType(KEYWORD_TYPE))
        return NewBoolean(false);
      return NewBoolean(id == o.cast<Keyword>()->id);")
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"%d\", id); return nil();")
    (fns ("bool equals" "Keyword k"
          "return (id == k.id);"))
    (post-code "template<typename T>
                var NewKeyword(T k) {
                  return var(new Keyword(k));
                }"))
#+end_src

#+name: native-keyword-tests
#+begin_src clojure :tangle no
  (deftest native-keyword-test
    (is (= "true false true"
           (capture-output '((print (= :test :test)
                                    (= :test :other_test)
                                    ((fn [keyword]
                                       "__result = NewBoolean(keyword.equals(NewKeyword(\":space\")))")
                                     :space)))))))
#+end_src

*** Character

Holds a native /char/ type.

#+name: runtime-clojure-character-object
#+begin_src clojure :tangle no
  (defobject Character
    (data "char value;")
    (new ("char c" "value = c;"))
    (equals
     "if (!o.isType(CHARACTER_TYPE))
        return NewBoolean(false);
      return NewBoolean(value == o.cast<Character>()->value);")
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"%c\",value); return nil();")
    (post-code "var NewCharacter(char c) {
                  return var(new Character(c));
                }"))
#+end_src

*** Seekable Interface

All sequence functions use this interface to iterate seekable
containers.

#+name: runtime-clojure-seekable-interface
#+begin_src clojure :tangle no
  (defobject ISeekable
    (interfaces "var cons(var x)"
                "var first()"
                "var rest()"
                "size_t count()")
    (fns ("virtual ~ISeekable" "" "")))
#+end_src

#+name: runtime-native-iseekable-headers
#+begin_src c++ :tangle no
  namespace ferret{
    var FIRST(var coll);
    var REST(var coll);
    var CONS(var seq, var x);
    var NTH(var seq, var index);
  }
#+end_src

#+name: runtime-native-iseekable-functions
#+begin_src c++ :tangle no
  namespace ferret{
    var FIRST(var coll){
      if (coll.isNil())
        return nil();
      else
        return coll.cast<ISeekable>()->first();
    }

    var REST(var coll){
      if (coll.isNil())
        return NewSequence();
      else
        return coll.cast<ISeekable>()->rest();
    }

    var CONS(var seq, var x){
      if (seq.isNil())
        seq = NewSequence();
      return seq.cast<ISeekable>()->cons(x);
    }
    
    var NTH(var seq, var idx){
      int index = ToInt(idx);

      if ( index < 0 || seq.cast<ISeekable>()->count() < idx)
        return nil();
      
      var head = seq;
      for(int i=0; i < index; i++)
        head = REST(head);
      return FIRST(head);
    }
  }
#+end_src

#+name: runtime-native-object-casting-macros
#+begin_src c++ :tangle no
  #define ITERATE(c,i) for(var i = c; !REST(i).isNil(); i = REST(i))
#+end_src

*** Sequence

A simple linked list container implementing the seekable interface.

#+name: runtime-clojure-sequence-object
#+begin_src clojure :tangle no
  (defobject Sequence
    (interface :ISeekable)
    (data "var next;"
          "var data;"
          "size_t size;")
    (new ("var d = NULL, var n = NULL, size_t s = 0"
          "next = n; data = d; size = s;"))

    (equals
     "if (!o.isType(SEQUENCE_TYPE))
       return NewBoolean(false);

      var itOther = o;
      ITERATE(this,it){
        if (itOther.isNil() || FIRST(it).equals(FIRST(itOther))  == false)
          return NewBoolean(false);
        itOther = REST(itOther);
      }
      return NewBoolean(true);")
    
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"(\");
      if (!next.isNil()){ 
        data.toOutputStream();
        ITERATE(next,it){
          fprintf(OUTPUT_STREAM, \" \");
          FIRST(it).toOutputStream();
        }
      }
      fprintf(OUTPUT_STREAM, \")\");
      return nil();")
    (fns
     ("var cons" "var x"
      "return var(new Sequence(x, this, (size + 1)));")
     ("var first" ""
      "return data;")
     ("var rest" ""
      "return next;")
     ("size_t count" ""
      "return size;"))
    (post-code "var NewSequence() {return var(new Sequence());}"))
#+end_src

*** Lazy Sequence

A lazy list container implementing the seekable interface.

#+name: runtime-clojure-sequence-object
#+begin_src clojure :tangle no
  (defobject LazySequence
    (interface :ISeekable)
    (data "var seq;")
    (new ("var t"
          "seq = NewSequence();
           seq.cast<Sequence>()->next = t;")
         ("var d, var t"
          "seq = NewSequence();
           seq.cast<Sequence>()->data = d; seq.cast<Sequence>()->next = t;"))
    (equals
     "if (o.cast<Object>()->getType() != LAZYSEQUENCE_TYPE)
       return NewBoolean(false);
      var itOther = o;
      ITERATE(this,it){
        if (itOther.isNil() || FIRST(it).equals(FIRST(itOther))  == false)
          return NewBoolean(false);
        itOther = REST(itOther);
      }
      return NewBoolean(true);")
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"(\");
        if (!seq.isNil()){ 
          seq.cast<Sequence>()->data.toOutputStream();
          ITERATE(REST(var(this)),it){
            fprintf(OUTPUT_STREAM, \" \");
            FIRST(it).toOutputStream();
          }
        }
        fprintf(OUTPUT_STREAM, \")\");
        return nil();")
    
    (fns
     ("var cons" "var x"
      "return var(new LazySequence(x,seq.cast<Sequence>()->next));")
     
     ("var first" ""
      "return seq.cast<Sequence>()->data;")
     ("var iterate" ""
      "var s = _i(seq.cast<Sequence>()->next);
       if (s.isNil())
         return NewSequence();

       var data = (s.cast<LazySequence>()->seq).cast<Sequence>()->data;
       var next = (s.cast<LazySequence>()->seq).cast<Sequence>()->next;

       return var(new LazySequence(data,next));")
     ("var rest" ""
      "return iterate();")
     ("size_t count" ""
      "size_t acc = 1;
       var s = iterate();
       while(!s.equals(NewSequence())){ 
        s = REST(s);
        acc++;
       }
       return acc;"))
    (post-code "var NewLazySequence(var d, var t) {
                  return var(new LazySequence(d,t));
                }"))
#+end_src

#+name: runtime-clojure-sequence-object
#+begin_src clojure :tangle no
  (defn new-lazy-seq [f]
    "__result = var(new LazySequence(f));")

  (defmacro lazy-seq [& body]
    (list 'new-lazy-seq (cons 'fn `( [] ~@body))))
#+end_src

#+name: runtime-clojure-sequences-tests
#+begin_src clojure :tangle no
  (deftest lazy-sequence-test
    (is (= "10 11 12 (10 9 8 7 6 5 4 3 2 1 0)"
           (capture-output '((let [a 1]
                               (defn lazy-countdown [n]
                                 (if (>= n 0)
                                   (cons n (lazy-seq (lazy-countdown (- n 1))))))
                               
                               (defn ints-from [n]
                                 (cons n (lazy-seq (ints-from (inc n))))))
                             
                             (print (first (ints-from 10))
                                    (first (rest (ints-from 10)))
                                    (first (rest (rest (ints-from 10))))
                                    (lazy-countdown 10)))))))
#+end_src

*** String

Strings are represented as a linked list of characters.

#+name: runtime-clojure-string-object
#+begin_src clojure :tangle no
  (defobject String
    (interface :ISeekable)
    (data "var data;")
    (new (""
          "data = NULL;")
         ("var s"
          "data = s;")
         ("const char * str"
          "int length = 0;
           for (length = 0; str[length] != '\\0'; length++);
           length--;
           var s = var(new Sequence());
           for (int i = length; i >= 0; i--)
             s = s.cast<ISeekable>()->cons(var(new Character(str[i])));
           data = s;"))
    (equals
     "if (!o.isType(STRING_TYPE))
       return NewBoolean(false);
      return NewBoolean(data.equals(o.cast<String>()->data));")
    (toOutputStream
     "ITERATE(data,it){ FIRST(it).toOutputStream(); }
      return nil();")
    (fns
     ("var cons" "var x"
      "return data.cast<ISeekable>()->cons(x);")
     ("var first" ""
      "return FIRST(data);")
     ("var rest" ""
      "return REST(data);")
     ("size_t count" ""
      "return data.cast<ISeekable>()->count();")
     ("ifdef STD_LIB"
      "std::string toString" ""
      "std::stringstream ss;
       ITERATE(data,it){ss << FIRST(it).cast<Character>()->value;}
       return ss.str();"))
    (post-code "template<typename T>
                var NewString(T s) {
                    return var(new String(s));
                }
                #if defined(STD_LIB)
                const char* ToCStr(var s) {
                  return (s.cast<String>()->toString().c_str());
                }
                #endif"))
#+end_src

#+name: native-string-tests
#+begin_src clojure :tangle no
  (deftest native-string-test
    (is (= "Some String false true false true"
           (capture-output '((print "Some String"
                                    (= "Some String" "Other String")
                                    (= "Some String" "Some String")
                                    (= "Some String" 1)
                                    ((fn [str] "__result = NewBoolean((str.cast<String>()->toString() == \"String\"))")
                                     "String")
                                    ))))))
#+end_src

*** Boolean

A boolean object,

#+name: runtime-clojure-boolean-object
#+begin_src clojure :tangle no
  (defobject Boolean
    (data "bool value;")
    (new ("bool b" "value = b;"))
    (equals "if (!o.isType(BOOLEAN_TYPE))
               return var(new Boolean(false));
             return var(new Boolean((value == o.cast<Boolean>()->value)));")
    (toOutputStream
     "if (value)
        fprintf(OUTPUT_STREAM, \"true\"); 
      else
      fprintf(OUTPUT_STREAM, \"false\"); 
      return nil();")
    
    (post-code "var NewBoolean(bool b){
                 return var(new Boolean(b));
                };
                var::operator bool() const {
                  if (m_ptr == NULL)
                    return false;
                  else if (m_ptr->getType() == BOOLEAN_TYPE)
                    return static_cast<Boolean*>(m_ptr)->value;
                    else
                      return true;
                  }
                
                  bool var::equals (var rhs){
                    if (get() == rhs.get())
                      return true;
                    else
                      return (get()->equals(rhs)).cast<Boolean>()->value;
                  }"))
#+end_src

*** Atom

Mimics Clojure's /atom/. It is thread safe when used on system where
/STD_LIB/ is defined.

#+name: runtime-clojure-atom-object
#+begin_src clojure :tangle no
  (defobject Atom
    (data "var data;"
          "NEW_LOCK(lock)")
    (new ("var d"
          "data = d;
           INIT_LOCK(lock);"))
    (equals "if (!o.isType(ATOM_TYPE))
                 return NewBoolean(false);
               return NewBoolean(this == o.cast<Atom>());")
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"atom <\");
      data.toOutputStream();
      fprintf(OUTPUT_STREAM, \">\");
      return nil();")
    (fns
     ("~Atom" ""
      "DELETE_LOCK(lock);")
     ("var swap" "var f,var args"
      "WITH_LOCK(lock,{
         args = CONS(args,data);
         data = f.cast<Lambda>()->invoke(args);
       });
      return data;"))
    (post-code "var NewAtom(var v) {
                  return var(new Atom(v));
                }"))
#+end_src

Operations on /Atoms/

#+name: runtime-clojure-atom-object
#+begin_src clojure :tangle no
  (defn atom [x]
    "__result = NewAtom(x)")

  (defn swap! [a f & args]
    "__result = a.cast<Atom>()->swap(f,args);")

  (defn reset! [a newval]
    (swap! a (fn [old curr] curr) newval))

  (defn deref [a]
    "__result = a.cast<Atom>()->data;")
#+end_src

#+name: runtime-native-atom-tests
#+begin_src clojure :tangle no
  (deftest atom-tests
    (is (= "nil12(1 2 3)6truefalsefalse"
           (capture-output '((let [a (atom nil)
                                   b (atom nil)]
                               (print (deref a))
                               (reset! a 1)
                               (print (deref a))
                               (swap! a inc)
                               (print (deref a))
                               (reset! a (list 1 2 3))
                               (print (deref a))
                               (swap! a (fn [l] (reduce + l)))
                               (print (deref a))
                               (print (= a a))
                               (print (= a b))
                               (print (= a 1))))))))
#+end_src

*** Lambda

Every lambda object implements the /Lambda/ interface. All lambdas are
executed via /invoke/ method that takes a that takes a sequence of
vars as argument or /nil()/ if there are non, this allows us
to execute them in a uniform fashion.

#+name: runtime-clojure-lambda-interface
#+begin_src clojure :tangle no
  (defobject Lambda
    (interfaces "var invoke(var args)")
    (equals "if (!o.isType(LAMBDA_TYPE))
                 return NewBoolean(false);
               return NewBoolean(this == o.cast<Lambda>());")
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"lambda\"); return nil();")
    (force-type true))
#+end_src

Function invocation,

#+name: function-invocation-api-headers
#+begin_src c++ :tangle no
  namespace ferret{
    template<typename T>        
    T __list(T v);
        
    template<typename T, typename... Args>
    T __list(T first, Args... args);
        
    template<typename T, typename... Args>
    var _i(T fn, Args... args);
        
    template<typename T>
    var _i(T fn);

    template<>
    var _i(var);

    template<typename T>
    var fn(){
      return var(new T());
    }

    template<typename T, typename... Args>
    var closure(Args... args) {
      return var(new T(args...));
    }
  }
#+end_src

#+name: function-invocation-api
#+begin_src c++ :tangle no
  namespace ferret{
    template<typename T>        
    T __list(T v) {
      return v;
    }

    template<typename T, typename... Args>
    T __list(T first, Args... args) {

      return var(new Sequence(first, __list(args...), (sizeof...(args))));
    }

    template<typename T, typename... Args>
    var _i(T fn, Args... args) {
      return fn.invoke(__list(args...,var(new Sequence(NULL,NULL))));
    }

    template<typename T>
    var _i(T fn) {
      return fn.invoke(nil());
    }

    template<>
    var _i(var fn) {
      return fn.cast<Lambda>()->invoke(nil());
    }

    template<typename... Args>
    var _i(var fn, Args... args) {
      return fn.cast<Lambda>()->invoke(__list(args...,var(new Sequence(NULL,NULL))));
    }
  }
#+end_src

#+name: native-lambda-test
#+begin_src clojure :tangle no
  (deftest native-lambda-test
    (is (= "true false true false 1 2 3 4"
           (capture-output '((let [f1 (fn [])
                                   f2 (fn [])
                                   m-func (fn
                                            ([a] 1)
                                            ([a b] 2)
                                            ([a b & c] 3)
                                            ([a b [c d] & e] 4))]
                               (print (= f1 f1)
                                      (= f1 f2)
                                      (= f1 (do f1))
                                      (= f2 (do f1)))
                               (print " ")
                               (print (m-func 1)
                                      (m-func 1 2)
                                      (m-func 1 2 3)
                                      (m-func 1 2 (list 3 3) 4))))))))
#+end_src

*** var

Garbage collection is handled by reference counting, a /var/ holds a
pointer to an Object, everything is passed around as /vars/ it is
responsible for incrementing/decrementing the reference count, when it
reaches zero it will automatically free the Object. 

#+name: runtime-native-var
#+begin_src c++ :tangle no
  class var{
  public:
    var(Object* ptr=0) : m_ptr(ptr) { addRef(); }

    var(const var& p) : m_ptr(p.m_ptr) { addRef(); }
      
    ~var() { subRef(); }
      
    var& operator= (const var& p){
      return *this = p.m_ptr;
    }

    bool equals (var rhs);
      
    var& operator= (Object* ptr){
      if (m_ptr != ptr){
        subRef();
        m_ptr=ptr;
        addRef();
      }
      return *this;
    }

    operator bool() const;

  #if !defined(DISABLE_OUTPUT_STREAM)
    var toOutputStream() {
      if (m_ptr != NULL )
        m_ptr->toOutputStream();
      else
        fprintf(OUTPUT_STREAM, "nil");
      return var();
    }
  #endif
        
    Object* get() { return m_ptr; }
    template<typename T>
    T* cast() { return static_cast<T*>(m_ptr); }

    bool isType(size_t type) { 
      return (static_cast<Object*>(m_ptr)->getType() == type);
    }

    bool isNil() { 
      return (m_ptr == NULL);
    }

  private:
    void addRef(){
      // Only change if non-null
      if (m_ptr) m_ptr->addRef();
    }
      
    void subRef(){
      // Only change if non-null
      if (m_ptr){
        // Subtract and test if this was the last pointer.
        if (m_ptr->subRef()){
          delete m_ptr;
          m_ptr=0;
        }
      }
    }
      
    Object* m_ptr;
  };

  var nil(){
    return var();
  }
#+end_src

*** Program Header

Some options can be configured using /#define/ directives, these can
be defined using /native-define/ from program code. When,

#+BEGIN_EXAMPLE
  #define MEMORY_POOL_SIZE 2048
#+END_EXAMPLE

is defined program will will use a memory pool that's
/(2048/sizeof(size_t))/. (Allocates 2048 /bytes/)

You can also change memory pools page size so instead of /size_t/
pages you can use a pool of /char/ pages using,

#+BEGIN_EXAMPLE
  #define MEMORY_POOL_PAGE_TYPE char
#+END_EXAMPLE
    
By default Numbers use int to hold data use,

#+BEGIN_EXAMPLE
  #define NUMBER_DATA_TYPE long
  #define NUMBER_DATA_TYPE_FORMAT "%ld"
#+END_EXAMPLE

to switch to longs for number data.

To disable output stream (usefull on micro controllers to reduce code
size.) use,

#+BEGIN_EXAMPLE
  #define DISABLE_OUTPUT_STREAM true
#+END_EXAMPLE

To disable main use,

#+BEGIN_EXAMPLE
  #define DISABLE_MAIN_FUNCTION true
#+END_EXAMPLE

main won't be defined you need to call /ferret::ProgramRun()/ manually
to start the program. Detect host,

When

#+BEGIN_EXAMPLE
  #define PROGRAM_MAIN some_func
#+END_EXAMPLE

is defined defined lambda will be invoked after
/ferret::ProgramRun()/, acts as the programs main\//-main/ function.

When 

#+BEGIN_EXAMPLE
  #define SINGLE_THREADED true
#+END_EXAMPLE

is used it will disable locking for built in data structures. By
default when compiling with non embedded compiler. It will use /POSIX/
/mutexes/ for locking /Objects/.

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
  #if defined(__SAM3X8E__)
    # define ARDUINO TRUE
    # define ARDUINO_DUE TRUE
    # define DISABLE_MAIN_FUNCTION true
  #elif defined(__AVR__)
    # define ARDUINO TRUE
    # define ARDUINO_UNO TRUE
    # define DISABLE_MAIN_FUNCTION true
  #else
    # define STD_LIB TRUE
  #endif
#+end_src

Import libraries,

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
  #ifdef STD_LIB
   #include <iostream>
   #include <sstream>
   #include <cstdio>
   #include <cstdlib>
  #endif

  #ifdef ARDUINO
   #include <Arduino.h>
   #include <stdio.h>
   #include <stdlib.h>
  #endif
#+end_src

Host specific initialization code, if running on the Arduino platform
fix pure virtual functions,

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
#ifdef ARDUINO
  extern "C" void __cxa_pure_virtual(void);
#endif
#+end_src

Setup printing on different boards,

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
#if defined(ARDUINO_UNO) && !defined(DISABLE_OUTPUT_STREAM)
  static FILE uartout = {0};

  static int uart_putchar (char c, FILE *stream){
    Serial.write(c);
    return 0 ;
  }

  #define OUTPUT_STREAM &uartout
#endif
#+end_src

DUE,

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
#if defined(ARDUINO_DUE) && !defined(DISABLE_OUTPUT_STREAM)
 #define OUTPUT_STREAM stdout
#endif
#+end_src

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
#ifdef ARDUINO_DUE
 #if !defined(DISABLE_OUTPUT_STREAM)
  #define INIT_OUTPUT_STREAM Serial.begin(9600);
 #else
  #define INIT_OUTPUT_STREAM ;
 #endif
#endif
#+end_src

UNO,

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
#ifdef ARDUINO_UNO
 #if !defined(DISABLE_OUTPUT_STREAM)
  #define INIT_OUTPUT_STREAM                                              \
    Serial.begin(9600);                                                   \
    fdev_setup_stream (&uartout, uart_putchar, NULL, _FDEV_SETUP_WRITE);
 #else
  #define INIT_OUTPUT_STREAM ;
 #endif
#endif
#+end_src

When C++ Standard Library is present

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
#ifdef STD_LIB
 #define OUTPUT_STREAM stdout
#endif
#+end_src

Misc,

#+name: runtime-native-program-misc
#+begin_src c++ :tangle no
  namespace ferret{
    namespace runtime{
      #undef min
      #undef abs
      template<typename T>
        T min(T a, T b){
        return ((a)<(b)?(a):(b));
      }

      template<typename T>
        T abs(T a){
        return ((a)<0 ? -(a) : (a));
      }
    }
  }
#+end_src

** Lisp

Once our object system is in place we can define rest of the runtime
(functions/macros) using our Clojure subset,

#+name: runtime-clojure-first
#+begin_src clojure :tangle no
  (defn first [x]
    "__result = FIRST(x);")

  (defn nil? [x] "__result = NewBoolean(x.isNil())")

  (defn char? [x] "__result = x.isType(CHARACTER_TYPE);")
#+end_src

We can embed C++ code into our functions, which is how most of the
primitive functions are defined such as the /first/ function above,
once primitives are in place rest can be defined in pure Clojure,

#+name: runtime-clojure-println
#+begin_src clojure :tangle no
  (defn println [& more]
    (when more
      (apply print more))
    (newline))
#+end_src

As for macros, normal Clojure rules apply since they are expended using
Clojure, the only exception is that stuff should not expand to fully
qualified Clojure symbols, so the symbol /fn/ should not expand to
/clojure.core/fn/,

#+name: runtime-clojure-defn
#+begin_src clojure :tangle no
  (defmacro defn [name & body]
    (list 'def name (cons 'fn `~body)))

  (defmacro native-header [& body]
    (cons 'native-declare
          (->> (map #(if (symbol? %)
                       (str "#include \"" (str %) ".h\"\n")
                       (str "#include \"" (str %) "\"\n"))
                    body)
               (apply str)
               (list))))

  (defmacro configure-runtime! [& body]
    (cons 'native-define
          (->> (partition 2 body)
               (map #(str "#define " (first %) " " (second %) "\n"))
               (list))))

  (defmacro configure-ferret! [& body]
    (list 'native-define (str "// Ferret Build Configuration Begin\n"
                              "//" (str (apply hash-map body)) "\n"
                              "// Ferret Build Configuration End\n")))

  (defmacro defnative [name args & form]
    (let [includes (->> (filter #(seq? (nth % 2)) form)
                        (map #(cons (nth % 1) (apply list (nth % 2))))
                        (map (fn [form]
                               (let [[guard & headers] form]
                                 (str "\n#if " guard " \n"
                                      (apply str (map #(str "#include \"" % "\"\n") headers))
                                      "#endif\n"))))
                        (map #(list 'native-declare %)))
          body (->> (map #(vector (second %) (last %)) form)
                    (map #(str "\n#if " (first %) " \n"
                               (second %)
                               "\n#endif\n"))
                    (apply str))
          pre-ample (->> (map #(vector (second %) (drop-last (drop 3 %))) form)
                         (map #(str "\n#if " (first %) " \n"
                                    (apply str (map (fn [line] (str line "\n")) (second %)))
                                    "\n#endif\n"))
                         (map #(list 'native-declare %)))]
      (list 'def name (cons 'fn* `( ~args ~@includes ~@pre-ample  ~body)))))
#+end_src

*** Misc

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defn identity [x] x)

  (defnative sleep [millis]
    (on "defined STD_LIB"
        "usleep(ToInt(millis) * 1000L);")
    (on "defined ARDUINO"
        "::delay(ToInt(millis));"))

  (defnative get-char []
    (on "defined STD_LIB"
        "__result = NewCharacter(getchar());"))

  (defmacro defcallback [callback out in & pass-vars]
    (list 'do
          (list 'native-declare
                `~(str "\n" out " " (symbol-conversion callback) "_callack" "(" in "){\n"
                       "_i(" (str (symbol-conversion callback) "_callback_fn")
                       (str \, (apply str (interpose " , " (reverse pass-vars)))) ");"
                       "\n}\n"))
          (list 'def `~(symbol (str callback "-callback-fn")) `~callback)))

  (defnative sh [cmd]
    (on "defined STD_LIB"
        ("memory")
        "std::shared_ptr<FILE> pipe(popen(ToCStr(cmd), \"r\"), pclose);
         if (!pipe) 
            __result = nil();
         char buffer[128];
         std::string result = \"\";
         while (!feof(pipe.get()))
          if (fgets(buffer, 128, pipe.get()) != NULL)
           result += buffer;
         __result = NewString(result.c_str());"))

  (defn system-exit [code]
    "std::exit(ToInt(code));")

  (defnative memory-pool-free-pages []
    (on "defined MEMORY_POOL_SIZE"
        "int count = 0;
         for(int i = 0; i < MEMORY_POOL_SIZE; i++)
           if(ProgramMemory.used[i] == false)
             count++;
         __result = NewNumber(count);"))

  (defnative memory-pool-print-snapshot []
    (on "defined MEMORY_POOL_SIZE"
        "for(int i = 0; i < MEMORY_POOL_SIZE; i++)
           fprintf(OUTPUT_STREAM, \"%d\",ProgramMemory.used.get(i));
        fprintf(OUTPUT_STREAM, \"\\n\");
         __result = nil();"))

  (defn memory-sizeof-ferret-objects []
    (println "var:" ((fn [] "__result = NewNumber((NUMBER_DATA_TYPE)sizeof(var));")))
    (println "Object:" ((fn [] "__result = NewNumber((NUMBER_DATA_TYPE)sizeof(Object));")))
    (println "Pointer:" ((fn [] "__result = NewNumber((NUMBER_DATA_TYPE)sizeof(Pointer));")))
    (println "Number:" ((fn [] "__result = NewNumber((NUMBER_DATA_TYPE)sizeof(Number));")))
    (println "Keyword:" ((fn [] "__result = NewNumber((NUMBER_DATA_TYPE)sizeof(Keyword));")))
    (println "Sequence:" ((fn [] "__result = NewNumber((NUMBER_DATA_TYPE)sizeof(Sequence));")))
    (println "Char:" ((fn [] "__result = NewNumber((NUMBER_DATA_TYPE)sizeof(Character));")))
    (println "String:" ((fn [] "__result = NewNumber((NUMBER_DATA_TYPE)sizeof(String));")))
    (println "Boolean:" ((fn [] "__result = NewNumber((NUMBER_DATA_TYPE)sizeof(Boolean));")))
    (println "Lambda:" ((fn [] "__result = NewNumber((NUMBER_DATA_TYPE)sizeof(Lambda));")))
    (println "Atom:" ((fn [] "__result = NewNumber((NUMBER_DATA_TYPE)sizeof(Atom));"))))
#+end_src

Takes a function and returns the number of millis took.

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defnative time [f]
    (on "defined STD_LIB"
        ("sys/time.h")
        "struct timeval  te;
         gettimeofday(&te, NULL);
         unsigned long begin = (int)(te.tv_sec*1000LL + te.tv_usec/1000); 
         _i(f);
         gettimeofday(&te, NULL);
         unsigned long end = (int)(te.tv_sec*1000LL + te.tv_usec/1000); 
         __result = NewNumber((NUMBER_DATA_TYPE)(end - begin));")
    (on "defined ARDUINO"
        "unsigned long begin = millis();
         _i(f);
         unsigned long end = millis();
         __result = NewNumber((NUMBER_DATA_TYPE)(end - begin));"))
#+end_src

Threads the expr through the forms. Inserts x as the
last item in the first form, making a list of it if it is not a
list already. If there are more forms, inserts the first form as the
last item in second form, etc.

#+name: runtime-clojure-misc-thread-macro
#+begin_src clojure :tangle no
  (defmacro ->> [x & forms]
    (loop [x x, forms forms]
      (if forms
        (let [form (first forms)
              threaded (if (seq? form)
                         `(~(first form) ~@(next form)  ~x)
                         (list form x))]
          (recur threaded (next forms)))
        x)))
#+end_src

Multi arity functions are handled by the /fn/ macro. There are two
ways to define a function. For single arity functions it accepts the
following form,

#+begin_src clojure :tangle no
  (fn [a] a)
#+end_src

For multi arity functions it expects the following form,

#+begin_src clojure :tangle no
  (fn
    ([a] 1)
    ([a b] 2)
    ([a b & c] 3)
    ([a b [c d] & e] 4))
#+end_src

A multi arity function is a function that counts the number of its
arguments and then dispatches on the number of arguments to each
implementation.

#+name: runtime-clojure-misc-thread-macro
#+begin_src clojure :tangle no
  (defmacro fn [& body]
    (if (vector? (first body))
      (let [[args & body] body]
        (cons 'fn* `(~args ~@body)))
      (let [count-symbol (gensym)
            fn-arg-symbol (gensym)
            fns (map #(cons 'fn* %) body)
            conds (->> (map first body)
                       (map (fn* [args] (filter #(not (= % '&)) args)))
                       (map #(count %)))
            form (if (pos? (.indexOf (last (map first body)) '&))
                   (let [conds (interleave conds fns)
                         arg-dispatch (drop-last 2 conds)
                         last (take-last 2 conds)]
                     (concat arg-dispatch [true (second last)]))
                   (interleave conds fns))]
        
        `(fn* (& ~(list 'ferret-compiler-no-closure fn-arg-symbol))
              ~(->> form
                    (cons fn-arg-symbol)
                    (cons 'dispatch-lambda))))))
#+end_src

*** Console I/O

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defnative print [& more]
    (on "!defined(DISABLE_OUTPUT_STREAM)"
        "if (more.isNil())
           return nil();
         var f = more.cast<ISeekable>()->first();
         f.toOutputStream();
         var r = more.cast<ISeekable>()->rest();
         ITERATE(r,it){
          fprintf(OUTPUT_STREAM, \" \");
          FIRST(it).toOutputStream();
         }"))

  (defnative newline [& more]
    (on "!defined(DISABLE_OUTPUT_STREAM)"
        "fprintf(OUTPUT_STREAM, \"\\n\");"))

  <<runtime-clojure-println>>
#+end_src

*** Looping

#+name: runtime-clojure-looping
#+begin_src clojure :tangle no
  (defmacro doseq [binding & body]
    (list '_doseq_ (second binding) (cons 'fn* `( [~(first binding)] ~@body))))

  (defn _doseq_ [seq f] "ITERATE(seq,it){_i(f,FIRST(it));}")

  (defmacro dotimes [binding & body]
    (list '_dotimes_ (second binding) (cons 'fn* `( [~(first binding)] ~@body))))

  (defn _dotimes_ [t f] "for(int i = 0; i < ToInt(t); i++) _i(f,NewNumber(i));")
#+end_src

*** Conditionals

#+name: runtime-clojure-conditionals
#+begin_src clojure :tangle no
  (defmacro when [test & body]
    (list 'if test (cons 'do body)))

  (defmacro cond
    [& clauses]
    (when clauses
      (list 'if (first clauses)
            (if (next clauses)
              (second clauses)
              (throw (IllegalArgumentException.
                      "cond requires an even number of forms")))
            (cons 'cond (next (next clauses))))))

  (defmacro while [test & body]
    (list '_while_ (list 'fn* [] test) (cons 'fn* `( [] ~@body))))

  (defn _while_ [pred fn]
    "while(_i(pred))
       _i(fn);")

  (defmacro forever [& body]
    (cons 'while `(true  ~@body)))

  (defmacro if-let
    ([bindings then]
     `(if-let ~bindings ~then nil))
    ([bindings then else & oldform]
     (let [form (bindings 0) tst (bindings 1)]
       `(let [temp# ~tst]
          (if temp#
            (let [~form temp#]
              ~then)
            ~else)))))
#+end_src

#+name: runtime-clojure-conditionals-tests
#+begin_src clojure :tangle no
  (deftest conditionals-test
    (is (= "2 1 -1 2 2 2 1 2 nil 5"
           (capture-output '((print (if 1 2)
                                    (if (zero? 0) 1 -1)
                                    (if (zero? 1) 1 -1)
                                    (when true 2)
                                    (when (integer? 2) 2)
                                    (cond (float? 2.1) 2
                                          (integer? 2) 4
                                          true 1)
                                    (cond (float? 2) 2.1
                                          (integer? 2.1) 4
                                          true 1)
                                    (if nil 1 2)
                                    (if-let [a nil]
                                      a)
                                    (if-let [a 5]
                                      a)))))))
#+end_src

*** Sequence

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn map [f col]
    (if (not (empty? col))
      (cons (f (first col))
            (lazy-seq (map f (rest col))))))
#+end_src

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn range
    ([high]
     (range 0 high))
    ([low high]
     (if (< low high)
       (cons low (lazy-seq
                  (range (inc low) high))))))
#+end_src

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn take [n coll]
    (if (not (empty? coll))
      (if (> n 0)
        (cons (first coll)
              (lazy-seq (take (- n 1) (rest coll)))))))
#+end_src

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn concat
    ([x]
     (if (not (empty? x))
       (cons (first x) (lazy-seq (concat (rest x))))))
    ([x y]
     (if (not (empty? x))
       (cons (first x) (lazy-seq (concat (rest x) y)))
       (concat y))))
#+end_src

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn reduce
    ([f [sf & sr]]
     "var acc = _i(f, FIRST(sr), sf);
      ITERATE(REST(sr),it){
        acc = _i(f, acc, FIRST(it));
      }
      return acc;")
    ([f acc coll]
     "ITERATE(coll,it){
       acc = _i(f, acc, FIRST(it));
      }
      return acc;"))
#+end_src

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn list [& xs] "if (xs.isNil())
                       __result = NewSequence();
                     else
                       __result = xs;")

  (defn list? [x] "__result = NewBoolean(x.isType(SEQUENCE_TYPE));")

  (defn empty? [x] "__result = NewBoolean(x.cast<ISeekable>()->count() == 0)")

  (defn rest [x] "var r = REST(x);
                  if (r.isNil())
                    return NewSequence();
                  else 
                    __result = r;")

  (defn nth [coll index] "__result = NTH(coll,index);")

  (defn cons [x seq] "__result = CONS(seq,x);")

  (defn apply [f args] "__result = f.cast<Lambda>()->invoke(args);")

  (defn conj [coll & xs]
    (reduce (fn[h v] (cons v h)) (if (nil? coll) (list) coll) xs))

  (defn reverse [s]
    (reduce conj (list) s))
#+end_src

#+name: runtime-clojure-sequence-count
#+begin_src clojure :tangle no
  (defn count [s]
    "if (s.isNil())
       return NewNumber(0);
     __result = NewNumber((NUMBER_DATA_TYPE)s.cast<ISeekable>()->count());")
#+end_src

#+name: runtime-clojure-sequences-tests
#+begin_src clojure :tangle no
  (deftest sequences-test
    (is (= "(1 2 3 4) 1 (2 3 4) (3 4) (3 3 4) 3 4 (4 3 2 1 1 2) (4 3 2 1) 21 21 (nil) (1) () nil 0"
           (capture-output '((print (list 1 2 3 4)
                                    (first (list 1 2 3 4))
                                    (rest (list 1 2 3 4))
                                    (rest (rest (list 1 2 3 4)))
                                    (cons 3 (rest (rest (list 1 2 3 4))))
                                    (first (cons 3 (rest (rest (list 1 2 3 4)))))
                                    (count (list 1 2 3 4))
                                    (conj (list 1 2) 1 2 3 4)
                                    (conj nil 1 2 3 4)
                                    (reduce + (list 1 2 3 4 5 6))
                                    (apply + (list 1 2 3 4 5 6))
                                    (cons nil nil)
                                    (cons 1 nil)
                                    (rest (list))
                                    (first (rest (rest (list))))
                                    (count (list )))))))
    (is (= "(6 5 4 3 2 1) (6 5 4 3 2) (4 3 2 1 0) (. o l l e H) true"
           (capture-output '((print (reverse (list 1 2 3 4 5 6))
                                    (reduce (fn [h v]
                                              (conj h (inc v))) (list) (list 1 2 3 4 5))
                                    (reduce (fn [h v]
                                              (conj h (dec v))) (list) (list 1 2 3 4 5))
                                    (reduce (fn [h v]
                                              (conj h v)) (list) "Hello.")
                                    (= (list ) (list )))))))

    (is (= "(1 2 3 4 5 6) (7 6 5 4 3 2) (1 7 6 5 4 3 2) true"
           (capture-output '((let [l1 (list 1 2 3 4 5 6)
                                   l2 (reduce (fn[h v] (conj h (inc v))) (list) l1)
                                   l3 (cons 1 l2)]
                               (print l1 l2 l3 (empty? (rest nil))))))))
    (is (= "(2 3 4) (0 1 2) (4 5 6) 3 (0 1 2 3 4) 5 (0 1 2 3 4 5 6 7 8 9) (2 3) (2 3 4) (1 2 3 4 5 6 7) 21"
           (capture-output '((print (map inc (list 1 2 3))
                                    (map dec (list 1 2 3))
                                    (map (fn [x] (+ 3 x)) (list 1 2 3))
                                    (count (map inc (list 1 2 3)))
                                    (range 5)
                                    (count (range 5))
                                    (range 0 10)
                                    (take 2 (map inc (list 1 2 3)))
                                    (take 20 (map inc (list 1 2 3)))
                                    (concat (list 1 2 3) (list 4 5 6 7))
                                    (reduce + (concat (list 1 2 3) (list 4 5 6))))))))
    (is (= "1 2 3 nil nil"
           (capture-output '((print (nth (list 1 2 3) 0)
                                    (nth (list 1 2 3) 1)
                                    (nth (list 1 2 3) 2)
                                    (nth (list 1 2 3) 10)
                                    (nth (list 1 2 3) -10)))))))
#+end_src

*** Logical Operators

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn = [& args]
    "var curr = FIRST(args);
     ITERATE(REST(args),it){
      var first = FIRST(it);
      if (curr.equals(first) == false)
        return NewBoolean(false);
      curr = first;
     }
     return NewBoolean(true);")

  (defmacro not= [& test]
    (list 'not (cons '= `( ~@test))))

  (defn <
    ([] true)
    ([x] true)
    ([a b]
     "NUMBER_DATA_TYPE an = a.cast<Number>()->getNumerator();
      NUMBER_DATA_TYPE adn = a.cast<Number>()->getDenominator();

      NUMBER_DATA_TYPE bn = b.cast<Number>()->getNumerator();
      NUMBER_DATA_TYPE bdn = b.cast<Number>()->getDenominator();

      __result = NewBoolean((an * bdn) < (bn * adn));")
    ([a b & more]
     (if (< a b)
       (apply < (cons b more))
       false)))

  (defn >
    ([] true)
    ([x] true)
    ([a b]
     "NUMBER_DATA_TYPE an = a.cast<Number>()->getNumerator();
      NUMBER_DATA_TYPE adn = a.cast<Number>()->getDenominator();

      NUMBER_DATA_TYPE bn = b.cast<Number>()->getNumerator();
      NUMBER_DATA_TYPE bdn = b.cast<Number>()->getDenominator();

      __result = NewBoolean((an * bdn) > (bn * adn));")
    ([a b & more]
     (if (> a b)
       (apply > (cons b more))
       false)))

  (defn >=
    ([] true)
    ([x] true)
    ([a b]
     "NUMBER_DATA_TYPE an = a.cast<Number>()->getNumerator();
      NUMBER_DATA_TYPE adn = a.cast<Number>()->getDenominator();

      NUMBER_DATA_TYPE bn = b.cast<Number>()->getNumerator();
      NUMBER_DATA_TYPE bdn = b.cast<Number>()->getDenominator();

      __result = NewBoolean((an * bdn) >= (bn * adn));")
    ([a b & more]
     (if (>= a b)
       (apply >= (cons b more))
       false)))

  (defn <=
    ([] true)
    ([x] true)
    ([a b]
     "NUMBER_DATA_TYPE an = a.cast<Number>()->getNumerator();
      NUMBER_DATA_TYPE adn = a.cast<Number>()->getDenominator();

      NUMBER_DATA_TYPE bn = b.cast<Number>()->getNumerator();
      NUMBER_DATA_TYPE bdn = b.cast<Number>()->getDenominator();

      __result = NewBoolean((an * bdn) <= (bn * adn));")
    ([a b & more]
     (if (<= a b)
       (apply <= (cons b more))
       false)))

  (defmacro and
    ([] true)
    ([x] x)
    ([x & next]
     (list 'if x `(and ~@next) false)))

  (defmacro or
    ([] nil)
    ([x] x)
    ([x & next]
     (list 'if x x `(or ~@next))))

  (defn not [x]
    "if (x)
       return NewBoolean(false);
     return NewBoolean(true);")
#+end_src

#+name: runtime-clojure-logical-operators-tests
#+begin_src clojure :tangle no
  (deftest logical-operators-test
    (is (= "true true false true false true true true false true true false true false true true"
           (capture-output '((print (< 2)
                                    (< 2 3 4 5)
                                    (< 2 3 6 5)
                                    (> 2)
                                    (> 2 3 4 5)
                                    (> 6 5 4 3)
                                    (>= 2)
                                    (>= 5 4 3 2 2 2)
                                    (>= 5 1 3 2 2 2)
                                    (<= 2)
                                    (<= 2 2 3 4 5)
                                    (<= 2 2 1 3 4)
                                    (= 2)
                                    (= 2 3)
                                    (= 2 2 2 2)
                                    (= 2 2.0 2))))))

    (is (= "false true false true false falsetrue false true true"
           (capture-output '((print (= 2 2 2 2 3 5)
                                    (= (list 1 2) (list 1 2))
                                    (= (list 1 2) (list 1 3))
                                    (= true true)
                                    (not (= true true))
                                    (not 1))
                             (let [a (fn [x] (+ 1 x))
                                   b (fn [x] (inc x))]
                               (print (= a a)
                                      (= a b)
                                      (= nil ((fn [] )))
                                      (= nil ((fn [x y] ) 1 2)))))))))
#+end_src

*** Math

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn integer? [x] "__result = NewBoolean(x.isType(NUMBER_TYPE) &&
                                           (x.cast<Number>()->getDenominator() == 1));")

  (defn float? [x] "__result = NewBoolean(x.isType(NUMBER_TYPE) &&
                                         (x.cast<Number>()->getDenominator() != 1));")

  (defn +
    ([] 0)
    ([x] x)
    ([h v]
     "NUMBER_DATA_TYPE hn = h.cast<Number>()->getNumerator();
      NUMBER_DATA_TYPE hdn = h.cast<Number>()->getDenominator();

      NUMBER_DATA_TYPE vn = v.cast<Number>()->getNumerator();
      NUMBER_DATA_TYPE vdn = v.cast<Number>()->getDenominator();

      NUMBER_DATA_TYPE ndn = (hdn * vdn);

      __result = NewRatio(((hn * vdn) + (vn * hdn)),ndn);")
    ([x y & more]
     (reduce + (+ x y) more)))

  (defn inc [x]
    (+ x 1))

  <<runtime-clojure-sequence-count>>

  (defn *
    ([] 1)
    ([x] x)
    ([h v]
     "NUMBER_DATA_TYPE hn = h.cast<Number>()->getNumerator();
      NUMBER_DATA_TYPE hdn = h.cast<Number>()->getDenominator();

      NUMBER_DATA_TYPE vn = v.cast<Number>()->getNumerator();
      NUMBER_DATA_TYPE vdn = v.cast<Number>()->getDenominator();

      NUMBER_DATA_TYPE ndn = (hdn * vdn);

      __result = NewRatio(((hn * vdn) * (vn * hdn)),ndn);")
    ([x y & more]
     (reduce * (* x y) more)))

  (defn -
    ([x]
     (* -1 x))
    ([h v]
     "NUMBER_DATA_TYPE hn = h.cast<Number>()->getNumerator();
      NUMBER_DATA_TYPE hdn = h.cast<Number>()->getDenominator();

      NUMBER_DATA_TYPE vn = v.cast<Number>()->getNumerator();
      NUMBER_DATA_TYPE vdn = v.cast<Number>()->getDenominator();

      NUMBER_DATA_TYPE ndn = (hdn * vdn);

      __result = NewRatio(((hn * vdn) - (vn * hdn)),ndn);")
    ([x y & more]
     (reduce - (- x y) more)))

  (defn /
    ([x]
     (apply / (list 1 x)))
    ([h v]
     "NUMBER_DATA_TYPE hn = h.cast<Number>()->getNumerator();
      NUMBER_DATA_TYPE hdn = h.cast<Number>()->getDenominator();

      NUMBER_DATA_TYPE vn = v.cast<Number>()->getNumerator();
      NUMBER_DATA_TYPE vdn = v.cast<Number>()->getDenominator();

      __result = NewRatio((hn * vdn),(vn * hdn));")
    ([x y & more]
     (reduce / (/ x y) more)))

  (defn dec [x]
    (- x 1))

  (defn pos? [x]
    (> x 0))

  (defn neg? [x]
    (< x 0))

  (defn zero? [x]
    (= x 0))

  (defn floor [x] "__result = NewNumber(x.cast<Number>()->intValue());")

  (defn mod [num div] "__result = NewNumber((num.cast<Number>()->intValue() % ToInt(div)));")
#+end_src

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn scale [x in-min in-max out-min out-max]
    (+ (/ (* (- x in-min) (- out-max out-min)) (- in-max in-min)) out-min))

  (defn clamp [x min max]
    (cond
      (> x max) max
      (< x min) min
      true x))
#+end_src

#+name: runtime-clojure-bit-arithmetic-tests
#+begin_src clojure :tangle no
  (deftest arithmetic-test
    (is (= "3/5 0 1 10 10 -1 0 0 1 8 8 1 1/2 1 1 1 1 1 0 0 1 1"
           (capture-output '((print (+ 0.3 0.3)
                                    (+ )
                                    (+ 1)
                                    (+ 1 2 3 4)
                                    (+ 1 2.0 3 4)

                                    (- 1)
                                    (- 4 2 2)
                                    (- 4 2 2.0)
                                    
                                    (* )
                                    (* 2 2 2)
                                    (* 2.0 2 2)
                                    
                                    (/ 1)
                                    (/ 2)
                                    (/ 4 2 2)
                                    (/ 4 2 2.0)

                                    (floor 1.1)
                                    (floor 1.5)
                                    (floor 1.9)

                                    (mod 2 2)
                                    (mod 4 2)
                                    (mod 5 2)
                                    (mod 8 7))))))

    (is (= "true true false false true true false true true true"
           (capture-output '((print (pos? 1)
                                    (pos? 0.2)
                                    (pos? 0)
                                    (neg? 1)
                                    (neg? -1)
                                    (zero? 0)
                                    (zero? 10)
                                    (zero? (- 1 1))
                                    (zero? (- 1.2 1.2))
                                    (zero? (+ 1.2 -1.2)))))))

    (is (= "1 21 21 21 2"
           (capture-output '((let [a 1
                                   b 2]
                               (+ 1 a)
                               (+ b a)
                               (print a b)
                               (* 2 a)
                               (* b a)
                               (print a b)
                               (/ 2 a)
                               (/ b a)
                               (print a b)
                               (- 2 a)
                               (- b a)
                               (print a b)))))))
#+end_src

#+name: runtime-clojure-bit-arithmetic-tests
#+begin_src clojure :tangle no
  (deftest math-test
    (is (= "100 50 0 5 10 0 -10"
           (capture-output '((print (scale 10 0 10 0 100)
                                    (scale 5 0 10 0 100)
                                    (scale 0 0 10 0 100)
                                    (clamp 10 0 5)
                                    (clamp 10 0 20)
                                    (clamp 10 -10 0)
                                    (clamp -100 -10 0)))))))
#+end_src

*** Bit Operations

#+name: runtime-clojure-bit-operations
#+begin_src clojure :tangle no
  (defn bit-not [x] "__result = NewNumber(~x.cast<Number>()->getNumerator());")

  (defn bit-and [x y] "__result = NewNumber((x.cast<Number>()->getNumerator() &
                                             y.cast<Number>()->getNumerator()));")

  (defn bit-or [x y] "__result = NewNumber((x.cast<Number>()->getNumerator() |
                                            y.cast<Number>()->getNumerator()));")

  (defn bit-xor [x y] "__result = NewNumber((x.cast<Number>()->getNumerator() ^
                                             y.cast<Number>()->getNumerator()));")

  (defn bit-shift-left [x n] "__result = NewNumber((x.cast<Number>()->getNumerator() <<
                                                    n.cast<Number>()->getNumerator()));")

  (defn bit-shift-right [x n] "__result = NewNumber((x.cast<Number>()->getNumerator() >>
                                                     n.cast<Number>()->getNumerator()));")
#+end_src

#+name: runtime-clojure-bit-operations-tests
#+begin_src clojure :tangle no
  (deftest bit-operations-test
    (is (= "-5 -1 7 1 0 0 0 1 8 16 2 1"
           (capture-output '((print (bit-not  4)
                                    (bit-not  0)
                                    (bit-or   4 3)
                                    (bit-or   0 1)
                                    (bit-and  4 3)
                                    (bit-and  0 1)
                                    (bit-xor  4 4)
                                    (bit-xor  1 0)
                                    (bit-shift-left 4 1)
                                    (bit-shift-left 4 2)
                                    (bit-shift-right 4 1)
                                    (bit-shift-right 4 2)))))))
#+end_src

*** Concurrency

Runs the given lambda in a posix thread,

#+name: runtime-clojure-bit-operations
#+begin_src clojure :tangle no
  (defnative pthread-create [f]
    (on "defined STD_LIB"
        ("pthread.h")
        "void *PTHREAD_LAMBDA_INVOKER(void *data) {
            ferret::var fn = ferret::var(static_cast<ferret::Object*>(data));
            fn.cast<ferret::Object>()->subRef();
            _i(fn);
            pthread_exit(NULL);
         }"
        "pthread_t th;
         f.cast<Object>()->addRef();
         if(::pthread_create(&th, 0, &PTHREAD_LAMBDA_INVOKER, static_cast<void*>(f.get())))
           return nil();
         __result = NewNumber(pthread_detach(th));"))
#+end_src

#+name: runtime-clojure-bit-operations-tests
#+begin_src clojure :tangle no
  (deftest pthreads-test
    (is (= "Thread-1Thread-2"
           (capture-output '((defn print-some [y x]
                               (fn []
                                 (sleep y)
                                 (print x)))
                             (pthread-create (print-some 0 "Thread-1"))
                             (pthread-create (print-some 1 "Thread-2"))
                             (sleep 3))))))
#+end_src

*** State Machines

This macro allows users to define state machines using the following
DSL,

#+begin_src clojure :tangle no
  (defmachine two-state-machine
    (states
     (off (println "Off"))
     (on (println "On")))
    (transitions
     (off
      (fn [] true) on)
     (on
      (fn [] true) off)))


  (dotimes [i 10]
    (two-state-machine))
#+end_src

Each transition takes a list of /fn/ /state/ pairs first function that
returns true returns the next state.

#+name: runtime-clojure-state-machine
#+begin_src clojure :tangle no
  (defmacro defmachine [name states transitions]
    (let [transitions
          (->> transitions
               rest
               (map (fn [x]
                      (let [[state & states] x
                            states (->> (partition 2 states)
                                        (map #(list (list (first %)) (second %))))
                            states (->> (clojure.core.protocols/coll-reduce
                                         states (fn [h v]
                                                  (conj h (second v) (first v))) (list))
                                        (cons 'cond))]
                        [(list '= 'state state) (concat states [true state])]))))
          start-state (-> transitions first first last)
          transitions (clojure.core.protocols/coll-reduce
                       transitions (fn [h v] (conj h (first v) (second v))) ['cond])
          states (->> (rest states)
                      (map (fn [x]
                             [(first x)
                              (->> (rest x)
                                   (cons [])
                                   (cons 'fn*))])))
          states (clojure.core.protocols/coll-reduce
                  states (fn [h v]
                           (conj h (first v) (second v))) [])
          state-names (->> states
                           (partition 2)
                           (map first))
          state-symbols (->> states
                             (partition 2)
                             (map second))
          func (list 'fn (into [] state-names)
                     (list
                      (list 'fn [(symbol (str name "-state"))]
                            `~(list 'fn* []
                                    (list
                                     (list 'fn* []
                                           `~(list 'swap! (symbol (str name "-state"))
                                                   (list 'fn* ['state]
                                                         (list 'state)
                                                         `(~@transitions)))))))
                      (list 'atom start-state)))]
      (list 'def name (cons func state-symbols))))
#+end_src

#+name: runtime-clojure-state-machine-tests
#+begin_src clojure :tangle no
  (deftest state-machine-test
    (is (= "10 0 10"
           (capture-output '((def state (atom 0))
                             (defmachine two-state-machine
                               (states
                                (off (swap! state inc))
                                (on (swap! state inc)))
                               (transitions
                                (off
                                 (fn [] true) on)
                                (on
                                 (fn [] true) off)))
                             (dotimes [_ 10]
                               (two-state-machine))
                             (print (deref state))
                             (print " ")
                             (reset! state 0)
                             (print (deref state))

                             (defmachine three-state-machine
                               (states
                                (a (swap! state inc))
                                (b (swap! state inc))
                                (c (swap! state inc))
                                (no-op (swap! state inc)))
                               (transitions
                                (a
                                 (fn [] false) no-op
                                 (fn [] true) b)
                                (b
                                 (fn [] true) c)
                                (c
                                 (fn [] false) no-op
                                 (fn [] false) no-op
                                 (fn [] true) a
                                 (fn [] false) no-op)))
                             (dotimes [_ 10]
                               (three-state-machine))
                             (print " ")
                             (print (deref state)))))))
#+end_src

*** PID

#+name: runtime-clojure-arduino
#+begin_src clojure :tangle no

#+end_src



*** Arduino

Some wrappers for the Arduino platform.

#+name: runtime-clojure-arduino
#+begin_src clojure :tangle no
  (defn pin-mode [pin mode]
    "if (mode.equals(NewKeyword(618)) == true) // :input
        pinMode(ToInt(pin), INPUT);
     else
        pinMode(ToInt(pin), OUTPUT);")

  (defn digital-write [pin mode]
    "if (mode.equals(NewKeyword(474))  == true) // :high
        digitalWrite(ToInt(pin), HIGH);
     else
        digitalWrite(ToInt(pin), LOW);")
#+end_src

* Misc
** I/O

  #+name: core-code-generation-misc
  #+begin_src clojure
    ;; I/O
    (defn read-clojure-file [f]
      (try
        (read-string (str \( (FileUtils/readFileToString (file f)) \)))
        (catch Exception e
          (println "Error Reading," f)
          (System/exit 1))))

    (defn copy-to-solution [fin fout]
      (FileUtils/copyURLToFile (ClassLoader/getSystemResource fin) (file fout)))

    (defn delete-recursively [file]
      (let [func (fn [func f]
                   (when (.isDirectory f)
                     (doseq [f2 (.listFiles f)]
                       (func func f2)))
                   (clojure.java.io/delete-file f))]
        (when (.exists file)
          (func func file))))

    (defn append-to! [r ks v]
      (dosync 
       (let [cv (reduce (fn[h v] (v h)) @r ks)]
         (alter r assoc-in ks (conj cv v)))))

    (defn to-str? [f]
      (symbol? f))

    (defn is-special-form? [s f]
      (and (seq? f)
           (= (first f) s)))
  #+end_src

** Main

   Default compile options, 

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn compile-options [& [options]]
      (merge {:compiler "g++"
              :include-path []
              :library-path []
              :link []
              :compiler-options []
              :source-extension "cpp"
              :base-name "solution"}
             options))

    (defn cpp-file-name [options]
      (str (:output-path options) (:base-name options) "." (:source-extension options)))
  #+end_src

   Read the /cpp/ file parse build options embedded in it.

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn compile-options-parse-source [file]
      (try
        (let [program (slurp file)
              options (->> program
                           (re-seq #"(?s)Ferret Build Configuration Begin.*?//(.*?)// Ferret Build Configuration")
                           (map second)
                           (map #(.replaceAll % "//" ""))
                           (map #(.replaceAll % "\n" " "))
                           (map read-string))
              keys (->> options
                        (map #(keys %))
                        flatten
                        (into #{})
                        (into []))
              combine (fn [key]
                        (->> options
                             (reduce (fn[h v]
                                       (if (nil? (key v))
                                         h
                                         (apply merge (flatten [h (key v)])))) #{})
                             (into [])))]
          (compile-options
           (reduce (fn[h v]
                     (assoc h v (combine v))) {} keys)))
        (catch Exception e
          (compile-options {}))))
  #+end_src

   Compile the form to C++,

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn compile->cpp [form options]
      (let [file-name (cpp-file-name options)
            source (emit-source form options)]
        (println "[+] Compiling")
        (FileUtils/writeStringToFile (file file-name) (solution-template source))
        (let [formatted-source (try (with-sh-dir "./"
                                      (sh "clang-format" "-style" "{Standard: Cpp03}" file-name))
                                    (catch Exception e nil))]
          (when (:fomat-code options)
            (if formatted-source
              (do (println "[+] Formatting Code") 
                  (spit file-name (:out formatted-source)))
              (println "[+] Install clang-format for Formatted Output (Optional)"))))))
  #+end_src

   Compile C++ code to binary,

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn compile->binary [options extra-source-files]
      (let [command (flatten [(:compiler options)
                              (map #(str %) (:compiler-options options))
                              (map #(str "-I" %) (:include-path options))
                              (map #(str "-L" %) (:library-path options))
                              (map #(str "-l" %) (:link options))
                              (map #(let [extension (org.apache.commons.io.FilenameUtils/getExtension %)]
                                      [(cond (= extension "c") ["-x" "c"]
                                             (= extension "c++") ["-x" "c++"]
                                             :default "")
                                       %])
                                   extra-source-files)
                              ["-x" "c++"]
                              (str (:base-name options) "." (:source-extension options))])]

        (println "[+] Building Binary")
        (if (:build-command options)
          (do (println "[+] Build Command" (:build-command options))
              (let [ret (with-sh-dir (:output-path options)
                          (apply sh (flatten ["bash" "-c" (:build-command options)])))]
                (if (not= 0 (:exit ret))
                  (do (println "[+] Build Error")
                      (println (:err ret))
                      (System/exit 1))
                  (println (:out ret)))))
          (do (println "[+] Compiler:" (:compiler options))
              (println "[+] Options:")
              (doseq [option (:compiler-options options)]
                (println "           " option))
              (println "[+] Include Path:")
              (doseq [path (:include-path options)]
                (println "           " path))
              (println "[+] Library Path:")
              (doseq [path (:library-path options)]
                (println "           " path))
              (println "[+] Link:")
              (doseq [link (:link options)]
                (println "           " link))
              (let [ret (with-sh-dir (:output-path options)
                          (apply sh command))]
                (if (not= 0 (:exit ret))
                  (do (println "[+] Build Error")
                      (println (:err ret))
                      (System/exit 1))
                  (do (when (:name options)
                        (with-sh-dir (:output-path options)
                          (sh "mv" "a.out" (str "./" (:name options)))))
                      (println "[+] Done")
                      true)))))))
  #+end_src

   Compiler /main/,

  #+name: core-code-compile-code
  #+begin_src clojure
    (def program-options [["-i" "--input FILE" "Input File" :default "./core.clj"]
                          ["-c" "--compile" "Compile Solution"]
                          ["-f" "--source-files FILE" "Extra Source Files to Pass to GCC"]
                          ["-w" "--watch-input" "Automatically recompile input file on change."]
                          [nil "--disable-formatting" "Disables solution formatting using clang-format."]
                          [nil "--global-functions" "Disables replace-fn-call-sites optimization."]
                          [nil "--ast" "Print Intermediate AST."]
                          ["-h" "--help" "Print Help"]])

    (defn -main [& args]
      (let [args (parse-opts args program-options)]
        (when (->> args :options :help)
          (println "Ferret Compiler")
          (println (:summary args))
          (System/exit 0))

        (let [input (if (and (->> args :options :input)
                             (.exists (file (->> args :options :input))))
                      (->> args :options :input)
                      (do (println "No Input File.")
                          (System/exit 1)))
              input-base-name (org.apache.commons.io.FilenameUtils/getBaseName input)
              input-path (str (org.apache.commons.io.FilenameUtils/getPrefix input)
                              (org.apache.commons.io.FilenameUtils/getPath input))
              options (-> (file (str input-base-name ".cpp"))
                          compile-options-parse-source
                          (assoc :base-name input-base-name)
                          (assoc :output-path input-path)
                          (assoc :ast (->> args :options :ast))
                          (assoc :fomat-code (not (->> args :options :disable-formatting)))
                          (assoc :global-functions (->> args :options :global-functions)))
              extra-source-files (cond (not (empty? (:arguments args))) (:arguments args)
                                       (not (empty? (:extra-source-files options))) (:extra-source-files options)
                                       :default [])
              build-fn (fn []
                         (let [input (read-clojure-file input)]
                           (compile->cpp input options)
                           (when (->> args :options :compile)
                             (let [options (-> (file (cpp-file-name options))
                                               compile-options-parse-source
                                               (assoc :output-path input-path)
                                               (assoc :base-name input-base-name))
                                   options (assoc options :base-name input-base-name)]
                               (compile->binary options extra-source-files)))))]
          (if (nil? (->> args :options :watch-input))
            (build-fn)
            (do (watcher/watcher [input]
                                 (watcher/rate 1000)
                                 (watcher/on-change (fn [_] (build-fn))))
                @(promise)))
          (shutdown-agents))))
  #+end_src

* Files                                                            :noexport:
** project.clj
#+begin_src clojure :mkdirp yes :tangle src/project.clj
  (defproject ferret "1.0.0-SNAPSHOT"
    :dependencies [[org.clojure/clojure "1.7.0"]
                   [org.clojure/tools.cli "0.3.3"]
                   [org.bituf/clj-stringtemplate "0.2"]
                   [org.clojars.amit/commons-io "1.4.0"]
                   [watchtower "0.1.1"]]
    :repl-options {:host "0.0.0.0"
                   :port 7888
                   :init-ns ferret.core}
    :main ferret.core
    :aot [ferret.core]
    :jar-name "interim.jar"
    :uberjar-name "ferret-app.jar")
#+end_src 
** src/ferret/core.clj
#+begin_src clojure :noweb yes :mkdirp yes :tangle src/src/ferret/core.clj
  (ns ferret.core
    (:refer-clojure :exclude [compile])
    (:gen-class)
    (:use [clojure.java.io])
    (:require [clojure.set :as set]
              [clojure.zip :as zip]
              [clojure.walk :as walk]
              [clojure.pprint :as pprint]
              [clojure.tools.cli :refer [parse-opts]]
              [watchtower.core :as watcher])
    (:use [ferret.string-template]
          [ferret.template]
          [clojure.java.shell])
    (:import (org.apache.commons.io FileUtils)))

  <<core-code-generation-misc>>
  <<core-compilation-form-fns>>
  <<core-compilation-reader-macros>>
  <<core-compilation-expand-macros>>
  <<core-compilation-shake-concat>>
  <<core-compilation-add-built-in>>
  <<core-compilation-closure-conversion>>
  <<core-compilation-symbol-conversion>>
  <<core-compilation-do-fn>>
  <<core-compilation-let-fn>>
  <<core-compilation-process>>
  <<core-code-generation-emit>>
  <<core-code-generation-emit-source-methods>>
  <<core-code-generation-emit-source>>
  <<core-code-compile-code>>
#+end_src 
** src/ferret/template.clj
#+begin_src clojure :mkdirp yes :noweb yes :tangle src/src/ferret/template.clj
  (ns ferret.template
    (:use [ferret.string-template])
    (:import (java.io BufferedReader InputStreamReader)))

  (defn read-from-url [f]
    (with-open [in (.getResourceAsStream (ClassLoader/getSystemClassLoader) f)
                rdr (BufferedReader. (InputStreamReader. in))]
      (apply str (interpose \newline (line-seq rdr)))))

  (defn indexed
    "Returns a lazy sequence of [index, item] pairs, where items come
    from 's' and indexes count up from zero.

    (indexed '(a b c d))  =>  ([0 a] [1 b] [2 c] [3 d])"
    [s]
    (map vector (iterate inc 0) s))

  <<code-templates>>
#+end_src 
** src/ferret/string_template.clj
#+begin_src clojure :noweb yes :mkdirp yes :tangle src/src/ferret/string_template.clj
  (ns ferret.string-template
    (:import org.antlr.stringtemplate.StringTemplateGroup)
    (:import org.antlr.stringtemplate.StringTemplate)
    (:use ferret.string-template-internal))


  (defn create-view "Return new view template - useful as mentioned here:
    http://hardlikesoftware.com/weblog/2006/12/12/using-json-with-stringtemplate/"
    ([]
      (StringTemplate.))
    ([^String template]
      (StringTemplate. template)))


  (defn get-view-from-classpath "Return the view template from classpath"
    [^String view-name]
    (let [st-group (StringTemplateGroup. "default")]
      (.getInstanceOf st-group view-name)))


  (defn get-view-from-dir "Return the view template from specified directory"
    [^String view-name ^String root-dir]
    (let [st-group (StringTemplateGroup. "default" root-dir)]
      (.getInstanceOf st-group view-name)))


  (defn reset-view! "Reset view template with supplied content"
    [^StringTemplate view ^String template]
    (.setTemplate view template))


  (defn fill-view! "Fill view template with key/value pairs"
    ;;;
    ;; Fill template with key and value
    ([^StringTemplate template k v]
      (.setAttribute template (stringify k) (each-kv-to-sv v))
      template)
    ;;;
    ;; Fill template with key/value from map
    ([^StringTemplate template kv-map]
      (.setAttributes template (kv-to-sv kv-map))
      template))


  (defn render-view "Return rendered view for the template"
    [^StringTemplate template]
    (.toString template))
#+end_src

#+begin_src clojure :noweb yes :mkdirp yes :tangle src/src/ferret/string_template_internal.clj
  (ns ferret.string-template-internal)


  (defn stringify [any]
    (if (keyword? any)
      (name any)
      (str any)))


  (declare kv-to-sv)
  (declare scan-kv-to-sv)


  (defn each-kv-to-sv "If element is a collection type, do deep transformation"
    [each]
    (if (map? each)
      (kv-to-sv each)
      (if (or (vector? each) (list? each) (seq? each) (set? each))
        (scan-kv-to-sv each)
        each)))


  (defn scan-kv-to-sv
    "Scans a collection and turns any contained map within from kv to sv"
    [coll]
    (map each-kv-to-sv coll))


  (defn kv-to-sv
    "Transforms keyword-value map {:a 10 :b 20 :c 30}
     to string-value map {\"a\" 10 \"b\" 20 \"c\" 30}"
    [mp]
    (let [m (into {} mp)
          k (keys m)
          v (vals m)]
      (zipmap
        (map stringify k)
        (scan-kv-to-sv v))))

#+end_src

** test/ferret/test/core.clj
#+begin_src clojure :noweb yes :mkdirp yes :tangle src/test/ferret/test/core.clj
    (ns ferret.test.core
      (:refer-clojure :exclude [compile])
      (:use [ferret.core] :reload)
      (:use [clojure.test]
            [clojure.java.shell]))

  (defn capture-output [form]
    (let [options (compile-options
                   {:compiler-options
                    ["-std=c++11" "-pedantic"
                     "-Werror" "-Wall" "-Wextra"
                     "-Woverloaded-virtual" "-Wuninitialized"
                     "-Wmissing-declarations" "-Winit-self"
                     "-Wno-variadic-macros"]})] ;; C99 Standart
      (compile->cpp form options)
      (compile->binary options [])
      (with-sh-dir "./"
        (let [r (sh "./a.out")]
          (sh "rm" "-f" "a.out")
          (sh "rm" "-f" "solution.cpp")
          (:out r)))))

    <<compiler-transformation-tests>>
    <<compiler-import-module-test>>
    <<compiler-reader-macro-test>>
    <<runtime-clojure-bit-operations-tests>>
    <<runtime-clojure-bit-arithmetic-tests>>
    <<runtime-clojure-logical-operators-tests>>
    <<runtime-clojure-conditionals-tests>>
    <<runtime-clojure-sequences-tests>>
    <<clojure-destructure-tests>>
    <<native-string-tests>>
    <<native-keyword-tests>>
    <<runtime-clojure-memory-pool-tests>>
    <<runtime-clojure-state-machine-tests>>
    <<runtime-native-atom-tests>>
    <<native-lambda-test>>
#+end_src 

** resources/Object.cpp

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/resources/Object.cpp
  <<runtime-native-math-config-macros>>

  <<runtime-native-program-header>>
  <<runtime-native-memory-management-macros>>
  <<runtime-native-object-casting-macros>>

  namespace ferret{
    class var;
    <<runtime-native-memory-pool>>
    <<runtime-native-object>>
    <<runtime-native-var>>
  }
#+end_src 

** resources/runtime.clj

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/resources/runtime.clj
  <<runtime-clojure-misc-thread-macro>>
  <<runtime-clojure-boolean-object>>
  <<runtime-clojure-pointer-object>>
  <<runtime-clojure-number-object>>
  <<runtime-clojure-seekable-interface>>
  <<runtime-clojure-lambda-interface>>
  <<runtime-clojure-keyword-object>>
  <<runtime-clojure-sequence-object>>
  <<runtime-clojure-character-object>>
  <<runtime-clojure-string-object>>
  <<runtime-clojure-atom-object>>
  <<runtime-clojure-defn>>
  <<runtime-clojure-looping>>
  <<runtime-clojure-first>>
  <<runtime-clojure-sequence>>
  <<runtime-clojure-logical-operators>>
  <<runtime-clojure-conditionals>>
  <<runtime-clojure-math>>
  <<runtime-clojure-sequence-lazy>>
  <<runtime-clojure-bit-operations>>
  <<runtime-clojure-console-io>>
  <<runtime-clojure-misc>>
  <<runtime-clojure-state-machine>>
  <<runtime-clojure-arduino>>
#+end_src

** resources/bash_executable_stub.sh

#+begin_src sh :mkdirp yes :tangle src/resources/bash_executable_stub.sh
  #!/bin/sh
  MYSELF=`which "$0" 2>/dev/null`
  [ $? -gt 0 -a -f "$0" ] && MYSELF="./$0"
  java=java
  if test -n "$JAVA_HOME"; then
      java="$JAVA_HOME/bin/java"
  fi
  exec "$java" $java_args -jar $MYSELF "$@"
  exit 1 
#+end_src
