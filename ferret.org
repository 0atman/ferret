#+title: Ferret: An Experimental Clojure Compiler
#+tags: clojure c++ arduino avr-gcc gcc
#+STARTUP: hidestars
#+TAGS: noexport(e)
#+EXPORT_EXCLUDE_TAGS: noexport
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-dark.min.css" />
#+OPTIONS: toc:nil

#+BEGIN_ABSTRACT
Ferret is an experimental Lisp to C++ compiler, the idea was to
compile code that is written in a very small subset of Clojure to be
automatically translated to C++ so that I can program stuff in
Clojure where JVM or any other Lisp dialect is not available.

This is a literate program, the code in this document is the
executable source, in order to extract it, open this raw file
with emacs and run /M-x org-babel-tangle/.
It will build the necessary directory structure and export the files
and tests contained.
#+END_ABSTRACT
#+TOC: headlines 3

* Example Code

In order to compile the samples,

#+begin_example
lein run -in sample.clj
#+end_example

or 

#+begin_example
java -jar ferret-app.jar -in sample.clj
#+end_example

output will be placed in a a file /solution.cpp/,

** SQLite

Compiler supports the option of reading build configuration from a
file. 

#+begin_src clojure :mkdirp yes :tangle ferret/examples/sqlite-build.options
  {:include-path ["/usr/local/Cellar/sqlite/3.8.2/include/"]
   :library-path ["/usr/local/Cellar/sqlite/3.8.2/lib/"]
   :link ["sqlite3"]
   :compiler-options ["-Wall"]}
#+end_src 

#+begin_src clojure :mkdirp yes :tangle ferret/examples/sqlite.clj
  (native-header sqlite3.h)

  (defn open-db []
    "sqlite3 *db;
     int rc = sqlite3_open(\"./test.db\", &db);
     if (rc == SQLITE_OK)
       __result = NEW_POINTER(db);
     else
      fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));")

  (defn close-db [db]
    "sqlite3_close(TO_POINTER(db,sqlite3));")

  (defn exec-db [db sql]
    "char *err_msg = 0;
     int rc = sqlite3_exec(TO_POINTER(db,sqlite3), TO_C_STR(sql), 0, 0, &err_msg);
     if (rc == SQLITE_OK)
       __result = VAR(true);
     else{
       fprintf(stderr, \"SQL error: %s\\n\", err_msg);
       sqlite3_free(err_msg);}")

  (defn prep-stmt-db [db-ptr sql]
    "char *err_msg = 0;
     sqlite3_stmt *stmt;
     sqlite3* db = TO_POINTER(db_ptr,sqlite3);
     int rc = sqlite3_prepare_v2(db, TO_C_STR(sql), -1, &stmt, NULL);
     if (rc == SQLITE_OK)
       __result = VAR(new Pointer(stmt));
     else{
       fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));
       sqlite3_finalize(stmt);
       sqlite3_free(err_msg);}")

  (defn select-db [stmt-ptr]
    "sqlite3_stmt *stmt = TO_POINTER(stmt_ptr,sqlite3_stmt);
     __result = NEW_SEQUENCE();
     while(sqlite3_step(stmt) == SQLITE_ROW){
       const char* col = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1));
       CONS(__result,NEW_STRING(col));
     }
     sqlite3_finalize(stmt);")

  (def setup-db (list "DROP TABLE IF EXISTS Cars;" 
                      "CREATE TABLE Cars(Id INT, Name TEXT, Price INT);" 
                      "INSERT INTO Cars VALUES(1, 'Audi', 52642);" 
                      "INSERT INTO Cars VALUES(2, 'Mercedes', 57127);" 
                      "INSERT INTO Cars VALUES(3, 'Skoda', 9000);" 
                      "INSERT INTO Cars VALUES(4, 'Volvo', 29000);" 
                      "INSERT INTO Cars VALUES(5, 'Bentley', 350000);" 
                      "INSERT INTO Cars VALUES(6, 'Citroen', 21000);" 
                      "INSERT INTO Cars VALUES(7, 'Hummer', 41400);" 
                      "INSERT INTO Cars VALUES(8, 'Volkswagen', 21600);"))

  (def db (open-db))

  (doseq [sql setup-db]
    (exec-db db sql))

  (def select-all (prep-stmt-db db "SELECT * FROM Cars"))

  (println (select-db select-all))
#+end_src 

** mongoose


#+begin_src clojure :mkdirp yes :tangle ferret/examples/mongoose-build.options
  {:extra-source-files ["mongoose.c"]}
#+end_src 

#+begin_src clojure :mkdirp yes :tangle ferret/examples/mongoose.clj
  (native-header mongoose.h)

  (native-declare "static struct mg_serve_http_opts s_http_server_opts;")

  (defn request-listener [nc ev p]
    "if (TO_INT(ev) == MG_EV_HTTP_REQUEST) {
         mg_serve_http(TO_POINTER(nc,struct mg_connection), 
                       TO_POINTER(p,struct http_message), 
                       s_http_server_opts);
       }")

  (create-callback request-listener
                   "void" "struct mg_connection *nc, int ev, void *p"
                   "NEW_POINTER(nc)" "VAR(ev)" "NEW_POINTER(p)")

  (defn web-server-init [port]
    "struct mg_mgr *mgr = (struct mg_mgr *)malloc(sizeof(mg_mgr));
     struct mg_connection *nc;

     mg_mgr_init(mgr, NULL);
     nc = mg_bind(mgr, TO_C_STR(port), request_listener_callback);

     // Set up HTTP server parameters
     mg_set_protocol_http_websocket(nc);
     s_http_server_opts.document_root = \".\";  // Serve current directory
     s_http_server_opts.dav_document_root = \".\";  // Allow access via WebDav
     s_http_server_opts.enable_directory_listing = \"yes\";
     __result = NEW_POINTER(mgr);")

  (defn web-server-poll [mgr]
    "mg_mgr_poll(TO_POINTER(mgr,struct mg_mgr), 1000);")

  (def server (web-server-init "8000"))

  (while true (web-server-poll server))
#+end_src 

** Arduino LED

   A sample Arduino skecth to blink the on board led.

#+begin_src clojure :mkdirp yes :tangle ferret/examples/led.clj
  (pin-mode 13 :output)
  
  (forever
   (digital-write 13 :high)
   (sleep 500)
   (digital-write 13 :low)
   (sleep 500))
#+end_src 

** OpenCV

Following /build.options/ file links the resulting code with
OpenCV.

#+BEGIN_EXAMPLE
  {:include-path ["/usr/local/Cellar/opencv/2.4.9/include/"]
   :library-path ["/usr/local/Cellar/opencv/2.4.9/lib/"]
   :link ["opencv_core"
          "opencv_highgui"]
   :compiler-options ["-Wall"]
   :name "cv-webcam"}
#+END_EXAMPLE

Compile the file using,

#+BEGIN_EXAMPLE
  lein run -i examples/webcam.clj -o build.options 
#+END_EXAMPLE

Display webcam in a window.

#+begin_src clojure :mkdirp yes :tangle ferret/examples/webcam.clj
  (native-header "opencv/cv.h"
                 "opencv/highgui.h")
  
  (defn wait-key [i] "__result = var((char)cvWaitKey(NUMBER(i)->intValue()));")
  
  (defn video-capture [i]
    "cv::VideoCapture *cap = new cv::VideoCapture(NUMBER(i)->intValue());
     if (cap->isOpened())
      __result = var(new Pointer(cap));")
  
  (defn named-window [n] "cv::namedWindow(STRING(n)->toString(),1);")
  
  (defn query-frame [c]
    "cv::VideoCapture *cap = static_cast<cv::VideoCapture*>(POINTER(c)->ptr);
     cap->grab();
     cv::Mat *image = new cv::Mat;
     cap->retrieve(*image, 0);
     __result = var(new Pointer(image));")
  
  (defn show-image [f img]
    "cv::Mat *i = static_cast<cv::Mat*>(POINTER(img)->ptr);
     imshow(STRING(f)->toString(), *i);")
  
  (def cam (video-capture 0))
  
  (named-window "cam")
  
  (while (not= (wait-key 1) \q)
    (let [f (query-frame cam)]
      (show-image "cam" f)))
#+end_src 

* Compiler

Compiler has two major parts, transformation and code
generation. During transformation we make passes over the code, with
each pass code becomes more and more like C++ basically after the final
pass it is C++ written with s-expressions. Then during code generation
we iterate over the code and spit valid C++.

** Transformation

Forms go through eight transformations before they are passed to the
code generation phase.

#+name: core-transformation-process
#+begin_src clojure :tangle no
  (defn process [form]
    (->> (import-modules-all form)
         (add-built-in)
         (expand-macros-all)
         (vector->list)
         (let->fn)
         (do->fn)
         (closure-conversion)
         (symbol-conversion)
         (replace-fn-call-sites)))

  ;;(process '((require '[examples.sqlite :as io]) (asdasdasdads)))
#+end_src

*** Import Modules

Import other ferret files using,

#+BEGIN_SRC clojure :tangle no
  (require '[package.io :as io])
#+END_SRC

Compiler will look for a file under current working directory called,
/package/io.clj/ all expression in the that file will be added to the
front of the current form with symbols renamed to /some-fn/ =>
/io/some-function/.

#+name: core-transformation-add-built-in
#+begin_src clojure :tangle no
  (defn import-modules [form]
      (let [package-list (select-form form (is-form? 'require))
            imports (->> package-list
                         (map rest)
                         (map first)
                         (map rest)
                         (map first)
                         (map (fn [[mod _ as]]
                                [(str (.replace (str mod) "." "/") ".clj") as]))
                         (map (fn [[mod as]]
                                [(read-clojure-file mod) as]))
                         (map (fn [[mod as]]
                                (let [symbols (->> (select-form
                                                    (expand-macros-all mod) (is-form? 'def))
                                                   (map second)
                                                   (into #{}))
                                      mod (morph-form mod symbol?
                                                      (fn [f]
                                                        (if (symbols f)
                                                          (symbol (str as "/" f))
                                                          f)))]
                                  mod)))
                         (reduce (fn[mod form]
                                   (reduce (fn[h v] (cons v h)) form mod)) [])
                         vec)
            form-no-require (remove-form form (is-form? 'require))]
        (apply list (reduce (fn[h v] (conj h v)) imports form-no-require))))

  (defn import-modules-all [form]
    (loop [f form]
      (let [expanded (import-modules f)]
        (if (= f expanded)
          expanded
          (recur expanded)))))
#+end_src

**** Tests

Create some dummy libs under /examples/modules/,

#+begin_src clojure :mkdirp yes :tangle ferret/examples/modules/module-a.clj
  (defn helper-a []
    (print "Module A"))
#+end_src 

#+begin_src clojure :mkdirp yes :tangle ferret/examples/modules/module-b.clj
  (require '[examples.modules.module-c :as mod-c])

  (defn helper-b []
    (mod-c/helper-c))
#+end_src 

#+begin_src clojure :mkdirp yes :tangle ferret/examples/modules/module-c.clj
  (defn helper-c []
    (print "Module C"))
#+end_src 

Run import tests,

#+name: compiler-import-module-test
#+begin_src clojure :tangle no
  (deftest import-module-test
    (is (= "Module A Module C "
           (capture-output '((require '[examples.modules.module-a :as mod-a])
                             (require '[examples.modules.module-b :as mod-b])
                             (mod-a/helper-a)
                             (mod-b/helper-b))))))
#+end_src

*** Add Runtime

In order to keep the generated C++ code compact only the functions used
will be present in the generated source file. Which means if you don't
use /println/ anywhere in the code it won't be defined in the final
C++ file, but if you use it, it and everything it uses will be
defined, in the case of /println/ it will pull /apply/, /print/ and
/newline/ with it.

#+name: core-transformation-add-built-in
#+begin_src clojure :tangle no
  (defn add-built-in
    ([form]
     (let [runtime-form (read-string (str \( (read-from-url "runtime.clj") \)))
           built-in-defn (expand-macros-all runtime-form)
           built-in-order (->> (filter #(not= 'defobject (first %)) built-in-defn)
                               (map second))
           built-in (->> built-in-defn
                         (reduce (fn[h v] (assoc h (second v) v)) {}))
           fns (atom {})
           _ (add-built-in (->> form expand-macros-all vector->list) built-in fns)
           sorted-fns (->> @fns
                           (sort-by #(.indexOf built-in-order (key %)))
                           (map #(second %)))
           def-objects (filter #(= 'defobject (first %)) built-in-defn)]
       (concat def-objects sorted-fns form)))
    ([form built-in fns]
     (morph-form form symbol?
                 #(do (if-let [f (built-in %)]
                        (when (not (@fns %))
                          (swap! fns assoc % f)
                          (add-built-in f built-in fns))) %))))
#+end_src

*** Expand Macros

First we read all the macros present in /runtime.clj/ then add to that
user defined macros, they are evaluated in a temporary namespace,
using /morph-form/ we iterate all the macros used in the code that we
are compiling and expand them in the temporary namespace then the node
is replaced with its expanded form.

#+name: core-transformation-expand-macros
#+begin_src clojure :tangle no
  (defn expand-macros [form]
    (let [macros (->> (read-string (str \( (read-from-url "runtime.clj") \)))
                      ;;get built in macros
                      (filter (is-form? 'defmacro))
                      ;;merge user defined macros
                      (concat (filter (is-form? 'defmacro) form)))
          form (remove-form form (is-form? 'defmacro))
          temp-ns (gensym)]
      
      (create-ns temp-ns)
      (binding [*ns* (the-ns temp-ns)]
        (refer 'clojure.core :exclude (concat (map second macros) ['fn 'let* 'def]))
        (use '[ferret.core :only [symbol-conversion]])
        (doseq [m macros]
          (eval m)))

      (let [form (morph-form form
                             (apply is-form? (map second macros))
                             (fn [f]
                               (binding [*ns* (the-ns temp-ns)]
                                 (macroexpand-all f))))]
        (remove-ns temp-ns)
        form)))

  (defn expand-macros-all [form]
    (loop [f form]
      (let [expanded (expand-macros f)]
        (if (= f expanded)
          expanded
          (recur expanded)))))
#+end_src

*** vector->list

Since there is no support for vectors, they are converted to
lists. Also zippers do not iterate over vectors.

#+name: core-transformation-vector-list
#+begin_src clojure :tangle no
  (defn vector->list [form]
    (morph-form form vector? #(reverse (into '() %))))
#+end_src

*** let->fn

let forms are transformed into nested functions which are then called
immediately, bindings are setup in the outer function, expressions are
placed in the inner function which takes the bindings as arguments.

So following form,

#+begin_src clojure :tangle no
  (let->fn '(let [a 1
                  b 2]
              (+ a b)))
#+end_src

after transformation becomes,

#+begin_src clojure :tangle no
  ((fn []
     (define-var a 1)
     (define-var b 2)
  
     ((fn (a b)
        (+ a b)) a b)))
#+end_src

#+name: core-transformation-let-fn
#+begin_src clojure :tangle no
  (defn let->fn [form]
    (morph-form form
                (is-form? 'let*)
                (fn [[_ bindings & body]]
                  (let [bindings (partition 2 bindings)
                        vars (flatten (map first bindings))
                        defs (map #(cons 'define-var %) bindings)
                        body-fn (cons (concat ['fn vars] body) vars)]
                    (list (concat ['fn []] defs [body-fn]))))))
#+end_src

*** do->fn

A similar method is used for the do form, expressions are wrapped in a fn
that takes no parameters and executed in place.

#+begin_src clojure :tangle no
  (do->fn '(do (+ 1 1)))
#+end_src

#+begin_src clojure :tangle no
  ((fn [] (+ 1 1)))
#+end_src

#+name: core-transformation-do-fn
#+begin_src clojure :tangle no
  (defn do->fn [form]
    (morph-form form
                (is-form? 'do)
                #(list (concat ['fn []] (rest %)))))
#+end_src

*** Closure Conversion

/closure-conversion/ handles the problem of free variables, 

#+begin_src clojure :tangle no
  (defn make-adder [x]
    (fn [n] (+ x n)))
#+end_src

in the above snippet x is a free variable, the function /make-adder/
returns, has to have a way of referencing that variable when it is
used. The way we do this is that, every function will pass its arguments to
inner functions (if any) it contains.

#+begin_src clojure :tangle no
  (closure-conversion '(fn [x]
                          (fn [n] (+ x n))))
#+end_src

Above form will be converted to,

#+begin_src clojure :tangle no
  (define-lambda G__265 (x) (n) (+ x n))
  (define-lambda G__266 () (x) (lambda-object G__265 x))
#+end_src

What this means is, define a functor named /G__265/ that holds a
reference to /x/, and another functor /G__266/ that has no state. When
we create an instance of /G__265/ we pass /x/ to its
constructor. Since every thing is already converted to fns this
mechanism allows variables to be referenced down the line and solves
the free variable problem.

#+name: core-transformation-closure-conversion 
#+begin_src clojure :tangle no
  (defn lambda-defined? [fns env args body]
    (let [f (concat [env args] body)
          name (reduce (fn[h v]
                         (let [[_ n & r] v]
                           (if (= r f) n))) nil @fns)]
      (when name
        (apply list 'lambda-object name env))))
  
  (defn define-lambda [fns env args body]
    (let [n (gensym)]
      (dosync (alter fns conj (concat ['define-lambda n env args] body)))
      (apply list 'lambda-object n env)))
  
  (defn closure-conversion
    ([form]
       (let [fns (ref [])
             form (closure-conversion form fns)]
         (vector->list (concat form @fns))))
    ([form fns & env]
       (morph-form form
                   (is-form? 'fn)
                   (fn [[_ args & body]]
                     (let [env (if (nil? env) '() (first env))
                           body (closure-conversion body fns (concat args env))]
                       (if-let [n (lambda-defined? fns env args body)]
                         n
                         (define-lambda fns env args body)))))))
#+end_src

*** Symbol Conversion

Next step converts all symbols that are not legal C++ identifiers
into valid ones.

#+name: core-transformation-symbol-conversion
#+begin_src clojure :tangle no
  (defn symbol-conversion [form]
    (let [c (comp #(symbol (clojure.string/escape
                            (str %)
                            {\- \_ \* "_star_" \+ "_plus_" \/ "_slash_"
                             \< "_lt_" \> "_gt_" \= "_eq_" \? "_QMARK_"}))
                  #(cond (= 'not %) '_not_
                         :default %))]
      (morph-form form symbol? c)))

#+end_src

*** Replace Fn Call Sites

Final step replaces all functions calls with new function
objects /define_lambda/ are renamed to /fn/. This removes all globals
variables unless the /fn/ defined is a closure. In which case it is
left as a global variable and the class implementation is prepended
with the global name for readability.

#+BEGIN_EXAMPLE
  (process '((let [a 1]
               (defn adder [x]
                 (+ a x)))
             (defn my-inc [x] (+ 1 x))))

  (replace-fn-call-sites
   '((define_lambda G__3885 (a) (x) (_plus_ a x))
     (define_lambda G__3886 () (a) (def adder (lambda_object G__3885 a)))
     (define_lambda G__3887 () () (define_var a 1) ((lambda_object G__3886) a))
     (define_lambda G__3888 () (x) (_plus_ 1 x))
     ((lambda_object G__3887))
     (def my_inc (lambda_object G__3888))))

  ((define_lambda adder_G__3885 (a) (x) (_plus_ a x))
   (define_lambda G__3886 () (a) (def adder (lambda_object adder_G__3885 a)))
   (define_lambda G__3887 () () (define_var a 1) ((lambda_object G__3886) a))
   (define_lambda my_inc () (x) (_plus_ 1 x))
   ((lambda_object G__3887)))
#+END_EXAMPLE

#+name: core-transformation-symbol-conversion
#+begin_src clojure :tangle no
  (defn select-def-fn [form]
    (->> (select-form form (is-form? 'def))
         (filter (fn [[_ name val]]
                   (and (seq? val)
                        (= 'lambda_object (first val)))))))

  (defn replace-fn-call-sites-pure [form fn-defs fn-table]
    (let [no-global-fn (reduce (fn[h v]
                                 (remove-form h (fn [f]
                                                  (and (seq? f)
                                                       (= 'def (first f))
                                                       (every? true? (map = f v))))))
                               form fn-defs)        
          embeded-fn-calls (reduce (fn[h [name gensym]]
                                     (morph-form h symbol?
                                                 (fn [f]
                                                   (if (= f name)
                                                     (list 'lambda_object gensym)
                                                     f))))
                                   no-global-fn fn-table)
          embed-fn-names (reduce (fn[h [name gensym]]
                                   (morph-form h symbol?
                                               (fn [f]
                                                 (if (= f gensym)
                                                   name
                                                   f))))
                                 embeded-fn-calls fn-table)]
      embed-fn-names))

  (defn replace-fn-call-sites [form]
    (let [pure-fn-defs (->> (select-def-fn form)
                            (filter #(= 2 (-> % last count))))
          pure-fn-table (map (fn [[_ name [_ gensym]]] [name gensym]) pure-fn-defs)
          form (replace-fn-call-sites-pure form pure-fn-defs pure-fn-table)
          closure-fn-defs (->> (select-def-fn form)
                               (filter #(not= 2 (-> % last count))))
          closure-fn-table (map (fn [[_ name [_ gensym]]] [name gensym]) closure-fn-defs)]
      (reduce (fn[h [name gensym]]
                (morph-form h symbol?
                            (fn [f]
                              (if (= f gensym)
                                (symbol (str name "_" gensym))
                                f))))
              form closure-fn-table)))
#+end_src

*** Helpers

During each pass we iterate over the nodes in the form using
/morph-form/ and /remove-form/, they both take a s-expression and a
predicate if the predicate returns true, morph-form will call /f/
passing the current node as an argument and replace that node with
/f/'s return value, remove-form on the other hand does what its name
suggests and removes the node when predicate returns true.

#+name: core-transformation-form-fns
#+begin_src clojure :tangle no
  (defn morph-form [tree pred f]
    (loop [loc (zip/seq-zip tree)]
      (if (zip/end? loc)
        (zip/root loc)
        (recur
         (zip/next
          (if (pred (zip/node loc))
            (zip/replace loc (f (zip/node loc)))
            loc))))))

  (defn remove-form [tree pred]
    (loop [loc (zip/seq-zip tree)]
      (if (zip/end? loc)
        (zip/root loc)
        (recur
         (zip/next
          (if (pred (zip/node loc))
            (zip/remove loc)
            loc))))))

  (defn select-form [tree pred]
    (loop [loc (zip/seq-zip tree)
           nodes []]
      (if (zip/end? loc)
        nodes
        (recur
         (zip/next loc)
         (if (pred (zip/node loc))
           (conj nodes (zip/node loc))
           nodes)))))

  (defn is-form? [& s]
    (fn [f]
      (and (seq? f)
           (some true? (map #(= % (first f)) s)))))
#+end_src

*** Tests

#+name: compiler-transformation-tests
#+begin_src clojure :tangle no
  (deftest transformation-test
    (is (seq? (vector->list [1 2 [2 [5 4] 3]])))
    (is (= (symbol-conversion '(make-adder 2)) '(make_adder 2)))
    (is (= (symbol-conversion '(make-adder* 2)) '(make_adder_star_ 2)))

    (let [form (closure-conversion '((def make-adder (fn [n] (fn [x] (+ x n))))))]
      (is (= (first (second form)) 'define-lambda))
      (is (= (last (second form)) '(+ x n)))
      (is (= (second (first form)) 'make-adder))
      (is (= (first (first form)) 'def))))

  (deftest transformation-macro-test
    (is (= "1 1 1 true false true true true 0 1 2 3 4 3 "
           (capture-output '((defmacro my-when [test & body]
                               (list 'if test (cons 'do body)))
                             
                             (print (my-when (< 2 3) 1)

                                    (when (< 2 3) 1)

                                    (when (< 2 3) 1)
                                    
                                    (let [a 1]
                                      (and (> a 0)
                                           (< a 10)))

                                    (let [a 11]
                                      (and (> a 0)
                                           (< a 10)))
                                    
                                    (and true true)

                                    (or true false)

                                    (let [a 11]
                                      (or (> a 0)
                                          (< a 10))))
                             
                             (dotimes [i 5] (print i))
                             (let [a 1]
                               (defn adder [x]
                                 (+ a x)))
                             (defn my-inc [x] (+ 1 (adder x)))
                             (print (my-inc 1)))))))

  (deftest transformation-special-forms-test
    (is (= "10 89 11 3 1 5 5 1 1 1 1 1 1 1 1 1 1 "
           (capture-output '((def make-adder
                               (fn [n] (fn [x] (+ x n))))
                             (def adder
                               (make-adder 1))

                             (def fibo (fn [n]
                                         (if (< n 2)
                                           1
                                           (+ (fibo (- n 1))
                                              (fibo (- n 2))))))

                             (def adder-let (let [a 1
                                                  b 2]
                                              (fn [n] (+ a b n))))

                             (def adder-let-2 (fn [n]
                                                (let [a 1
                                                      b 2]
                                                  (+ a b n))))

                             (native-declare "int i = 0;")
                             (defn inc-int [] "__result =  i++;")
                             
                             (print (adder 9)

                                    (fibo 10)

                                    ((fn [n] (+ n 1)) 10)

                                    (((fn [n] (fn [n] n)) 3) 3)

                                    (if (< 2 3 4 5 6)
                                      (do 1)
                                      (do 2))

                                    (adder-let 2)

                                    (adder-let-2 2))
                             
                             (while (< (inc-int) 10)
                               (print 1)))))))
#+end_src

** Code Generation

At this point all we need is a multi method that will emit correct
string based on the form.

#+name: core-code-generation-emit
#+begin_src clojure :tangle no  
  (defmulti emit (fn [form _]
                   (cond (is-special-form? 'defobject form) 'defobject
                         (is-special-form? 'define_lambda form) 'define_lambda
                         (is-special-form? 'lambda_object form) 'lambda_object
                         (is-special-form? 'define_var form) 'define_var
                         (is-special-form? 'native_declare form) 'native_declare
                         (is-special-form? 'if form) 'if
                         (is-special-form? 'def form) 'def
                         (to-str? form) :to-str
                         (keyword? form) :keyword
                         (number? form) :number
                         (nil? form) :nil
                         (char? form) :char
                         (string? form) :string
                         (seq? form) :sequence)))
#+end_src

Without preprocessing following forms,

#+begin_src clojure :tangle no
  (emit '(list 1 2 3) (ref {}))
  
  (emit '(+ 1 2) (ref {}))
  
  (emit '(if (< a b)
           b a)
        (ref {}))
#+end_src

would evaluate to,

#+begin_example
  "INVOKE(VAR(list), VAR(3),VAR(2),VAR(1))"
  "INVOKE(VAR(+), VAR(2),VAR(1))"
  "(BOOLEAN(INVOKE(VAR(<), VAR(b),VAR(a)))->asBool() ? (VAR)VAR(b) : (VAR)VAR(a))"  
#+end_example

So the actual compilation will just map emit to all forms passed and
/string-template/ will handle the job of putting them into an empty
C++ skeleton.

#+name: core-code-generation-emit-source
#+begin_src clojure :tangle no
  (defn emit-source [form]
    (let [state (ref {:lambdas [] :symbol-table #{} :native-declarations []})
          body (doall (map #(emit % state) (process form)))]
      (assoc @state :body body)))
#+end_src

*** Code Emitting
**** Object Types

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit :to-str [form state] (str "VAR("form ")"))

  (defmethod emit :char [form state] (str "VAR(new ferret::Character('" form "'))"))

  (defmethod emit :string [form state] (str "VAR(new ferret::String(\"" form "\"))"))

  (defmethod emit :nil [form state] "VAR()")

  (defmethod emit :keyword [form state]
    (str "VAR(new ferret::Keyword(" (reduce (fn[h v] (+ h (int v))) 0 (str form))"))"))

  (defmethod emit :number [form state]
    (str "VAR("form (if (float? form) "f") ")"))

  (defmethod emit :sequence [[fn & args] state]
    (invoke-lambda (emit fn state) (doall (map #(emit % state) args))))

  (defmethod emit 'define_var [[_ name form] state]
    (str "VAR " name " = " (emit form state)))

  (defmethod emit 'native_declare [[_ declaration] state]
    (append-to! state [:native-declarations] declaration) "")
#+end_src

**** Lambdas

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit 'lambda_object [[_ name & env] state]
    (new-lambda name (filter #(not (= '& %)) env)))

  (defn emit-native-block [form state]
    (let [includes (->> (filter #(= 4 (count %)) (rest form))
                        (map #(cons (nth % 1) (apply list (nth % 2))))
                        (map (fn [[guard & headers]]
                               (str "\n#if " guard " \n"
                                    (apply str (map #(str "#include \"" % "\"\n") headers))
                                    "#endif\n"))))
          body (->> (map #(vector (second %) (last %)) (rest form))
                    (map #(str "\n#if " (first %) " \n"
                               (second %)
                               "\n#endif\n")))
          pre-ample (->> (map #(vector (second %) (drop-last (drop 3 %))) (rest form))
                         (map #(str "\n#if " (first %) " \n"
                                    (apply str (map (fn [line] (str line "\n")) (second %)))
                                    "\n#endif\n")))]
      (doseq [inc includes] 
        (append-to! state [:native-declarations] inc))
      (doseq [pre pre-ample] 
        (append-to! state [:native-declarations] pre))
      ["VAR __result" body "__result"]))

  (defmethod emit 'define_lambda [[_ name env args & body] state]
    (let [body (cond  (empty? body) ["VAR()"]
                      (and (= 1 (count body))
                           (string? (first body)))
                      ["VAR __result" body "__result"]
                      (and (= 1 (count body))
                           (seq? (-> body first))
                           (= 'native_block (-> body first first)))
                      (emit-native-block (first body) state)
                      :default (doall (map #(emit % state) body)))
          env (filter #(not (= '& %)) env)
          reg-args (take-while #(not (= '& %)) args)
          va-args (if (some #{'&} args)
                    (let [arg (last args)]
                      (str "VAR " arg " = _args_;\n")))]
      (append-to! state [:lambdas] {:name name :env env :args reg-args :var_args va-args :body body}) ""))
#+end_src

**** Misc

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit 'defobject [[_ name & spec] state]
    (append-to! state [:native-declarations] (declare-object name spec))
    "")

  (defmethod emit 'if [[_ cond t f] state]
    (let [cond (emit cond state)
          t (emit t state)
          f (if (nil? f) "VAR()" (emit f state))]
      (if-statement cond t f)))

  (defmethod emit 'def [[_ name & form] state]
    (append-to! state [:symbol-table] name)
    (str "(" name " = " (apply str (doall (map #(emit % state) form))) ")"))
#+end_src

*** Code Templates

#+name: code-templates
#+begin_src clojure :tangle no
  (defn new-lambda [n e]
    (let [view (create-view "(FN($name$$env:{,$it$}$))")]
      (fill-view! view "name" n)
      (fill-view! view "env" e)
      (render-view view)))

  (defn invoke-lambda [n args]
    (let [view (create-view "INVOKE($lambda$, $args:{$it$} ;separator=\",\"$)")]
      (fill-view! view "lambda" n)
      (fill-view! view "args" (reverse args))
      (render-view view)))

  (defn if-statement [cond t f]
    (apply str "(BOOLEAN(" cond ")->asBool() ? (VAR)" t " : (VAR)" f ")"))

  (defn declare-lambdas [lambdas]
    (let [view (create-view
                
    "$lambdas: {lambda|
        class $lambda.name$ : public Lambda{

        $lambda.env:{VAR $it$;} ;separator=\"\n\"$

        public:

          $lambda.name$ ($lambda.env:{VAR $it$} ;separator=\",\"$){ 
             $lambda.env:{this->$it$ = $it$;} ;separator=\"\n\"$
          }

          VAR invoke (VAR _args_){
            $lambda.args:{args | VAR $last(args)$ = FIRST(_args_); _args_ = REST(_args_); } ;separator=\"\n\"$

            $lambda.var_args$

            $trunc(lambda.body):{$it$;} ;separator=\"\n\"$
            return $last(lambda.body):{ $it$;} ;separator=\"\n\"$
          }
        };};separator=\"\n\n\"$")]
      (fill-view! view "lambdas" (map #(let [args (:args %)]
                                         (assoc % :args (indexed args))) lambdas))
      (render-view view)))

  (defn declare-object [name body]
    (let [specs (into {} (map #(vector (first %) (rest %)) body))
          interface (if (nil? (specs 'interface))
                      "Object"
                      (apply str (rest (str (first (specs 'interface))))))
          interface-only (cond (specs 'interface) false
                               (empty? (specs 'new)) true
                               :defaul false)
          view (create-view "
      namespace ferret{

       $if(object_type)$
         int $type$_TYPE = $type_val$;
       $endif$

       class $name$ : public $interface$ {
       public:

         $data:{$it$;} ;separator=\"\n\"$

         $interfaces:{virtual $it$ = 0;} ;separator=\"\n\"$

         $new:{it | $name$($first(it)$){
           $first(rest(it))$
         }} ;separator=\"\n\"$

         $if(object_type)$
          int getType(){ return $type$_TYPE;}
         $endif$

         $if(equals)$
          var equals(var o){
           $equals$
          }
         $endif$

         $if(toOutputStream)$
          var toOutputStream(){
           $toOutputStream$
          }
         $endif$

         $fns:{it | $first(it)$($first(rest(it))$){
           $first(rest(rest(it)))$
         }} ;separator=\"\n\"$

         $ifdef_fns:{it | #$first(it)$
           $first(rest(it))$($first(rest(rest(it)))$){
           $first(rest(rest(rest(it))))$
         }
       #endif} ;separator=\"\n\"$
       };
       $post_code$
      }")]
      (fill-view! view "name" name)
      (fill-view! view "interface" interface)
      (fill-view! view "interface_only" interface-only)
      (fill-view! view "object_type" (cond (specs 'force_type) true
                                           interface-only false
                                           :default true))
      (fill-view! view "type" (.toUpperCase (str name)))
      (fill-view! view "type_val" (gensym ""))
      (fill-view! view "data" (specs 'data))
      (fill-view! view "new" (specs 'new))
      (fill-view! view "equals" (first (specs 'equals)))
      (fill-view! view "toOutputStream" (first (specs 'toOutputStream)))
      (fill-view! view "interfaces" (specs 'interfaces))
      (fill-view! view "fns" (filter #(= 3 (count %)) (specs 'fns)))
      (fill-view! view "ifdef_fns" (filter #(= 4 (count %)) (specs 'fns)))
      (fill-view! view "post_code" (first (specs 'post_code)))
      (render-view view)))

  (defn solution-template [source]
    (let [{:keys [body lambdas symbol-table native-declarations]} source
          view (create-view "
      $object_interface$

      #ifdef GNU_GCC
        VAR _star_command_line_args_star_;
      #endif

      $symbols:{VAR $it$;} ;separator=\"\n\"$

      $native_declarations:{$it$} ;separator=\"\n\"$      

      namespace ferret{
        $lambdas:{$it$} ;separator=\"\n\"$
      }

      int main(int argc, char* argv[]){
      
        INIT_ENV

      #ifdef GNU_GCC
        _star_command_line_args_star_ = VAR(new ferret::Sequence());
        for (int i = argc - 1; i > -1 ; i--)
          _star_command_line_args_star_ =
             SEQUENCE(_star_command_line_args_star_)->cons(VAR(new ferret::String(argv[i])));
      #endif
        $body:{$it$;} ;separator=\"\n\"$
        return 0;
      }")]
      (fill-view! view "object_interface" (read-from-url "Object.cpp"))
      (fill-view! view "body" (filter #(not (empty? %)) body))
      (fill-view! view "lambdas" (declare-lambdas lambdas))
      (fill-view! view "symbols" symbol-table)
      (fill-view! view "native_declarations" native-declarations)
      (render-view view)))
#+end_src    

* Runtime
** Native

On the C++ side we define our own object system, which includes the
following types,

Object Casting macros,

#+name: runtime-native-object-casting-macros
#+begin_src c++ :tangle no
  #define IS_NIL(o) (o.get() == NULL)
  #define IS_NOT_NIL(o) (o.get() != NULL)
  #define OBJECT(v) static_cast<ferret::Object*>(v.get())
  #define POINTER(v) static_cast<ferret::Pointer*>(v.get())
  #define NUMBER(v) static_cast<ferret::Number*>(v.get())
  #define CHARACTER(v) static_cast<ferret::Character*>(v.get())
  #define BOOLEAN(v) static_cast<ferret::Boolean*>(v.get())
  #define KEYWORD(v) static_cast<ferret::Keyword*>(v.get())
  #define ISEEKABLE(v) static_cast<ferret::ISeekable*>(v.get())
  #define CELL(v) static_cast<ferret::Cell*>(v.get())
  #define SEQUENCE(v) static_cast<ferret::Sequence*>(v.get())
  #define STRING(v) static_cast<ferret::String*>(v.get())
  #define LAMBDA(v) static_cast<ferret::Lambda*>(v.get())
#+end_src

*** Object

#+name: runtime-native-object
#+begin_src c++ :tangle no
class Object{
    public:
      Object() : refCount(0) {}
      virtual ~Object() {};
  
      virtual int getType() = 0;
      virtual var toOutputStream() = 0;
      virtual var equals(var o) = 0;
  
      void addRef() { refCount++; }
      bool subRef() { return (--refCount <= 0); }
  
  
      void* operator new(size_t size){ 
        return malloc(size); 
      } 
  
      void  operator delete(void * ptr){ 
        free(ptr); 
      }
  
      void* operator new[](size_t size){ 
        return malloc(size); 
      }
  
      void  operator delete[](void * ptr){ 
        free(ptr); 
      }
  
    private:
      int refCount;
    };
#+end_src

All our types are derived from the base Object type,(defining
new/delete is needed because in avr-gcc they are not defined.)

*** Pointer

#+name: runtime-clojure-pointer-object
#+begin_src clojure :tangle no
  (defobject Pointer
    (data "void* ptr")
    (new ("void* p" "ptr = p;"))
    (equals
     "return ptr = POINTER(o)->ptr;")
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"Pointer\"); return var();"))
#+end_src

#+name: runtime-native-iseekable-macros
#+begin_src c++ :tangle no
  #define NEW_POINTER(p) (VAR(new ferret::Pointer(p)))
  #define TO_POINTER(p,type) ((type *)POINTER(p)->ptr)
#+end_src

*** Number

Math configuration,

#+name: runtime-native-math-config
#+begin_src c++ :tangle no
  #define NUMBER_PRECISION 1000 //used when reading floats.
  //#define NUMBER_DATA_TYPE long
  //#define NUMBER_DATA_TYPE_FORMAT "%ld"
  #define NUMBER_DATA_TYPE int
  #define NUMBER_TYPE_FORMAT "%d"
#+end_src

#+name: runtime-clojure-number-object
#+begin_src clojure :tangle no
  (defobject Number
    (data "NUMBER_DATA_TYPE numerator"
          "NUMBER_DATA_TYPE denominator")
    (new ("NUMBER_DATA_TYPE x"
          "numerator = x; denominator = 1;")
         ("NUMBER_DATA_TYPE n, NUMBER_DATA_TYPE dn"
          "numerator = n; denominator = dn; simplificate();")
         ("float x"
          "float decimal = (x - (NUMBER_DATA_TYPE)x) * (float)NUMBER_PRECISION;
           NUMBER_DATA_TYPE integer = (NUMBER_DATA_TYPE)x;
           numerator = decimal + (integer * NUMBER_PRECISION);
           denominator = NUMBER_PRECISION;
           simplificate();"))
    (equals "int self_type = getType();
             int other_type = OBJECT(o)->getType();
             if (self_type == NUMBER_TYPE && other_type == NUMBER_TYPE)
               if (getNumerator() == 0 && NUMBER(o)->getNumerator() == 0)
                 return true;
               else
                 return ((getNumerator() == NUMBER(o)->getNumerator()) &&
                         (getDenominator() == NUMBER(o)->getDenominator()));
             else
               return false;")
    (toOutputStream
     "if (denominator == 1)
        fprintf(OUTPUT_STREAM, NUMBER_TYPE_FORMAT, numerator);
      else if (numerator == 0)
        fprintf(OUTPUT_STREAM, \"0\");
      else{
        fprintf(OUTPUT_STREAM, NUMBER_TYPE_FORMAT,numerator);
        fprintf(OUTPUT_STREAM, \"/\");
        fprintf(OUTPUT_STREAM, NUMBER_TYPE_FORMAT,denominator);
      }
      return var();")
    
    (fns
      ("NUMBER_DATA_TYPE getNumerator" "" "return numerator;")
      ("NUMBER_DATA_TYPE getDenominator" "" "return denominator;")
      ("float floatValue" "" "return (float)numerator/(float)denominator;")
      ("int intValue" ""
       "if (denominator == 1)
          return (int)numerator;
        else
          return (int)floatValue();")
      ("void simplificate" ""
       "int commondivisor = 1;
        for(NUMBER_DATA_TYPE i=2;i<=MIN(ABS(numerator), ABS(denominator));i++)
          if( numerator%i == 0 && denominator%i == 0 )
            commondivisor = i;
        numerator /= commondivisor;
        denominator /= commondivisor;")
      ("~Number" "" "")
      ("if NUMBER_DATA_TYPE != int"
       "Number" "int x" "numerator = x; denominator = 1;"))
    
    (post-code "
    #if NUMBER_DATA_TYPE != int
    var::var(int i){
      m_ptr = new Number(i);
      addRef();
    }
    #endif

    var::var(NUMBER_DATA_TYPE i){
      m_ptr = new Number(i);
      addRef();
    }

    var::var(NUMBER_DATA_TYPE n, NUMBER_DATA_TYPE dn){
      m_ptr = new Number(n,dn);
      addRef();
    }

    var::var(float f){
      m_ptr = new Number(f);
      addRef();
    }"))
#+end_src

#+name: runtime-native-math-config
#+begin_src c++ :tangle no
  #define TO_INT(i) (NUMBER(i)->intValue())
#+end_src

*** Keyword

#+name: runtime-clojure-keyword-object
#+begin_src clojure :tangle no
  (defobject Keyword
    (data "int id")
    (new ("int b" "id=b;")
         ("const char * str"
          "id = 0;
           for (int i = 0; str[i] != '\\0'; i++){
             id = id + (int)str[i];
           }"))
    (equals
     "if (OBJECT(o)->getType() != KEYWORD_TYPE)
        return false;
      return (id == KEYWORD(o)->id);")
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"%d\", id); return var();")
    (fns ("bool equals" "Keyword k"
          "return (id == k.id);")))
#+end_src

#+name: native-keyword-tests
#+begin_src clojure :tangle no
  (deftest native-keyword-test
    (is (= "true false true "
           (capture-output '((print (= :test :test)
                                    (= :test :other_test)
                                    ((fn [keyword]
                                       "__result = VAR(keyword.equals(VAR(new ferret::Keyword(\":space\"))))")
                                     :space)))))))
#+end_src

*** Character

#+name: runtime-clojure-character-object
#+begin_src clojure :tangle no
  (defobject Character
    (data "char value")
    (new ("char c" "value = c;"))
    (equals
     "if (OBJECT(o)->getType() != CHARACTER_TYPE)
        return false;
      return (value == CHARACTER(o)->value);")
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"%c\",value); return var();"))
#+end_src

*** Seekable Interface

#+name: runtime-clojure-seekable-interface
#+begin_src clojure :tangle no
  (defobject ISeekable
    (interfaces "var cons(var x)"
                "var first()"
                "var rest()")
    (fns ("virtual ~ISeekable" "" "")))
#+end_src

#+name: runtime-native-iseekable-macros
#+begin_src c++ :tangle no
  #define FIRST(coll) (ISEEKABLE(coll)->first())
  #define REST(coll) (ISEEKABLE(coll)->rest())
  #define ITERATE(c,i) for(var i = c; IS_NOT_NIL(i) ; it = REST(i))

  #define NEW_SEQUENCE() (VAR(new ferret::Sequence()))
  #define CONS(s,v) (s = ISEEKABLE(s)->cons(v))
#+end_src

*** Sequence

#+name: runtime-clojure-cell-object
#+begin_src clojure :tangle no
  (defobject Cell
    (data "var data"
          "var next")
    (new ("" "")
         ("var d, var n" "data = d; next = n;"))
    (equals "if (OBJECT(o)->getType() != CELL_TYPE)
              return false;
             return data.equals(o);")
    (toOutputStream
     "OBJECT(data)->toOutputStream(); return var();"))
#+end_src

#+name: runtime-clojure-sequence-object
#+begin_src clojure :tangle no
  (defobject Sequence
    (interface :ISeekable)
    (data "var head")
    (new ("" "head = NULL;")
         ("var h" "head = h;"))
    (equals
     "if (OBJECT(o)->getType() != SEQUENCE_TYPE)
       return false;
      var itOther = o;
      ITERATE(this,it){
        if (IS_NIL(itOther) || FIRST(it).equals(FIRST(itOther))  == false)
          return false;
        itOther = REST(itOther);
      }
      return true;")
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"( \");
      ITERATE(this,it){
        FIRST(it).toOutputStream();
        fprintf(OUTPUT_STREAM, \" \");
      }
      fprintf(OUTPUT_STREAM, \")\");
      return var();")

    (fns
     ("var cons" "var x"
      "return var(new Sequence(var(new Cell(x,head))));")
     ("var first" ""
      "if (head.get() == NULL )
         return var();
        else
         return CELL(head)->data;")
     ("var rest" ""
      "if ( head.get() == NULL || CELL(head)->next.get() == NULL )
         return var();
        else
         return var(new Sequence(CELL(head)->next));"))
    (post-code
     "ferret::var& ferret::var::operator, (const var& m){
        ,*this = static_cast<ferret::Sequence*>(m_ptr)->cons(m);
        return *this;
      }"))
#+end_src

*** String

#+name: runtime-clojure-string-object
#+begin_src clojure :tangle no
  (defobject String
    (interface :ISeekable)
    (data "var data")
    (new (""
          "data = NULL;")
         ("var s"
          "data = s;")
         ("const char * str"
          "int length = 0;
           for (length = 0; str[length] != '\\0'; length++);
           length--;
           var s = var(new Sequence());
           for (int i = length; i >= 0; i--)
             s = ISEEKABLE(s)->cons(VAR(new ferret::Character(str[i])));
           data = s;"))
    (equals
     "if (OBJECT(o)->getType() != STRING_TYPE)
       return false;
      return data.equals(STRING(o)->data);")
    (toOutputStream
     "ITERATE(data,it){ FIRST(it).toOutputStream(); }
      return var();")
    (fns
     ("var cons" "var x"
      "return ISEEKABLE(data)->cons(x);")
     ("var first" ""
      "return FIRST(data);")
     ("var rest" ""
      "return REST(data);")
     ("ifdef GNU_GCC"
      "std::string toString" ""
      "std::stringstream ss;
       ITERATE(data,it){ss << CHARACTER(FIRST(it))->value;}
       return ss.str();")))
#+end_src

#+name: runtime-native-iseekable-macros
#+begin_src c++ :tangle no
  #define NEW_STRING(s) (VAR(new ferret::String(s)))
  #define TO_C_STR(s) (STRING(s)->toString().c_str())
#+end_src

#+name: native-string-tests
#+begin_src clojure :tangle no
  (deftest native-string-test
    (is (= "Some String false true false true "
           (capture-output '((print "Some String"
                                    (= "Some String" "Other String")
                                    (= "Some String" "Some String")
                                    (= "Some String" 1)
                                    ((fn [str] "__result = VAR((STRING(str)->toString() == \"String\"))")
                                     "String")
                                    ))))))
#+end_src
*** Boolean

#+name: runtime-clojure-boolean-object
#+begin_src clojure :tangle no
  (defobject Boolean
    (data "bool value")
    (new ("bool b" "value = b;"))
    (equals "if (OBJECT(o)->getType() != BOOLEAN_TYPE)
               return false;
             return (value == BOOLEAN(o)->asBool());")
    (toOutputStream
     "if (value)
        fprintf(OUTPUT_STREAM, \"true\"); 
      else
      fprintf(OUTPUT_STREAM, \"false\"); 
      return var();")
    
    (fns
     ("bool asBool" "" "return value;"))
    
    (post-code "  
    var::var(bool b){
      m_ptr = new Boolean(b);
      addRef();
    }

    bool var::equals (var rhs){
      if (get() == rhs.get())
        return true;
      else
        return BOOLEAN(get()->equals(rhs))->asBool();
    }"))
#+end_src

*** Lambda

except functors, they derive from the class Lambda, which has a single
invoke method that takes a sequence of vars as argument, this allows us
to execute them in a uniform fashion.

#+name: runtime-clojure-lambda-interface
#+begin_src clojure :tangle no
  (defobject Lambda
    (interfaces "var invoke(var args)")
    (equals "return false;")
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"lambda\"); return VAR();")
    (force-type true))
#+end_src

Function invocation macros,

#+name: runtime-native-lambda-invoke-macros
#+begin_src c++ :tangle no
  #define VA_ARGS(...) , ##__VA_ARGS__
  #define INVOKE(f,...) LAMBDA(f)->invoke((ferret::var(new ferret::Sequence()) VA_ARGS(__VA_ARGS__)))
  #define FN(f,...) ferret::var(new ferret::f(__VA_ARGS__))
#+end_src

*** var

Garbage collection is handled by reference counting, a /var/ holds a
pointer to an Object, everything is passed around as /vars/ it is
responsible for incrementing/decrementing the reference count, when it
reaches zero it will automatically free the Object. 

#+name: runtime-native-var
#+begin_src c++ :tangle no
  class var{
  public:
    var(Object* ptr=0) : m_ptr(ptr) { addRef(); }

    var(const var& p) : m_ptr(p.m_ptr) { addRef(); }
      
    ~var() { subRef(); }
      
    var& operator= (const var& p){
      return *this = p.m_ptr;
    }

    bool equals (var rhs);
      
    var& operator= (Object* ptr){
      if (m_ptr != ptr){
        subRef();
        m_ptr=ptr;
        addRef();
      }
      return *this;
    }

  #if NUMBER_DATA_TYPE != int
    var(int i);
  #endif

    var(NUMBER_DATA_TYPE i);
    var(NUMBER_DATA_TYPE n, NUMBER_DATA_TYPE dn);
    var(float f);
    var(bool b);
      
    var& operator, (const var& m);
    var toOutputStream() {
      if (m_ptr != NULL )
        m_ptr->toOutputStream();
      else
        fprintf(OUTPUT_STREAM, "nil");
      return var();
    }
      
    Object* get() { return m_ptr; }
      
  private:
    void addRef(){
      // Only change if non-null
      if (m_ptr) m_ptr->addRef();
    }
      
    void subRef(){
      // Only change if non-null
      if (m_ptr){
        // Subtract and test if this was the last pointer.
        if (m_ptr->subRef()){
          delete m_ptr;
          m_ptr=0;
        }
      }
    }
      
    Object* m_ptr;
  };
#+end_src

*** Program Header

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
  #ifdef __AVR__
  # define AVR_GCC TRUE
  #else
  # define GNU_GCC TRUE
  #endif

  #include <stdlib.h>
  #include <stdio.h>

  #ifdef GNU_GCC
  #include <iostream>
  #include <sstream>
  #endif

  #ifdef AVR_GCC
  #include "Arduino.h"
  #endif

  //
  // Compiler Specific
  //

  #ifdef AVR_GCC
  extern "C" void __cxa_pure_virtual(void); 

  static FILE uartout = {0};

  static int uart_putchar (char c, FILE *stream){
    Serial.write(c);
    return 0 ;
  }

  #define OUTPUT_STREAM &uartout

  #define INIT_ENV                                                        \
    init();                                                               \
    Serial.begin(9600);                                                   \
    fdev_setup_stream (&uartout, uart_putchar, NULL, _FDEV_SETUP_WRITE);  \

  #endif

  #ifdef GNU_GCC
  #define OUTPUT_STREAM stdout
  #define INIT_ENV 
  #endif

  #define VAR ferret::var

  #define MIN(a,b) ((a)<(b)?(a):(b))
  #define ABS(a) ((a)<0 ? -(a) : (a))
#+end_src

** Lisp

Once our object system is in place we can define rest of the runtime
(functions/macros) using our Clojure subset,

#+name: runtime-clojure-first
#+begin_src clojure :tangle no
  (defn first [x]
    "if(x.get() == NULL)
      __result = VAR();
    else
      __result = FIRST(x);")

  (defn nil? [x] "__result = (x.get() == NULL)")

  (defn char? [x] "__result = (OBJECT(x)->getType() == CHARACTER_TYPE);")
#+end_src

We can embed C++ code into our functions, which is how most of the
primitive functions are defined such as the /first/ function above,
once primitives are in place rest can be defined in pure Clojure,

#+name: runtime-clojure-println
#+begin_src clojure :tangle no
  (defn println [& more]
    (apply print more)
    (newline))
#+end_src

As for macros, normal Clojure rules apply since they are expended using
Clojure, the only exception is that stuff should not expand to fully
qualified Clojure symbols, so the symbol /fn/ should not expand to
/clojure.core/fn/,

#+name: runtime-clojure-defn
#+begin_src clojure :tangle no
  (defmacro defn [name args & body]
    (list 'def name (cons 'fn `( ~args ~@body))))

  (defmacro let [bindings & body]
    (cons 'let* `(~bindings ~@body)))

  (defmacro native-header [& body]
    (cons 'native-declare
          (->> (map #(str "#include \"" (str %) "\"\n") body)
               (apply str)
               (list))))
#+end_src

*** Misc

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defn sleep [timeout]
    (native-block
     (on "defined GNU_GCC"
         ("unistd.h")
         "::sleep(NUMBER(timeout)->intValue());")
     (on "defined AVR_GCC"
         "::delay(NUMBER(timeout)->intValue());")))

  (defn get-char []
    (native-block
     (on "defined GNU_GCC"
         "__result = ferret::var(getchar());")))

  (defmacro create-callback [callback out in & pass-vars]
    (list 'do
          (list 'native-declare
                `~(str "\n" out " " (symbol-conversion callback) "_callback" "(" in "){\n"
                       "INVOKE(" (str (symbol-conversion callback) "_callback_fn")
                       (str \, (apply str (interpose " , " (reverse pass-vars)))) ");"
                       "\n}\n"))
          (list 'def `~(symbol (str callback "-callback-fn")) `~callback)))
#+end_src

*** Console I/O

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defn print [& more]
    "ITERATE(more,it){
         FIRST(it).toOutputStream();
         fprintf(OUTPUT_STREAM, \" \");
     }")

  (defn newline []
    "fprintf(OUTPUT_STREAM, \"\\n\");")

  <<runtime-clojure-println>>
#+end_src

*** Looping

#+name: runtime-clojure-looping
#+begin_src clojure :tangle no
  (defmacro doseq [binding & body]
    (list '_doseq_ (second binding) (cons 'fn `( [~(first binding)] ~@body))))

  (defn _doseq_ [seq f] "ITERATE(seq,it){INVOKE(f,FIRST(it));}")

  (defmacro dotimes [binding & body]
    (list '_dotimes_ (second binding) (cons 'fn `( [~(first binding)] ~@body))))

  (defn _dotimes_ [t f] "for(int i = 0; i < NUMBER(t)->intValue(); i++) INVOKE(f,i);")
#+end_src

*** Conditionals

#+name: runtime-clojure-conditionals
#+begin_src clojure :tangle no
  (defmacro when [test & body]
    (list 'if test (cons 'do body)))

  (defmacro cond
    [& clauses]
    (when clauses
      (list 'if (first clauses)
            (if (next clauses)
              (second clauses)
              (throw (IllegalArgumentException.
                      "cond requires an even number of forms")))
            (cons 'cond (next (next clauses))))))

  (defmacro while [test & body]
    (list '_while_ (list 'fn [] test) (cons 'fn `( [] ~@body))))

  (defn _while_ [pred fn]
    "while(BOOLEAN(INVOKE(pred))->asBool() == true)
       INVOKE(fn);")

  (defmacro forever [& body]
    (cons 'while `(true  ~@body)))
#+end_src

#+name: runtime-clojure-conditionals-tests
#+begin_src clojure :tangle no
  (deftest conditionals-test
    (is (= "2 1 -1 2 2 2 1 "
           (capture-output '((print (if 1 2)
                                    (if (zero? 0) 1 -1)
                                    (if (zero? 1) 1 -1)
                                    (when true 2)
                                    (when (integer? 2) 2)
                                    (cond (float? 2.1) 2
                                          (integer? 2) 4
                                          :default 1)
                                    (cond (float? 2) 2.1
                                          (integer? 2.1) 4
                                          :default 1)))))))
#+end_src

*** Sequence

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn _reduce_2_arg_ [f coll]
    "var first = FIRST(coll);
     var rest = REST(coll);
     var acc = INVOKE(f,first,FIRST(rest));
     ITERATE(REST(rest),it){
       acc = INVOKE(f, FIRST(it), acc);
     }
     return acc;")

  (defn _reduce_3_arg_ [f val coll]
    "if (IS_NIL(coll) || IS_NIL(SEQUENCE(coll)->head))
      return val;
     ITERATE(coll,it){
       val = INVOKE(f, FIRST(it), val);
     }
     return val;")

  (defmacro reduce [& args]
    (if (= 2 (count args))
      (cons '_reduce_2_arg_ `~args)
      (cons '_reduce_3_arg_ `~args)))
#+end_src

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn list [& xs] "__result = xs;")

  (defn list? [x] "__result = (OBJECT(x)->getType() == SEQUENCE_TYPE);")

  (defn empty? [x] "__result = (IS_NIL(x) || IS_NIL(SEQUENCE(x)->head))")

  (defn rest [x] "__result = REST(x);")

  (defn cons [x seq] "if IS_NIL(seq)
                       seq = VAR(new Sequence());
                      __result = SEQUENCE(seq)->cons(x);")

  (defn apply [f args] "__result = LAMBDA(f)->invoke(args);")

  (defn conj [coll & xs]
    (reduce (fn[h v] (cons v h)) (if (nil? coll) (list) coll) xs))

  (defn reverse [s]
    (reduce conj (list) s))

  (defn count [s] "NUMBER_DATA_TYPE count = (NUMBER_DATA_TYPE)0;
                   ITERATE(s,it){
                     count = count + 1;
                   }
                   __result = VAR(count);")
#+end_src

#+name: runtime-clojure-sequences-tests
#+begin_src clojure :tangle no
  (deftest sequences-test
    (is (= "( 1 2 3 4 ) 1 ( 2 3 4 ) ( 3 4 ) ( 3 3 4 ) 3 4 ( 4 3 2 1 1 2 ) ( 4 3 2 1 ) 21 21 ( nil ) ( 1 ) "
           (capture-output '((print (list 1 2 3 4)
                                    (first (list 1 2 3 4))
                                    (rest (list 1 2 3 4))
                                    (rest (rest (list 1 2 3 4)))
                                    (cons 3 (rest (rest (list 1 2 3 4))))
                                    (first (cons 3 (rest (rest (list 1 2 3 4)))))
                                    (count (list 1 2 3 4))
                                    (conj (list 1 2) 1 2 3 4)
                                    (conj nil 1 2 3 4)
                                    (reduce + (list 1 2 3 4 5 6))
                                    (apply + (list 1 2 3 4 5 6))
                                    (cons nil nil)
                                    (cons 1 nil))))))
    (is (= "( 6 5 4 3 2 1 ) ( 6 5 4 3 2 ) ( 4 3 2 1 0 ) ( . o l l e H ) "
           (capture-output '((print (reverse (list 1 2 3 4 5 6))
                                    (reduce (fn [h v]
                                              (conj h (inc v))) (list) (list 1 2 3 4 5))
                                    (reduce (fn [h v]
                                              (conj h (dec v))) (list) (list 1 2 3 4 5))
                                    (reduce (fn [h v]
                                              (conj h v)) (list) "Hello."))))))

    (is (= "( 1 2 3 4 5 6 ) ( 7 6 5 4 3 2 ) ( 1 7 6 5 4 3 2 ) "
           (capture-output '((let [l1 (list 1 2 3 4 5 6)
                                   l2 (reduce (fn[h v] (conj h (inc v))) (list) l1)
                                   l3 (cons 1 l2)]
                               (print l1 l2 l3)))))))
#+end_src
*** Logical Operators

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn = [a & more]
    (if (empty? more)
      true
      (and ((fn [a b] "__result = a.equals(b);") a (first more))
           (apply = more))))

  (defmacro not= [& test]
    (list 'not (cons '= `( ~@test))))

  (defn < [a & more]
    (if (empty? more)
      true
      (and ((fn [a b] "
      NUMBER_DATA_TYPE an = NUMBER(a)->getNumerator();
      NUMBER_DATA_TYPE adn = NUMBER(a)->getDenominator();

      NUMBER_DATA_TYPE bn = NUMBER(b)->getNumerator();
      NUMBER_DATA_TYPE bdn = NUMBER(b)->getDenominator();

      __result = VAR((an * bdn) < (bn * adn));") a (first more))
           (apply < more))))

  (defn > [a & more]
    (if (empty? more)
      true
      (and ((fn [a b] "
      NUMBER_DATA_TYPE an = NUMBER(a)->getNumerator();
      NUMBER_DATA_TYPE adn = NUMBER(a)->getDenominator();

      NUMBER_DATA_TYPE bn = NUMBER(b)->getNumerator();
      NUMBER_DATA_TYPE bdn = NUMBER(b)->getDenominator();

      __result =  VAR((an * bdn) > (bn * adn));") a (first more))
           (apply > more))))

  (defn >= [a & more]
    (if (empty? more)
      true
      (and ((fn [a b] "
      NUMBER_DATA_TYPE an = NUMBER(a)->getNumerator();
      NUMBER_DATA_TYPE adn = NUMBER(a)->getDenominator();

      NUMBER_DATA_TYPE bn = NUMBER(b)->getNumerator();
      NUMBER_DATA_TYPE bdn = NUMBER(b)->getDenominator();

      return VAR((an * bdn) >= (bn * adn));") a (first more))
           (apply >= more))))

  (defn <= [a & more]
    (if (empty? more)
      true
      (and ((fn [a b] "
      NUMBER_DATA_TYPE an = NUMBER(a)->getNumerator();
      NUMBER_DATA_TYPE adn = NUMBER(a)->getDenominator();

      NUMBER_DATA_TYPE bn = NUMBER(b)->getNumerator();
      NUMBER_DATA_TYPE bdn = NUMBER(b)->getDenominator();

      __result = VAR((an * bdn) <= (bn * adn));") a (first more))
           (apply <= more))))

  (defmacro and
    ([] true)
    ([x] x)
    ([x & next]
     (list 'if x `(and ~@next) false)))

  (defmacro or
    ([] nil)
    ([x] x)
    ([x & next]
     (list 'if x x `(or ~@next))))

  (defn not [x]
    "if (OBJECT(x)->getType() != BOOLEAN_TYPE)
        return false;
        __result = !BOOLEAN(x)->asBool();")
#+end_src

#+name: runtime-clojure-logical-operators-tests
#+begin_src clojure :tangle no
  (deftest logical-operators-test
    (is (= "true true false true false true true true false true true false true false true true "
           (capture-output '((print (< 2)
                                    (< 2 3 4 5)
                                    (< 2 3 6 5)
                                    (> 2)
                                    (> 2 3 4 5)
                                    (> 6 5 4 3)
                                    (>= 2)
                                    (>= 5 4 3 2 2 2)
                                    (>= 5 1 3 2 2 2)
                                    (<= 2)
                                    (<= 2 2 3 4 5)
                                    (<= 2 2 1 3 4)
                                    (= 2)
                                    (= 2 3)
                                    (= 2 2 2 2)
                                    (= 2 2.0 2))))))

    (is (= "false true false true false false true false true true "
           (capture-output '((print (= 2 2 2 2 3 5)
                                    (= (list 1 2) (list 1 2))
                                    (= (list 1 2) (list 1 3))
                                    (= true true)
                                    (not (= true true))
                                    (not 1))
                             (let [a (fn [x] (+ 1 x))
                                   b (fn [x] (inc x))]
                               (print (= a a)
                                      (= a b)
                                      (= nil ((fn [] )))
                                      (= nil ((fn [x y] ) 1 2)))))))))
#+end_src

*** Math

#+name: runtime-clojure-math
#+begin_src clojure :tangle no
  (defn integer? [x] "__result = ((OBJECT(x)->getType() == NUMBER_TYPE) &&
                                    (NUMBER(x)->getDenominator() == 1));")

  (defn float? [x] "__result = ((OBJECT(x)->getType() == NUMBER_TYPE) &&
                                  (NUMBER(x)->getDenominator() != 1));")

  (defn + [& xs]
    (reduce (fn[h v] "
        NUMBER_DATA_TYPE hn = NUMBER(h)->getNumerator();
        NUMBER_DATA_TYPE hdn = NUMBER(h)->getDenominator();

        NUMBER_DATA_TYPE vn = NUMBER(v)->getNumerator();
        NUMBER_DATA_TYPE vdn = NUMBER(v)->getDenominator();

        NUMBER_DATA_TYPE ndn = (hdn * vdn);

        __result = VAR(((hn * vdn) + (vn * hdn)),ndn);") 0 xs))

  (defn * [& xs]
    (reduce (fn[h v] "
        NUMBER_DATA_TYPE hn = NUMBER(h)->getNumerator();
        NUMBER_DATA_TYPE hdn = NUMBER(h)->getDenominator();

        NUMBER_DATA_TYPE vn = NUMBER(v)->getNumerator();
        NUMBER_DATA_TYPE vdn = NUMBER(v)->getDenominator();

        NUMBER_DATA_TYPE ndn = (hdn * vdn);

        __result = VAR(((hn * vdn) * (vn * hdn)),ndn);") 1 xs))

  (defn - [& xs]
    (if (= (count xs) 1)
      (* -1 (first xs))
      (reduce (fn[h v] "
        NUMBER_DATA_TYPE hn = NUMBER(h)->getNumerator();
        NUMBER_DATA_TYPE hdn = NUMBER(h)->getDenominator();

        NUMBER_DATA_TYPE vn = NUMBER(v)->getNumerator();
        NUMBER_DATA_TYPE vdn = NUMBER(v)->getDenominator();

        NUMBER_DATA_TYPE ndn = (hdn * vdn);

        __result = VAR(((hn * vdn) - (vn * hdn)),ndn);") (first xs) (rest xs))))

  (defn / [& xs]
    (if (= (count xs) 1)
      (apply / (cons 1 xs))
      (reduce (fn[h v] "
        NUMBER_DATA_TYPE hn = NUMBER(h)->getNumerator();
        NUMBER_DATA_TYPE hdn = NUMBER(h)->getDenominator();

        NUMBER_DATA_TYPE vn = NUMBER(v)->getNumerator();
        NUMBER_DATA_TYPE vdn = NUMBER(v)->getDenominator();

        __result = VAR((hn * vdn),(vn * hdn));") (first xs) (rest xs))))

  (defn inc [x]
    (+ x 1))

  (defn dec [x]
    (- x 1))

  (defn pos? [x]
    (> x 0))

  (defn neg? [x]
    (< x 0))

  (defn zero? [x]
    (= x 0))
#+end_src

#+name: runtime-clojure-bit-arithmetic-tests
#+begin_src clojure :tangle no
  (deftest arithmetic-test
    (is (= "3/5 0 1 10 10 -1 0 0 1 8 8 1 1/2 1 1 "
           (capture-output '((print (+ 0.3 0.3)
                                    (+ )
                                    (+ 1)
                                    (+ 1 2 3 4)
                                    (+ 1 2.0 3 4)

                                    (- 1)
                                    (- 4 2 2)
                                    (- 4 2 2.0)
                                    
                                    (* )
                                    (* 2 2 2)
                                    (* 2.0 2 2)
                                    
                                    (/ 1)
                                    (/ 2)
                                    (/ 4 2 2)
                                    (/ 4 2 2.0))))))

    (is (= "true true false false true true false true true true "
           (capture-output '((print (pos? 1)
                                    (pos? 0.2)
                                    (pos? 0)
                                    (neg? 1)
                                    (neg? -1)
                                    (zero? 0)
                                    (zero? 10)
                                    (zero? (- 1 1))
                                    (zero? (- 1.2 1.2))
                                    (zero? (+ 1.2 -1.2)))))))

    (is (= "1 2 1 2 1 2 1 2 "
           (capture-output '((let [a 1
                                   b 2]
                               (+ 1 a)
                               (+ b a)
                               (print a b)
                               (* 2 a)
                               (* b a)
                               (print a b)
                               (/ 2 a)
                               (/ b a)
                               (print a b)
                               (- 2 a)
                               (- b a)
                               (print a b)))))))
#+end_src

*** Bit Operations

#+name: runtime-clojure-bit-operations
#+begin_src clojure :tangle no
  (defn bit-not [x] "__result = VAR(~NUMBER(x)->getNumerator());")

  (defn bit-and [x y] "__result = VAR((NUMBER(x)->getNumerator() &
                                       NUMBER(y)->getNumerator()));")

  (defn bit-or [x y] "__result = VAR((NUMBER(x)->getNumerator() |
                                      NUMBER(y)->getNumerator()));")

  (defn bit-xor [x y] "__result = VAR((NUMBER(x)->getNumerator() ^
                                       NUMBER(y)->getNumerator()));")

  (defn bit-shift-left [x n] "__result = VAR((NUMBER(x)->getNumerator() <<
                                              NUMBER(n)->getNumerator()));")

  (defn bit-shift-right [x n] "__result = VAR((NUMBER(x)->getNumerator() >>
                                               NUMBER(n)->getNumerator()));")
#+end_src

#+name: runtime-clojure-bit-operations-tests
#+begin_src clojure :tangle no
  (deftest bit-operations-test
    (is (= "-5 -1 7 1 0 0 0 1 8 16 2 1 "
           (capture-output '((print (bit-not  4)
                                    (bit-not  0)
                                    (bit-or   4 3)
                                    (bit-or   0 1)
                                    (bit-and  4 3)
                                    (bit-and  0 1)
                                    (bit-xor  4 4)
                                    (bit-xor  1 0)
                                    (bit-shift-left 4 1)
                                    (bit-shift-left 4 2)
                                    (bit-shift-right 4 1)
                                    (bit-shift-right 4 2)))))))
#+end_src

*** Concurrency

Runs the given lambda in a posix thread,

#+name: runtime-clojure-bit-operations
#+begin_src clojure :tangle no
  (defn pthread-create [f]
    (native-block
     (on "defined GNU_GCC"
         ("pthread.h")
          "void *PTHREAD_LAMBDA_INVOKER(void *data) {
            ferret::var fn = ferret::var(static_cast<ferret::Object*>(data));
            OBJECT(fn)->subRef();
            INVOKE(fn);
            pthread_exit(NULL);
           }"
          "pthread_t th;
           OBJECT(f)->addRef();
           if(::pthread_create(&th, 0, &PTHREAD_LAMBDA_INVOKER, static_cast<void*>(f.get())))
             return VAR();
           __result = pthread_detach(th);")))
#+end_src

#+name: runtime-clojure-bit-operations-tests
#+begin_src clojure :tangle no
  (deftest pthreads-test
    (is (= "Thread-1 Thread-2 "
           (capture-output '((defn print-some [y x]
                               (fn []
                                 (sleep y)
                                 (print x)))
                             (pthread-create (print-some 0 "Thread-1"))
                             (pthread-create (print-some 1 "Thread-2"))
                             (sleep 3))))))
#+end_src

*** Arduino

#+name: runtime-clojure-arduino
#+begin_src clojure :tangle no
  (defn pin-mode [pin mode]
    "if (mode.equals(VAR(new ferret::Keyword(\":input\"))) == true)
        pinMode(NUMBER(pin)->intValue(), INPUT);
     else
        pinMode(NUMBER(pin)->intValue(), OUTPUT);")

  (defn digital-write [pin mode]
    "if (mode.equals(VAR(new ferret::Keyword(\":high\")))  == true)
        digitalWrite(NUMBER(pin)->intValue(), HIGH);
     else
        digitalWrite(NUMBER(pin)->intValue(), LOW);")
#+end_src

* Misc
** I/O

  #+name: core-code-generation-misc
  #+begin_src clojure
    ;; I/O
    (defn read-clojure-file [f]
      (try
        (read-string (str \( (FileUtils/readFileToString (file f)) \)))
        (catch Exception e
          (println "Error Reading," f e)
          (System/exit 1))))

    (defn copy-to-solution [fin fout]
      (FileUtils/copyURLToFile (ClassLoader/getSystemResource fin) (file fout)))

    (defn delete-recursively [file]
      (let [func (fn [func f]
                   (when (.isDirectory f)
                     (doseq [f2 (.listFiles f)]
                       (func func f2)))
                   (clojure.java.io/delete-file f))]
        (when (.exists file)
          (func func file))))

    (defn write-to-solution [s f]
      (FileUtils/writeStringToFile (file (str "./" f)) s))

    (defn append-to! [r ks v]
      (dosync 
       (let [cv (reduce (fn[h v] (v h)) @r ks)]
         (alter r assoc-in ks (conj cv v)))))

    (defn to-str? [f]
      (or (true? f) (false? f) (symbol? f)))

    (defn is-special-form? [s f]
      (and (seq? f)
           (= (first f) s)))
  #+end_src

** Main

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn compile-options [& [options]]
      (merge {:compiler "g++"
              :include-path []
              :library-path []
              :link []
              :compiler-options ["-Werror" "-Wall"]
              :source-extension "cpp"}
             options))

    (defn compile->cpp [form options]
      (let [source (emit-source form)]
        (write-to-solution (solution-template source) (str "solution." (:source-extension options)))))

    (defn compile->binary [options extra-source-files]
      (let [command (flatten [(:compiler options)
                              (map #(str %) (:compiler-options options))
                              (map #(str "-I" %) (:include-path options))
                              (map #(str "-L" %) (:library-path options))
                              (map #(str "-l" %) (:link options))
                              (map #(let [extension (org.apache.commons.io.FilenameUtils/getExtension %)]
                                      [(cond (= extension "c") ["-x" "c"]
                                             (= extension "c++") ["-x" "c++"]
                                             :default "")
                                       %])
                                   extra-source-files)
                              ["-x" "c++"]
                              (str "solution." (:source-extension options))])
            ret (with-sh-dir "./"
                  (apply sh command))]
        (println "Running=>" command)
        (println "Return=>" ret)
        (if (not= 0 (:exit ret))
          (System/exit 1)
          (do (when (:name options)
                (with-sh-dir "./"
                  (sh "mv" "a.out" (str "./" (:name options)))))
              true))))

    (defn -main [& args]
      (let [opts [["-i" "--input FILE" "Input File"
                   :parse-fn #(read-clojure-file %)]
                  ["-c" "--compile" "Compile Solution"]
                  ["-o" "--compile-options FILE" "Compile Options File"
                   :parse-fn #(read-string (FileUtils/readFileToString (file %)))]
                  ["-f" "--source-files FILE" "Extra Source Files to Pass to GCC"]
                  ["-h" "--help"]]
            args (parse-opts args opts)
            options (compile-options (->> args :options :compile-options))
            extra-source-files (cond (not (empty? (:arguments args))) (:arguments args)
                                     (not (empty? (:extra-source-files options))) (:extra-source-files options)
                                     :default [])]
        (if (->> args :options :input)
          (do (compile->cpp (->> args :options :input) options)
              (when (->> args :options :compile)
                (compile->binary options extra-source-files)
                (shutdown-agents)))
          (println "No Input File."))))
  #+end_src

* Files                                                            :noexport:
** project.clj
#+begin_src clojure :mkdirp yes :tangle ferret/project.clj
  (defproject ferret "1.0.0-SNAPSHOT"
    :dependencies [[org.clojure/clojure "1.7.0"]
                   [org.clojure/tools.cli "0.3.3"]
                   [org.bituf/clj-stringtemplate "0.2"]
                   [org.clojars.amit/commons-io "1.4.0"]]
    :repl-options {:host "0.0.0.0"
                   :port 7888
                   :init-ns ferret.core}
    :main ferret.core
    :aot [ferret.core]
    :jar-name "interim.jar"
    :uberjar-name "ferret-app.jar")
#+end_src 
** src/core.clj
#+begin_src clojure :noweb yes :mkdirp yes :tangle ferret/src/ferret/core.clj
  (ns ferret.core
    (:gen-class)
    (:use [clojure.java.io]
          [clojure.walk :only [macroexpand-all]])
    (:require [clojure.zip :as zip]
              [clojure.tools.cli :refer [parse-opts]])
    (:use [ferret.string-template]
          [ferret.template]
          [clojure.java.shell])
    (:import (org.apache.commons.io FileUtils)))

  <<core-code-generation-misc>>

  <<core-transformation-form-fns>>

  <<core-transformation-vector-list>>

  <<core-transformation-vector-list>>

  <<core-transformation-expand-macros>>

  <<core-transformation-add-built-in>>

  <<core-transformation-closure-conversion>>

  <<core-transformation-symbol-conversion>>

  <<core-transformation-do-fn>>

  <<core-transformation-let-fn>>

  <<core-transformation-process>>

  <<core-code-generation-emit>>

  <<core-code-generation-emit-source-methods>>

  <<core-code-generation-emit-source>>

  <<core-code-compile-code>>
#+end_src 
** src/template.clj
#+begin_src clojure :mkdirp yes :noweb yes :tangle ferret/src/ferret/template.clj
  (ns ferret.template
    (:use [ferret.string-template])
    (:import (java.io BufferedReader InputStreamReader)))

  (defn read-from-url [f]
    (with-open [in (.getResourceAsStream (ClassLoader/getSystemClassLoader) f)
                rdr (BufferedReader. (InputStreamReader. in))]
      (apply str (interpose \newline (line-seq rdr)))))

  (defn indexed
    "Returns a lazy sequence of [index, item] pairs, where items come
    from 's' and indexes count up from zero.

    (indexed '(a b c d))  =>  ([0 a] [1 b] [2 c] [3 d])"
    [s]
    (map vector (iterate inc 0) s))

  <<code-templates>>
#+end_src 
** src/string_template.clj
#+begin_src clojure :noweb yes :mkdirp yes :tangle ferret/src/ferret/string_template.clj
  (ns ferret.string-template
    (:import org.antlr.stringtemplate.StringTemplateGroup)
    (:import org.antlr.stringtemplate.StringTemplate)
    (:use ferret.string-template-internal))


  (defn create-view "Return new view template - useful as mentioned here:
    http://hardlikesoftware.com/weblog/2006/12/12/using-json-with-stringtemplate/"
    ([]
      (StringTemplate.))
    ([^String template]
      (StringTemplate. template)))


  (defn get-view-from-classpath "Return the view template from classpath"
    [^String view-name]
    (let [st-group (StringTemplateGroup. "default")]
      (.getInstanceOf st-group view-name)))


  (defn get-view-from-dir "Return the view template from specified directory"
    [^String view-name ^String root-dir]
    (let [st-group (StringTemplateGroup. "default" root-dir)]
      (.getInstanceOf st-group view-name)))


  (defn reset-view! "Reset view template with supplied content"
    [^StringTemplate view ^String template]
    (.setTemplate view template))


  (defn fill-view! "Fill view template with key/value pairs"
    ;;;
    ;; Fill template with key and value
    ([^StringTemplate template k v]
      (.setAttribute template (stringify k) (each-kv-to-sv v))
      template)
    ;;;
    ;; Fill template with key/value from map
    ([^StringTemplate template kv-map]
      (.setAttributes template (kv-to-sv kv-map))
      template))


  (defn render-view "Return rendered view for the template"
    [^StringTemplate template]
    (.toString template))
#+end_src

#+begin_src clojure :noweb yes :mkdirp yes :tangle ferret/src/ferret/string_template_internal.clj
  (ns ferret.string-template-internal)


  (defn stringify [any]
    (if (keyword? any)
      (name any)
      (str any)))


  (declare kv-to-sv)
  (declare scan-kv-to-sv)


  (defn each-kv-to-sv "If element is a collection type, do deep transformation"
    [each]
    (if (map? each)
      (kv-to-sv each)
      (if (or (vector? each) (list? each) (seq? each) (set? each))
        (scan-kv-to-sv each)
        each)))


  (defn scan-kv-to-sv
    "Scans a collection and turns any contained map within from kv to sv"
    [coll]
    (map each-kv-to-sv coll))


  (defn kv-to-sv
    "Transforms keyword-value map {:a 10 :b 20 :c 30}
     to string-value map {\"a\" 10 \"b\" 20 \"c\" 30}"
    [mp]
    (let [m (into {} mp)
          k (keys m)
          v (vals m)]
      (zipmap
        (map stringify k)
        (scan-kv-to-sv v))))

#+end_src

** test/core.clj
#+begin_src clojure :noweb yes :mkdirp yes :tangle ferret/test/ferret/test/core.clj
    (ns ferret.test.core
      (:use [ferret.core] :reload)
      (:use [clojure.test]
            [clojure.java.shell]))

  (defn capture-output [form]
    (let [options (compile-options)]
      (compile->cpp form options)
      (compile->binary options [])
      (with-sh-dir "./"
        (let [r (sh "./a.out")]
          (:out r)))))

    <<compiler-transformation-tests>>
    <<compiler-import-module-test>>
    <<runtime-clojure-bit-operations-tests>>
    <<runtime-clojure-bit-arithmetic-tests>>
    <<runtime-clojure-logical-operators-tests>>
    <<runtime-clojure-conditionals-tests>>
    <<runtime-clojure-sequences-tests>>
    <<native-string-tests>>
    <<native-keyword-tests>>
#+end_src 

** resources/Object.cpp

#+begin_src c++ :mkdirp yes :noweb yes :tangle ferret/resources/Object.cpp
  <<runtime-native-program-header>>

  <<runtime-native-object-casting-macros>>

  <<runtime-native-lambda-invoke-macros>>

  <<runtime-native-iseekable-macros>>

  <<runtime-native-math-config>>

  namespace ferret{
    class var;
    <<runtime-native-object>>
    <<runtime-native-var>>
  }
#+end_src 

** resources/runtime.clj

#+begin_src clojure :mkdirp yes :noweb yes :tangle ferret/resources/runtime.clj
  <<runtime-clojure-pointer-object>>
  <<runtime-clojure-boolean-object>>
  <<runtime-clojure-number-object>>
  <<runtime-clojure-seekable-interface>>
  <<runtime-clojure-lambda-interface>>
  <<runtime-clojure-keyword-object>>
  <<runtime-clojure-cell-object>>
  <<runtime-clojure-sequence-object>>
  <<runtime-clojure-character-object>>
  <<runtime-clojure-string-object>>
  <<runtime-clojure-defn>>
  <<runtime-clojure-looping>>
  <<runtime-clojure-first>>
  <<runtime-clojure-sequence>>
  <<runtime-clojure-logical-operators>>
  <<runtime-clojure-conditionals>>
  <<runtime-clojure-math>>
  <<runtime-clojure-bit-operations>>
  <<runtime-clojure-console-io>>
  <<runtime-clojure-misc>>
  <<runtime-clojure-arduino>>
#+end_src
