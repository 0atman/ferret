#+title: Ferret: An Experimental Clojure Compiler
#+tags: clojure c++ arduino avr-gcc gcc
#+STARTUP: hidestars
#+TAGS: noexport(e)
#+EXPORT_EXCLUDE_TAGS: noexport

Ferret is an experimental Lisp to C++ compiler, the idea was to
compile code that is written in a very small subset of Clojure to be
automatically translated to C++ so that I can program stuff in
Clojure where JVM or any other Lisp dialect is not available.

This is a literate program, the code in this document is the
executable source, in order to extract it, open this [[https://github.com/nakkaya/nakkaya.com/tree/master/resources/posts/2011-06-29-ferret-an-experimental-clojure-compiler.org][raw file]]
with emacs and run,

#+begin_example
 M-x org-babel-tangle
#+end_example

It will build the necessary directory structure and export the files
and tests contained.

* Compiler

Compiler has two major parts, transformation and code
generation. During transformation we make passes over the code, with
each pass code becomes more and more like C++ basically after the final
pass it is C++ written with s-expressions. Then during code generation
we iterate over the code and spit valid C++.

** Transformation

Forms go through eight transformations before they are passed to the
code generation phase.

#+name: core-transformation-process
#+begin_src clojure :tangle no
  (defn process [form]
    (->> (add-built-in form)
         (expand-macros-all)
         (vector->list)
         (let->fn)
         (do->fn)
         (closure-conversion)
         (symbol-conversion)
         (replace-fn-call-sites)))
#+end_src

*** Add Runtime

In order to keep the generated C++ code compact only the functions used
will be present in the generated source file. Which means if you don't
use /println/ anywhere in the code it won't be defined in the final
C++ file, but if you use it, it and everything it uses will be
defined, in the case of /println/ it will pull /apply/, /print/ and
/newline/ with it.

#+name: core-transformation-add-built-in
#+begin_src clojure :tangle no
  (defn add-built-in
    ([form]
     (let [runtime-form (read-string (str \( (read-from-url "runtime.clj") \)))
           built-in-defn (expand-macros-all runtime-form)
           built-in-order (map second built-in-defn)
           built-in (->> built-in-defn
                         (reduce (fn[h v] (assoc h (second v) v)) {}))
           fns (atom {})
           _ (add-built-in (->> form expand-macros-all vector->list) built-in fns)
           sorted-fns (->> @fns
                           (sort-by #(.indexOf built-in-order (key %)))
                           (map #(second %)))]
       (concat sorted-fns form)))
    ([form built-in fns]
     (morph-form form symbol?
                 #(do (if-let [f (built-in %)]
                        (when (not (@fns %))
                          (swap! fns assoc % f)
                          (add-built-in f built-in fns))) %))))
#+end_src

*** Expand Macros

First we read all the macros present in /runtime.clj/ then add to that
user defined macros, they are evaluated in a temporary namespace,
using /morph-form/ we iterate all the macros used in the code that we
are compiling and expand them in the temporary namespace then the node
is replaced with its expanded form.

#+name: core-transformation-expand-macros
#+begin_src clojure :tangle no
  (defn expand-macros [form]
    (let [macros (->> (read-string (str \( (read-from-url "runtime.clj") \)))
                      ;;get built in macros
                      (filter (is-form? 'defmacro))
                      ;;merge user defined macros
                      (concat (filter (is-form? 'defmacro) form)))
          form (remove-form form (is-form? 'defmacro))
          temp-ns (gensym)]
      
      (create-ns temp-ns)
      (binding [*ns* (the-ns temp-ns)]
        (refer 'clojure.core :exclude (concat (map second macros) ['fn 'let 'def]))
        (doseq [m macros]
          (eval m)))

      (let [form (morph-form form
                             (apply is-form? (map second macros))
                             (fn [f]
                               (binding [*ns* (the-ns temp-ns)]
                                 (macroexpand-all f))))]
        (remove-ns temp-ns)
        form)))

  (defn expand-macros-all [form]
    (loop [f form]
      (let [expanded (expand-macros f)]
        (if (= f expanded)
          expanded
          (recur expanded)))))
#+end_src

*** vector->list

Since there is no support for vectors, they are converted to
lists. Also zippers do not iterate over vectors.

#+name: core-transformation-vector-list
#+begin_src clojure :tangle no
  (defn vector->list [form]
    (morph-form form vector? #(reverse (into '() %))))
#+end_src

*** let->fn

let forms are transformed into nested functions which are then called
immediately, bindings are setup in the outer function, expressions are
placed in the inner function which takes the bindings as arguments.

So following form,

#+begin_src clojure :tangle no
  (let->fn '(let [a 1
                  b 2]
              (+ a b)))
#+end_src

after transformation becomes,

#+begin_src clojure :tangle no
  ((fn []
     (define-var a 1)
     (define-var b 2)
  
     ((fn (a b)
        (+ a b)) a b)))
#+end_src

#+name: core-transformation-let-fn
#+begin_src clojure :tangle no
  (defn let->fn [form]
    (morph-form form
                (is-form? 'let)
                (fn [[_ bindings & body]]
                  (let [bindings (partition 2 bindings)
                        vars (flatten (map first bindings))
                        defs (map #(cons 'define-var %) bindings)
                        body-fn (cons (concat ['fn vars] body) vars)]
                    (list (concat ['fn []] defs [body-fn]))))))
#+end_src

*** do->fn

A similar method is used for the do form, expressions are wrapped in a fn
that takes no parameters and executed in place.

#+begin_src clojure :tangle no
  (do->fn '(do (+ 1 1)))
#+end_src

#+begin_src clojure :tangle no
  ((fn [] (+ 1 1)))
#+end_src

#+name: core-transformation-do-fn
#+begin_src clojure :tangle no
  (defn do->fn [form]
    (morph-form form
                (is-form? 'do)
                #(list (concat ['fn []] (rest %)))))
#+end_src

*** Closure Conversion

/closure-conversion/ handles the problem of free variables, 

#+begin_src clojure :tangle no
  (defn make-adder [x]
    (fn [n] (+ x n)))
#+end_src

in the above snippet x is a free variable, the function /make-adder/
returns, has to have a way of referencing that variable when it is
used. The way we do this is that, every function will pass its arguments to
inner functions (if any) it contains.

#+begin_src clojure :tangle no
  (closure-conversion '(fn [x]
                          (fn [n] (+ x n))))
#+end_src

Above form will be converted to,

#+begin_src clojure :tangle no
  (define-lambda G__265 (x) (n) (+ x n))
  (define-lambda G__266 () (x) (lambda-object G__265 x))
#+end_src

What this means is, define a functor named /G__265/ that holds a
reference to /x/, and another functor /G__266/ that has no state. When
we create an instance of /G__265/ we pass /x/ to its
constructor. Since every thing is already converted to fns this
mechanism allows variables to be referenced down the line and solves
the free variable problem.

#+name: core-transformation-closure-conversion 
#+begin_src clojure :tangle no
  (defn lambda-defined? [fns env args body]
    (let [f (concat [env args] body)
          name (reduce (fn[h v]
                         (let [[_ n & r] v]
                           (if (= r f) n))) nil @fns)]
      (when name
        (apply list 'lambda-object name env))))
  
  (defn define-lambda [fns env args body]
    (let [n (gensym)]
      (dosync (alter fns conj (concat ['define-lambda n env args] body)))
      (apply list 'lambda-object n env)))
  
  (defn closure-conversion
    ([form]
       (let [fns (ref [])
             form (closure-conversion form fns)]
         (vector->list (concat @fns form))))
    ([form fns & env]
       (morph-form form
                   (is-form? 'fn)
                   (fn [[_ args & body]]
                     (let [env (if (nil? env) '() (first env))
                           body (closure-conversion body fns (concat args env))]
                       (if-let [n (lambda-defined? fns env args body)]
                         n
                         (define-lambda fns env args body)))))))
#+end_src

*** Symbol Conversion

Next step converts all symbols that are not legal C++ identifiers
into valid ones.

#+name: core-transformation-symbol-conversion
#+begin_src clojure :tangle no
  (defn symbol-conversion [form]
    (let [c (comp #(symbol (clojure.string/escape
                            (str %)
                            {\- \_ \* "_star_" \+ "_plus_" \/ "_slash_"
                             \< "_lt_" \> "_gt_" \= "_eq_" \? "_QMARK_"}))
                  #(cond (= 'not %) '_not_
                         :default %))]
      (morph-form form symbol? c)))

#+end_src

*** Replace Fn Call Sites

Final step replaces all functions calls with new function
objects /define_lambda/ are renamed to /fn/. This removes all globals
variables unless the /fn/ defined is a closure. In which case it is
left as a global variable and the class implementation is prepended
with the global name for readability.

#+BEGIN_EXAMPLE
  (process '((let [a 1]
               (defn adder [x]
                 (+ a x)))
             (defn my-inc [x] (+ 1 x))))

  (replace-fn-call-sites
   '((define_lambda G__3885 (a) (x) (_plus_ a x))
     (define_lambda G__3886 () (a) (def adder (lambda_object G__3885 a)))
     (define_lambda G__3887 () () (define_var a 1) ((lambda_object G__3886) a))
     (define_lambda G__3888 () (x) (_plus_ 1 x))
     ((lambda_object G__3887))
     (def my_inc (lambda_object G__3888))))

  ((define_lambda adder_G__3885 (a) (x) (_plus_ a x))
   (define_lambda G__3886 () (a) (def adder (lambda_object adder_G__3885 a)))
   (define_lambda G__3887 () () (define_var a 1) ((lambda_object G__3886) a))
   (define_lambda my_inc () (x) (_plus_ 1 x))
   ((lambda_object G__3887)))
#+END_EXAMPLE

#+name: core-transformation-symbol-conversion
#+begin_src clojure :tangle no
  (defn select-def-fn [form]
    (->> (select-form form (is-form? 'def))
         (filter (fn [[_ name val]]
                   (and (seq? val)
                        (= 'lambda_object (first val)))))))

  (defn replace-fn-call-sites-pure [form fn-defs fn-table]
    (let [no-global-fn (reduce (fn[h v]
                                 (remove-form h (fn [f]
                                                  (and (seq? f)
                                                       (= 'def (first f))
                                                       (every? true? (map = f v))))))
                               form fn-defs)        
          embeded-fn-calls (reduce (fn[h [name gensym]]
                                     (morph-form h symbol?
                                                 (fn [f]
                                                   (if (= f name)
                                                     (list 'lambda_object gensym)
                                                     f))))
                                   no-global-fn fn-table)
          embed-fn-names (reduce (fn[h [name gensym]]
                                   (morph-form h symbol?
                                               (fn [f]
                                                 (if (= f gensym)
                                                   name
                                                   f))))
                                 embeded-fn-calls fn-table)]
      embed-fn-names))

  (defn replace-fn-call-sites [form]
    (let [pure-fn-defs (->> (select-def-fn form)
                            (filter #(= 2 (-> % last count))))
          pure-fn-table (map (fn [[_ name [_ gensym]]] [name gensym]) pure-fn-defs)
          form (replace-fn-call-sites-pure form pure-fn-defs pure-fn-table)
          closure-fn-defs (->> (select-def-fn form)
                               (filter #(not= 2 (-> % last count))))
          closure-fn-table (map (fn [[_ name [_ gensym]]] [name gensym]) closure-fn-defs)]
      (reduce (fn[h [name gensym]]
                (morph-form h symbol?
                            (fn [f]
                              (if (= f gensym)
                                (symbol (str name "_" gensym))
                                f))))
              form closure-fn-table)))
#+end_src

*** Helpers

During each pass we iterate over the nodes in the form using
/morph-form/ and /remove-form/, they both take a s-expression and a
predicate if the predicate returns true, morph-form will call /f/
passing the current node as an argument and replace that node with
/f/'s return value, remove-form on the other hand does what its name
suggests and removes the node when predicate returns true.

#+name: core-transformation-form-fns
#+begin_src clojure :tangle no
  (defn morph-form [tree pred f]
    (loop [loc (zip/seq-zip tree)]
      (if (zip/end? loc)
        (zip/root loc)
        (recur
         (zip/next
          (if (pred (zip/node loc))
            (zip/replace loc (f (zip/node loc)))
            loc))))))

  (defn remove-form [tree pred]
    (loop [loc (zip/seq-zip tree)]
      (if (zip/end? loc)
        (zip/root loc)
        (recur
         (zip/next
          (if (pred (zip/node loc))
            (zip/remove loc)
            loc))))))

  (defn select-form [tree pred]
    (loop [loc (zip/seq-zip tree)
           nodes []]
      (if (zip/end? loc)
        nodes
        (recur
         (zip/next loc)
         (if (pred (zip/node loc))
           (conj nodes (zip/node loc))
           nodes)))))

  (defn is-form? [& s]
    (fn [f]
      (and (seq? f)
           (some true? (map #(= % (first f)) s)))))
#+end_src

*** Tests

#+name: compiler-transformation-tests
#+begin_src clojure :tangle no
  (deftest transformation-test
    (is (seq? (vector->list [1 2 [2 [5 4] 3]])))
    (is (= (symbol-conversion '(make-adder 2)) '(make_adder 2)))
    (is (= (symbol-conversion '(make-adder* 2)) '(make_adder_star_ 2)))

    (let [form (closure-conversion '((def make-adder (fn [n] (fn [x] (+ x n))))))]
      (is (= (ffirst form) 'define-lambda))
      (is (= (last (first form)) '(+ x n)))
      (is (= (second (last form)) 'make-adder))
      (is (= (first (last form)) 'def))))

  (deftest transformation-macro-test
    (is (= "1 1 1 true false true true true 0 1 2 3 4 3 "
           (capture-output '((defmacro my-when [test & body]
                               (list 'if test (cons 'do body)))
                             
                             (print (my-when (< 2 3) 1)

                                    (when (< 2 3) 1)

                                    (when (< 2 3) 1)
                                    
                                    (let [a 1]
                                      (and (> a 0)
                                           (< a 10)))

                                    (let [a 11]
                                      (and (> a 0)
                                           (< a 10)))
                                    
                                    (and true true)

                                    (or true false)

                                    (let [a 11]
                                      (or (> a 0)
                                          (< a 10))))
                             
                             (dotimes [i 5] (print i))
                             (let [a 1]
                               (defn adder [x]
                                 (+ a x)))
                             (defn my-inc [x] (+ 1 (adder x)))
                             (print (my-inc 1)))))))

  (deftest transformation-special-forms-test
    (is (= "10 89 11 3 1 5 5 1 1 1 1 1 1 1 1 1 1 "
           (capture-output '((def make-adder
                               (fn [n] (fn [x] (+ x n))))
                             (def adder
                               (make-adder 1))

                             (def fibo (fn [n]
                                         (if (< n 2)
                                           1
                                           (+ (fibo (- n 1))
                                              (fibo (- n 2))))))

                             (def adder-let (let [a 1
                                                  b 2]
                                              (fn [n] (+ a b n))))

                             (def adder-let-2 (fn [n]
                                                (let [a 1
                                                      b 2]
                                                  (+ a b n))))

                             (native-declare "int i = 0;")
                             (defn inc-int [] "return i++;")
                             
                             (print (adder 9)

                                    (fibo 10)

                                    ((fn [n] (+ n 1)) 10)

                                    (((fn [n] (fn [n] n)) 3) 3)

                                    (if (< 2 3 4 5 6)
                                      (do 1)
                                      (do 2))

                                    (adder-let 2)

                                    (adder-let-2 2))
                             
                             (while (< (inc-int) 10)
                               (print 1)))))))
#+end_src

** Code Generation

At this point all we need is a multi method that will emit correct
string based on the form.

#+name: core-code-generation-emit
#+begin_src clojure :tangle no  
  (defmulti emit (fn [form _]
                   (cond (is-special-form? 'define_lambda form) 'define_lambda
                         (is-special-form? 'lambda_object form) 'lambda_object
                         (is-special-form? 'define_var form) 'define_var
                         (is-special-form? 'native_declare form) 'native_declare
                         (is-special-form? 'if form) 'if
                         (is-special-form? 'def form) 'def
                         (is-special-form? 'reduce form) 'reduce
                         (to-str? form) :to-str
                         (keyword? form) :keyword
                         (number? form) :number
                         (nil? form) :nil
                         (char? form) :char
                         (string? form) :string
                         (seq? form) :sequence)))
#+end_src

Without preprocessing following forms,

#+begin_src clojure :tangle no
  (emit '(list 1 2 3) (ref {}))
  
  (emit '(+ 1 2) (ref {}))
  
  (emit '(if (< a b)
           b a)
        (ref {}))
#+end_src

would evaluate to,

#+begin_example
  "INVOKE(VAR(list), VAR(3),VAR(2),VAR(1))"
  "INVOKE(VAR(+), VAR(2),VAR(1))"
  "(BOOLEAN(INVOKE(VAR(<), VAR(b),VAR(a)))->asBool() ? (VAR)VAR(b) : (VAR)VAR(a))"  
#+end_example

So the actual compilation will just map emit to all forms passed and
/string-template/ will handle the job of putting them into an empty
C++ skeleton.

#+name: core-code-generation-emit-source
#+begin_src clojure :tangle no
  (defn emit-source [form]
    (let [state (ref {:lambdas [] :symbol-table #{} :native-declarations []})
          body (doall (map #(emit % state) (process form)))]
      (assoc @state :body body)))
#+end_src

*** Code Emitting

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit :to-str [form state] (str "VAR("form ")"))

  (defmethod emit :char [form state] (str "VAR('" form "')"))

  (defmethod emit :string [form state] (str "VAR(\"" form "\")"))

  (defmethod emit :nil [form state] "VAR()")

  (defmethod emit :keyword [form state]
    (str "VAR(new ferret::Keyword(" (reduce (fn[h v] (+ h (int v))) 0 (str form))"))"))

  (defmethod emit :number [form state]
    (str "VAR("form (if (float? form) "f") ")"))

  (defmethod emit :sequence [[fn & args] state]
    (invoke-lambda (emit fn state) (doall (map #(emit % state) args))))

  (defmethod emit 'define_var [[_ name form] state]
    (str "VAR " name " = " (emit form state)))

  (defmethod emit 'native_declare [[_ declaration] state]
    (append-to! state [:native-declarations] declaration) "")

  (defmethod emit 'lambda_object [[_ name & env] state]
    (new-lambda name (filter #(not (= '& %)) env)))

  (defmethod emit 'define_lambda [[_ name env args & body] state]
    (let [body (if (string? (first body))
                 ["VAR __result" body "__result"]
                 (doall (map #(emit % state) body)))
          env (filter #(not (= '& %)) env)
          reg-args (take-while #(not (= '& %)) args)
          va-args (if (some #{'&} args)
                    (let [arg (last args)]
                      (str "VAR " arg " = "
                           (reduce (fn[h v]
                                     (str "SEQUENCE(" h ")->rest()"))
                                   "_args_" (range (count reg-args))) ";\n")))]
      (append-to! state [:lambdas] {:name name :env env :args reg-args :var_args va-args :body body}) ""))

  (defmethod emit 'if [[_ cond t f] state]
    (let [cond (emit cond state)
          t (emit t state)
          f (if (nil? f) "VAR()" (emit f state))]
      (if-statement cond t f)))

  (defmethod emit 'reduce [[_ & args] state]
    (if (= 2 (count args))
      (let [[f s] args]
        (str "(ISEEKABLE(" (emit s state) ")->reduce(" (emit f state) "))"))
      (let [[f v s] args]
        (str "(ISEEKABLE(" (emit s state) ")->reduce(" (emit f state) " , " (emit v state) "))"))))

  (defmethod emit 'def [[_ name & form] state]
    (append-to! state [:symbol-table] name)
    (str name " = " (apply str (doall (map #(emit % state) form)))))
#+end_src

*** Code Templates

#+name: code-templates
#+begin_src clojure :tangle no
  (defn new-lambda [n e]
    (let [view (create-view "(FN($name$$env:{,$it$}$))")]
      (fill-view! view "name" n)
      (fill-view! view "env" e)
      (render-view view)))

  (defn invoke-lambda [n args]
    (let [view (create-view "INVOKE($lambda$, $args:{$it$} ;separator=\",\"$)")]
      (fill-view! view "lambda" n)
      (fill-view! view "args" (reverse args))
      (render-view view)))

  (defn if-statement [cond t f]
    (apply str "(BOOLEAN(" cond ")->asBool() ? (VAR)" t " : (VAR)" f ")"))

  (defn declare-lambdas [lambdas]
    (let [view (create-view
                
    "$lambdas: {lambda|
        class $lambda.name$ : public Lambda{

        $lambda.env:{VAR $it$;} ;separator=\"\n\"$

        public:

          $lambda.name$ ($lambda.env:{VAR $it$} ;separator=\",\"$){ 
             $lambda.env:{this->$it$ = $it$;} ;separator=\"\n\"$
          }

          VAR invoke (VAR _args_){
            $lambda.args:{args | VAR $last(args)$ = SEQUENCE(_args_)->nth($first(args)$); } ;separator=\"\n\"$

            $lambda.var_args$

            $trunc(lambda.body):{$it$;} ;separator=\"\n\"$
            return $last(lambda.body):{ $it$;} ;separator=\"\n\"$
          }
        };};separator=\"\n\n\"$")]
      (fill-view! view "lambdas" (map #(let [args (:args %)]
                                         (assoc % :args (indexed args))) lambdas))
      (render-view view)))

  (defn solution-template [source]
    (let [{:keys [body lambdas symbol-table native-declarations]} source
          view (create-view "
      #include \"ferret.h\"
      
      $native_declarations:{$it$} ;separator=\"\n\"$
      
      $symbols:{VAR $it$;} ;separator=\"\n\"$
      
      namespace ferret{
        $lambdas:{$it$} ;separator=\"\n\"$
      }
      
      int main(void){
        INIT_ENV
        $body:{$it$;} ;separator=\"\n\"$
        return 0;
      }")]
      (fill-view! view "body" (filter #(not (empty? %)) body))
      (fill-view! view "lambdas" (declare-lambdas lambdas))
      (fill-view! view "symbols" symbol-table)
      (fill-view! view "native_declarations" native-declarations)
      (render-view view)))
#+end_src    

* Runtime
** Native

On the C++ side we define our own object system, which includes the
following types,

#+name: runtime-native-object-types-enum
#+begin_src c++ :tangle no
  enum TYPE {POINTER_TYPE,
             NUMBER_TYPE,
             CHARACTER_TYPE,
             BOOLEAN_TYPE,
             KEYWORD_TYPE,
             CONS_TYPE,
             LIST_TYPE,
             STRING_TYPE,
             LAMBDA_TYPE};
#+end_src

Object Casting macros,

#+name: runtime-native-object-casting-macros
#+begin_src c++ :tangle no
  #define OBJECT(v) static_cast<ferret::Object*>(v.get())
  #define POINTER(v) static_cast<ferret::Pointer*>(v.get())
  #define NUMBER(v) static_cast<ferret::Number*>(v.get())
  #define CHARACTER(v) static_cast<ferret::Character*>(v.get())
  #define BOOLEAN(v) static_cast<ferret::Boolean*>(v.get())
  #define KEYWORD(v) static_cast<ferret::Keyword*>(v.get())
  #define ISEEKABLE(v) static_cast<ferret::ISeekable*>(v.get())
  #define CELL(v) static_cast<ferret::Cell*>(v.get())
  #define SEQUENCE(v) static_cast<ferret::Sequence*>(v.get())
  #define STRING(v) static_cast<ferret::String*>(v.get())
  #define LAMBDA(v) static_cast<ferret::Lambda*>(v.get())
#+end_src

*** Object

#+name: runtime-native-object
#+begin_src c++ :tangle no
class Object{
    public:
      Object() : refCount(0) {}
      virtual ~Object() {};
  
      virtual int getType() = 0;
      virtual var toOutputStream() = 0;
      virtual var equals(var o) = 0;
  
      void addRef() { refCount++; }
      bool subRef() { return (--refCount <= 0); }
  
  
      void* operator new(size_t size){ 
        return malloc(size); 
      } 
  
      void  operator delete(void * ptr){ 
        free(ptr); 
      }
  
      void* operator new[](size_t size){ 
        return malloc(size); 
      }
  
      void  operator delete[](void * ptr){ 
        free(ptr); 
      }
  
    private:
      int refCount;
    };
#+end_src

All our types are derived from the base Object type,(defining
new/delete is needed because in avr-gcc they are not defined.)

*** Pointer

#+name: runtime-native-pointer
#+begin_src c++ :tangle no
  class Pointer : public Object { 
  public:
    void* ptr;
    Pointer(void* p){ptr = p;}

    int getType(){ return POINTER_TYPE;}
    var equals(var o){ return ptr = POINTER(o)->ptr; }

    var toOutputStream(){ 
      fprintf(OUTPUT_STREAM, "Pointer");
      return var();
    }
  };
#+end_src

*** Number

Math configuration,

#+name: runtime-native-math-config
#+begin_src c++ :tangle no
  #define NUMBER_PRECISION 1000 //used when reading floats.
  //#define NUMBER_DATA_TYPE long
  //#define NUMBER_DATA_TYPE_FORMAT "%ld"
  #define NUMBER_DATA_TYPE int
  #define NUMBER_TYPE_FORMAT "%d"
#+end_src

#+name: runtime-native-number
#+begin_src c++ :tangle no
  class Number : public Object{
  public:
  #if NUMBER_DATA_TYPE != int
    Number(int x);
  #endif
    Number(NUMBER_DATA_TYPE x);
    Number(NUMBER_DATA_TYPE n, NUMBER_DATA_TYPE dn);
    Number(float x);
    ~Number(){};
    int getType(){ return NUMBER_TYPE;}
    NUMBER_DATA_TYPE getNumerator(){ return numerator;}
    NUMBER_DATA_TYPE getDenominator(){ return denominator;}

    float floatValue(){return (float)numerator/(float)denominator;}
    int intValue(){
      if (denominator == 1)
        return (int)numerator;
      else
        return (int)floatValue();
    }
      
    var equals(var o){
      int self_type = getType();
      int other_type = OBJECT(o)->getType();
      
      if (self_type == NUMBER_TYPE && other_type == NUMBER_TYPE)
        if (getNumerator() == 0 && NUMBER(o)->getNumerator() == 0)
          return true;
        else
          return ((getNumerator() == NUMBER(o)->getNumerator()) &&
                  (getDenominator() == NUMBER(o)->getDenominator()));
      else
        return false;
    }
    
    var toOutputStream(){
      if (denominator == 1)
        fprintf(OUTPUT_STREAM, NUMBER_TYPE_FORMAT, numerator);
      else if (numerator == 0)
        fprintf(OUTPUT_STREAM, "0");
      else{
        fprintf(OUTPUT_STREAM, NUMBER_TYPE_FORMAT,numerator);
        fprintf(OUTPUT_STREAM, "/");
        fprintf(OUTPUT_STREAM, NUMBER_TYPE_FORMAT,denominator);
      }

      return var();
    };
    
  private:

    void simplificate(){
      int commondivisor = 1;
      for(NUMBER_DATA_TYPE i=2;i<=MIN(ABS(numerator), ABS(denominator));i++)
        if( numerator%i == 0 && denominator%i == 0 )
          commondivisor = i;
      numerator /= commondivisor;
      denominator /= commondivisor;
    }

    NUMBER_DATA_TYPE numerator;
    NUMBER_DATA_TYPE denominator;
  };
#+end_src

#+name: runtime-native-number
#+begin_src c++ :tangle no
  #if NUMBER_DATA_TYPE != int
  inline Number::Number(int x){
    numerator = x;
    denominator = 1;
  }
  #endif

  inline Number::Number(NUMBER_DATA_TYPE x){
    numerator = x;
    denominator = 1;
  }

  inline Number::Number(NUMBER_DATA_TYPE n, NUMBER_DATA_TYPE dn){
    numerator = n;
    denominator = dn;
    simplificate();
  }

  inline Number::Number(float x){
    float decimal = (x - (NUMBER_DATA_TYPE)x) * (float)NUMBER_PRECISION;
    NUMBER_DATA_TYPE integer = (NUMBER_DATA_TYPE)x;
    
    numerator = decimal + (integer * NUMBER_PRECISION);
    denominator = NUMBER_PRECISION;
    simplificate();
  }
#+end_src

*** Keyword

#+name: runtime-native-keyword
#+begin_src c++ :tangle no
  class Keyword : public Object { 
  public:
    int id;

    Keyword(int b){id = b;}
    Keyword(const char * str){
      id = 0;
      for (int i = 0; str[i] != '\0'; i++){
        id = id + (int)str[i];
      }
    }
    
    int getType(){ return KEYWORD_TYPE;}

    var equals(var o){
      if (OBJECT(o)->getType() != KEYWORD_TYPE)
        return false;
      
      return (id == KEYWORD(o)->id);
    }

    bool equals(Keyword k){
      return (id == k.id);
    }
    
    var toOutputStream(){ fprintf(OUTPUT_STREAM, "%d", id); return var();};
  };
#+end_src

**** Tests

#+name: native-keyword-tests
#+begin_src clojure :tangle no
  (deftest native-keyword-test
    (is (= "true false true "
           (capture-output '((print (= :test :test)
                                    (= :test :other_test)
                                    ((fn [keyword]
                                       "__result = VAR((KEYWORD(keyword)->equals(Keyword(\":space\"))))")
                                     :space)))))))
#+end_src

*** Character

#+name: runtime-native-character
#+begin_src c++ :tangle no
  class Character : public Object { 
  public:
    char value;
    Character(char c){value = c;}
    int getType(){ return CHARACTER_TYPE;}

    var equals(var o){
      if (OBJECT(o)->getType() != CHARACTER_TYPE)
        return false;
      
      return (value == CHARACTER(o)->value);
    }

    var toOutputStream(){ 
      fprintf(OUTPUT_STREAM, "%c",value);
      return var();
    }
  };

#+end_src

*** Seekable Interface

#+name: native-seekable-interface
#+begin_src c++ :tangle no
  class ISeekable : public Object{
  public:
    virtual ~ISeekable() {}
    virtual void cons(var x) = 0;
    virtual var first() = 0;
    virtual var rest() = 0;
    virtual var nth(var i) = 0;
    virtual bool isEmpty() = 0;
    virtual var reduce(var f) = 0;
    virtual var reduce(var f, var acc) = 0;
  };
#+end_src

*** Sequence

#+name: runtime-native-sequence
#+begin_src c++ :tangle no
  class Cell : public Object{
  public:
    var data;
    var next;

    var equals(var o){
      if (OBJECT(o)->getType() != CONS_TYPE)
        return false;
      
      return OBJECT(data)->equals(o);
    }

    int getType(){ return CONS_TYPE;}
    var toOutputStream(){ OBJECT(data)->toOutputStream(); return var();};
  };

  class Sequence : public ISeekable{
    var head;
  public:
    Sequence(){
      head = NULL;
    }

    Sequence(var h){
      head = h;
    }

    void cons(var x){
      var v = var(new Cell());
      CELL(v)->data = x;
      CELL(v)->next = head;
      head = v;
    }

    var first(){
      if (head.get() == NULL )
        return var();
      else
        return CELL(head)->data;
    }

    var rest(){
      if ( head.get() == NULL || CELL(head)->next.get() == NULL )
        return var(new Sequence());
      else
        return var(new Sequence(CELL(head)->next));
    }

    var nth(var i){
      var it = head;
      int index = NUMBER(i)->intValue();

      for(int i = 0 ; i < index; i++){
        if ((CELL(it)->next).get() == NULL )
          return VAR();

        it = CELL(it)->next;
      }

      return CELL(it)->data;
    }

    bool isEmpty(){
      if (head.get() == NULL)
        return true;

      return false;
    }

    var toOutputStream(){
      fprintf(OUTPUT_STREAM, "( ");

      for(var it = head; it.get() != NULL ; it = CELL(it)->next){
        OBJECT(CELL(it)->data)->toOutputStream();
        fprintf(OUTPUT_STREAM, " ");
      }

      fprintf(OUTPUT_STREAM, ")");
      return var();
    }

    var equals(var o){

      if (OBJECT(o)->getType() != LIST_TYPE)
        return false;

      var itOther = o;
      for(var it = this; !SEQUENCE(it)->isEmpty(); it = SEQUENCE(it)->rest()){
        if (SEQUENCE(itOther)->isEmpty() || 
            BOOLEAN(OBJECT(SEQUENCE(it)->first())->equals(SEQUENCE(itOther)->first()))->asBool() == false)
          return false;

        itOther = SEQUENCE(itOther)->rest();
      }

      return true;
    }

    var clone() { return var(new Sequence(head));}
    int getType(){ return LIST_TYPE;}

    var reduce(var f){
      var acc = INVOKE(f,CELL(head)->data,CELL(CELL(head)->next)->data);

      for(var it = CELL(CELL(head)->next)->next; it.get() != NULL ; it = CELL(it)->next)
        acc = INVOKE(f, CELL(it)->data, acc);

      return acc;
    }

    var reduce(var f, var acc){
      for(var it = head; it.get() != NULL ; it = CELL(it)->next)
        acc = INVOKE(f, CELL(it)->data, acc);

      return acc;
    }
  };
#+end_src
*** String

#+name: runtime-native-string
#+begin_src c++ :tangle no
  class String : public ISeekable{
    var data;
  public:
    String(){
      data = NULL;
    }

    String(var s){
      data = s;
    }

    String(const char * str){
      int length = 0;
      for (length = 0; str[length] != '\0'; length++);
      length--;
      var s = var(new Sequence());
        
      for (int i = length; i >= 0; i--){
        var ch = VAR(str[i]);
        s = (SEQUENCE(s)->clone(),ch);
      }
      data = s;
    }

    var clone() {return var(new String(data));}
    int getType(){return STRING_TYPE;}

    void cons(var x){
      ISEEKABLE(data)->cons(x);
    }

    var first(){
      return ISEEKABLE(data)->first();
    }

    var rest(){
      return ISEEKABLE(data)->rest();
    }

    var nth(var i){
      return ISEEKABLE(data)->nth(i);
    }

    bool isEmpty(){
      return ISEEKABLE(data)->isEmpty();
    }

    var toOutputStream(){
      for(var it = data; ISEEKABLE(it)->isEmpty() == false ; it = ISEEKABLE(it)->rest()){
        OBJECT(ISEEKABLE(it)->first())->toOutputStream();
      }
      return var();
    }

  #ifdef GNU_GCC
    std::string toString(){
      std::stringstream ss;

      for(var it = data; ISEEKABLE(it)->isEmpty() == false ; it = ISEEKABLE(it)->rest())
        ss << CHARACTER(ISEEKABLE(it)->first())->value;

      return ss.str();
    }
  #endif
    
    var getData(){
      return data;
    }
    
    var equals(var o){
      if (OBJECT(o)->getType() != STRING_TYPE)
        return false;
      return OBJECT(data)->equals(STRING(o)->getData());
    }

    var reduce(var f){
      return ISEEKABLE(data)->reduce(f);
    }

    var reduce(var f, var acc){
      return ISEEKABLE(data)->reduce(f,acc);
    }
  };
#+end_src

**** Tests

#+name: native-string-tests
#+begin_src clojure :tangle no
  (deftest native-string-test
    (is (= "Some String false true false true "
           (capture-output '((print "Some String"
                                    (= "Some String" "Other String")
                                    (= "Some String" "Some String")
                                    (= "Some String" 1)
                                    ((fn [str] "__result = VAR((STRING(str)->toString() == \"String\"))")
                                     "String")
                                    ))))))
#+end_src
*** Pointer

#+name: runtime-native-
#+begin_src c++ :tangle no

#+end_src

*** Boolean

#+name: runtime-native-boolean
#+begin_src c++ :tangle no
    class Boolean : public Object { 
    public:
      Boolean(bool b){value = b;}
      int getType(){ return BOOLEAN_TYPE;}
  
      bool asBool() { return value; }
  
      var equals(var o){
        if (OBJECT(o)->getType() != BOOLEAN_TYPE)
          return false;
      
        return (value == BOOLEAN(o)->asBool());
      }
  
      var toOutputStream(){ 
        if (value)
          fprintf(OUTPUT_STREAM, "true"); 
        else
          fprintf(OUTPUT_STREAM, "false"); 
        
        return var();
      }
    private:
      bool value;
    };
#+end_src

*** Lambda

except functors, they derive from the class Lambda, which has a single
invoke method that takes a sequence of vars as argument, this allows us
to execute them in a uniform fashion.

#+name: runtime-native-lambda
#+begin_src c++ :tangle no
  class Lambda : public Object{ 
  public:
    virtual var invoke(var args) = 0;
    int getType(){return LAMBDA_TYPE;}
    VAR equals(VAR o){return false;}
    VAR toOutputStream(){
      fprintf(OUTPUT_STREAM, "lambda");
      return VAR();
    }
  };
#+end_src

Function invocation macros,

#+name: runtime-native-lambda-invoke-macros
#+begin_src c++ :tangle no
  #define VA_ARGS(...) , ##__VA_ARGS__
  #define INVOKE(f,...) LAMBDA(f)->invoke((ferret::var(new ferret::Sequence()) VA_ARGS(__VA_ARGS__)))
  #define FN(f,...) ferret::var(new ferret::f(__VA_ARGS__))
#+end_src

*** var

Garbage collection is handled by reference counting, a /var/ holds a
pointer to an Object, everything is passed around as /vars/ it is
responsible for incrementing/decrementing the reference count, when it
reaches zero it will automatically free the Object. 

#+name: runtime-native-var
#+begin_src c++ :tangle no
  class var{
  public:
    var(Object* ptr=0) : m_ptr(ptr) { addRef(); }

    var(const var& p) : m_ptr(p.m_ptr) { addRef(); }
      
    ~var() { subRef(); }
      
    var& operator= (const var& p){
      return *this = p.m_ptr;
    }
      
    var& operator= (Object* ptr){
      if (m_ptr != ptr){
        subRef();
        m_ptr=ptr;
        addRef();
      }
      return *this;
    }

  #if NUMBER_DATA_TYPE != int
    var(int i);
  #endif

    var(NUMBER_DATA_TYPE i);
    var(NUMBER_DATA_TYPE n, NUMBER_DATA_TYPE dn);
    var(float f);
    var(bool b);
    var(char b);
    var(const char* str);
      
    var& operator, (const var& m);
    var toOutputStream() {
      if (m_ptr != NULL )
        m_ptr->toOutputStream();
      else
        fprintf(OUTPUT_STREAM, "nil");
      return var();
    }
      
    Object* get() { return m_ptr; }
      
  private:
    void addRef(){
      // Only change if non-null
      if (m_ptr) m_ptr->addRef();
    }
      
    void subRef(){
      // Only change if non-null
      if (m_ptr){
        // Subtract and test if this was the last pointer.
        if (m_ptr->subRef()){
          delete m_ptr;
          m_ptr=0;
        }
      }
    }
      
    Object* m_ptr;
  };
#+end_src

#+name: runtime-native-var-descriptions
#+begin_src c++ :tangle no
  #if NUMBER_DATA_TYPE != int
  var::var(int i){
    m_ptr = new Number(i);
    addRef();
  }
  #endif

  var::var(NUMBER_DATA_TYPE i){
    m_ptr = new Number(i);
    addRef();
  }

  var::var(NUMBER_DATA_TYPE n, NUMBER_DATA_TYPE dn){
    m_ptr = new Number(n,dn);
    addRef();
  }

  var::var(float f){
    m_ptr = new Number(f);
    addRef();
  }

  var::var(bool b){
    m_ptr = new Boolean(b);
    addRef();
  }

  var::var(char b){
    m_ptr = new Character(b);
    addRef();
  }

  var::var(const char* str){
    m_ptr = new String(str);
    addRef();
  }

  var& var::operator, (const var& m){
    static_cast<Sequence*>(m_ptr)->cons(m);
    return *this;
  }

#+end_src

** Lisp

Once our object system is in place we can define rest of the runtime
(functions/macros) using our Clojure subset,

#+name: runtime-clojure-first
#+begin_src clojure :tangle no
  (defn first [x]
    "if(x.get() == NULL)
      __result = VAR();
    else
      __result = SEQUENCE(x)->first();")

  (defn nil? [x] "__result = (x.get() == NULL)")

  (defn char? [x] "__result = (OBJECT(x)->getType() == CHARACTER_TYPE);")
#+end_src

We can embed C++ code into our functions, which is how most of the
primitive functions are defined such as the /first/ function above,
once primitives are in place rest can be defined in pure Clojure,

#+name: runtime-clojure-println
#+begin_src clojure :tangle no
  (defn println [& more]
    (apply print more)
    (newline))
#+end_src

As for macros, normal Clojure rules apply since they are expended using
Clojure, the only exception is that stuff should not expand to fully
qualified Clojure symbols, so the symbol /fn/ should not expand to
/clojure.core/fn/,

#+name: runtime-clojure-defn
#+begin_src clojure :tangle no
  (defmacro defn [name args & body]
    (list 'def name (cons 'fn `( ~args ~@body))))
#+end_src

*** Console I/O

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defn print [& more]
    (dotimes [i (count more)]
      "SEQUENCE(more)->nth(NUMBER(i)->intValue()).toOutputStream();
       fprintf(OUTPUT_STREAM, \" \");"))

  (defn newline []
    "fprintf(OUTPUT_STREAM, \"\\n\");")

  <<runtime-clojure-println>>
#+end_src

*** Looping

#+name: runtime-clojure-looping
#+begin_src clojure :tangle no
  (defmacro dotimes [binding & body]
    (list '_dotimes_ (second binding) (cons 'fn `( [~(first binding)] ~@body))))

  (defn _dotimes_ [t f] "for(int i = 0; i < NUMBER(t)->intValue(); i++) INVOKE(f,i);")
#+end_src

*** Conditionals

#+name: runtime-clojure-conditionals
#+begin_src clojure :tangle no
  (defmacro when [test & body]
    (list 'if test (cons 'do body)))

  (defmacro cond
    [& clauses]
    (when clauses
      (list 'if (first clauses)
            (if (next clauses)
              (second clauses)
              (throw (IllegalArgumentException.
                      "cond requires an even number of forms")))
            (cons 'cond (next (next clauses))))))

  (defmacro while [test & body]
    (list '_while_ (list 'fn [] test) (cons 'fn `( [] ~@body))))

  (defn _while_ [pred fn]
    "while(BOOLEAN(INVOKE(pred))->asBool() == true)
       INVOKE(fn);")

  (defmacro forever [& body]
    (cons 'while `(true  ~@body)))
#+end_src

**** Tests

#+name: runtime-clojure-conditionals-tests
#+begin_src clojure :tangle no
  (deftest conditionals-test
    (is (= "2 1 -1 2 2 2 1 "
           (capture-output '((print (if 1 2)
                                    (if (zero? 0) 1 -1)
                                    (if (zero? 1) 1 -1)
                                    (when true 2)
                                    (when (integer? 2) 2)
                                    (cond (float? 2.1) 2
                                          (integer? 2) 4
                                          :default 1)
                                    (cond (float? 2) 2.1
                                          (integer? 2.1) 4
                                          :default 1)))))))
#+end_src

*** Sequence

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn list [& xs] "__result = xs;")

  (defn list? [x] "__result = (OBJECT(x)->getType() == LIST_TYPE);")

  (defn empty? [x] "__result = SEQUENCE(x)->isEmpty();")

  (defn rest [x] "__result = SEQUENCE(x)->rest();")

  (defn cons [x seq] "__result = (SEQUENCE(seq)->clone(),x);")

  (defn apply [f args] "__result = LAMBDA(f)->invoke(args);")

  (defn conj [coll & xs]
    (reduce (fn[h v] (cons v h)) (if (nil? coll) (list) coll) xs))

  (defn reverse [s]
    (reduce conj (list) s))

  (defn count [s] "NUMBER_DATA_TYPE count = (NUMBER_DATA_TYPE)0;
                   for(var it = s; ISEEKABLE(it)->isEmpty() == false ; it = ISEEKABLE(it)->rest())
                     count = count + 1;
                   __result = VAR(count);")
#+end_src

**** Tests

#+name: runtime-clojure-sequences-tests
#+begin_src clojure :tangle no
  (deftest sequences-test
    (is (= "( 1 2 3 4 ) 1 ( 2 3 4 ) ( 3 4 ) ( 3 3 4 ) 3 4 ( 4 3 2 1 1 2 ) ( 4 3 2 1 ) 21 21 "
           (capture-output '((print (list 1 2 3 4)
                                    (first (list 1 2 3 4))
                                    (rest (list 1 2 3 4))
                                    (rest (rest (list 1 2 3 4)))
                                    (cons 3 (rest (rest (list 1 2 3 4))))
                                    (first (cons 3 (rest (rest (list 1 2 3 4)))))
                                    (count (list 1 2 3 4))
                                    (conj (list 1 2) 1 2 3 4)
                                    (conj nil 1 2 3 4)
                                    (reduce + (list 1 2 3 4 5 6))
                                    (apply + (list 1 2 3 4 5 6)))))))
    (is (= "( 6 5 4 3 2 1 ) ( 6 5 4 3 2 ) ( 4 3 2 1 0 ) ( . o l l e H ) "
           (capture-output '((print (reverse (list 1 2 3 4 5 6))
                                    (reduce (fn [h v]
                                              (conj h (inc v))) (list) (list 1 2 3 4 5))
                                    (reduce (fn [h v]
                                              (conj h (dec v))) (list) (list 1 2 3 4 5))
                                    (reduce (fn [h v]
                                              (conj h v)) (list) "Hello."))))))

    (is (= "( 1 2 3 4 5 6 ) ( 7 6 5 4 3 2 ) ( 1 7 6 5 4 3 2 ) "
           (capture-output '((let [l1 (list 1 2 3 4 5 6)
                                   l2 (reduce (fn[h v] (conj h (inc v))) (list) l1)
                                   l3 (cons 1 l2)]
                               (print l1 l2 l3)))))))
#+end_src
*** Logical Operators

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn = [a & more]
    (if (empty? more)
      true
      (and ((fn [a b] "__result = OBJECT(a)->equals(b);") a (first more))
           (apply = more))))

  (defmacro not= [& test]
    (list 'not (cons '= `( ~@test))))

  (defn < [a & more]
    (if (empty? more)
      true
      (and ((fn [a b] "
      NUMBER_DATA_TYPE an = NUMBER(a)->getNumerator();
      NUMBER_DATA_TYPE adn = NUMBER(a)->getDenominator();

      NUMBER_DATA_TYPE bn = NUMBER(b)->getNumerator();
      NUMBER_DATA_TYPE bdn = NUMBER(b)->getDenominator();

      return VAR((an * bdn) < (bn * adn));") a (first more))
           (apply < more))))

  (defn > [a & more]
    (if (empty? more)
      true
      (and ((fn [a b] "
      NUMBER_DATA_TYPE an = NUMBER(a)->getNumerator();
      NUMBER_DATA_TYPE adn = NUMBER(a)->getDenominator();

      NUMBER_DATA_TYPE bn = NUMBER(b)->getNumerator();
      NUMBER_DATA_TYPE bdn = NUMBER(b)->getDenominator();

      return VAR((an * bdn) > (bn * adn));") a (first more))
           (apply > more))))

  (defn >= [a & more]
    (if (empty? more)
      true
      (and ((fn [a b] "
      NUMBER_DATA_TYPE an = NUMBER(a)->getNumerator();
      NUMBER_DATA_TYPE adn = NUMBER(a)->getDenominator();

      NUMBER_DATA_TYPE bn = NUMBER(b)->getNumerator();
      NUMBER_DATA_TYPE bdn = NUMBER(b)->getDenominator();

      return VAR((an * bdn) >= (bn * adn));") a (first more))
           (apply >= more))))

  (defn <= [a & more]
    (if (empty? more)
      true
      (and ((fn [a b] "
      NUMBER_DATA_TYPE an = NUMBER(a)->getNumerator();
      NUMBER_DATA_TYPE adn = NUMBER(a)->getDenominator();

      NUMBER_DATA_TYPE bn = NUMBER(b)->getNumerator();
      NUMBER_DATA_TYPE bdn = NUMBER(b)->getDenominator();

      return VAR((an * bdn) <= (bn * adn));") a (first more))
           (apply <= more))))

  (defmacro and
    ([] true)
    ([x] x)
    ([x & next]
     (list 'if x `(and ~@next) false)))

  (defmacro or
    ([] nil)
    ([x] x)
    ([x & next]
     (list 'if x x `(or ~@next))))

  (defn not [x]
    "if (OBJECT(x)->getType() != BOOLEAN_TYPE)
        return false;
        __result = !BOOLEAN(x)->asBool();")
#+end_src

**** Tests

#+name: runtime-clojure-logical-operators-tests
#+begin_src clojure :tangle no
  (deftest logical-operators-test
    (is (= "true true false true false true true true false true true false true false true true "
           (capture-output '((print (< 2)
                                    (< 2 3 4 5)
                                    (< 2 3 6 5)
                                    (> 2)
                                    (> 2 3 4 5)
                                    (> 6 5 4 3)
                                    (>= 2)
                                    (>= 5 4 3 2 2 2)
                                    (>= 5 1 3 2 2 2)
                                    (<= 2)
                                    (<= 2 2 3 4 5)
                                    (<= 2 2 1 3 4)
                                    (= 2)
                                    (= 2 3)
                                    (= 2 2 2 2)
                                    (= 2 2.0 2))))))

    (is (= "false true false true false false "
           (capture-output '((print (= 2 2 2 2 3 5)
                                    (= (list 1 2) (list 1 2))
                                    (= (list 1 2) (list 1 3))
                                    (= true true)
                                    (not (= true true))
                                    (not 1)))))))
#+end_src

*** Math

#+name: runtime-clojure-math
#+begin_src clojure :tangle no
  (defn integer? [x] "__result = ((OBJECT(x)->getType() == NUMBER_TYPE) &&
                                    (NUMBER(x)->getDenominator() == 1));")

  (defn float? [x] "__result = ((OBJECT(x)->getType() == NUMBER_TYPE) &&
                                  (NUMBER(x)->getDenominator() != 1));")

  (defn + [& xs]
    (reduce (fn[h v] "
        NUMBER_DATA_TYPE hn = NUMBER(h)->getNumerator();
        NUMBER_DATA_TYPE hdn = NUMBER(h)->getDenominator();

        NUMBER_DATA_TYPE vn = NUMBER(v)->getNumerator();
        NUMBER_DATA_TYPE vdn = NUMBER(v)->getDenominator();

        NUMBER_DATA_TYPE ndn = (hdn * vdn);

        return VAR(((hn * vdn) + (vn * hdn)),ndn);") 0 xs))

  (defn * [& xs]
    (reduce (fn[h v] "
        NUMBER_DATA_TYPE hn = NUMBER(h)->getNumerator();
        NUMBER_DATA_TYPE hdn = NUMBER(h)->getDenominator();

        NUMBER_DATA_TYPE vn = NUMBER(v)->getNumerator();
        NUMBER_DATA_TYPE vdn = NUMBER(v)->getDenominator();

        NUMBER_DATA_TYPE ndn = (hdn * vdn);

        return VAR(((hn * vdn) * (vn * hdn)),ndn);") 1 xs))

  (defn - [& xs]
    (if (= (count xs) 1)
      (* -1 (first xs))
      (reduce (fn[h v] "
        NUMBER_DATA_TYPE hn = NUMBER(h)->getNumerator();
        NUMBER_DATA_TYPE hdn = NUMBER(h)->getDenominator();

        NUMBER_DATA_TYPE vn = NUMBER(v)->getNumerator();
        NUMBER_DATA_TYPE vdn = NUMBER(v)->getDenominator();

        NUMBER_DATA_TYPE ndn = (hdn * vdn);

        return VAR(((hn * vdn) - (vn * hdn)),ndn);") (first xs) (rest xs))))

  (defn / [& xs]
    (if (= (count xs) 1)
      (apply / (cons 1 xs))
      (reduce (fn[h v] "
        NUMBER_DATA_TYPE hn = NUMBER(h)->getNumerator();
        NUMBER_DATA_TYPE hdn = NUMBER(h)->getDenominator();

        NUMBER_DATA_TYPE vn = NUMBER(v)->getNumerator();
        NUMBER_DATA_TYPE vdn = NUMBER(v)->getDenominator();

        return VAR((hn * vdn),(vn * hdn));") (first xs) (rest xs))))

  (defn inc [x]
    (+ x 1))

  (defn dec [x]
    (- x 1))

  (defn pos? [x]
    (> x 0))

  (defn neg? [x]
    (< x 0))

  (defn zero? [x]
    (= x 0))
#+end_src

**** Tests

#+name: runtime-clojure-bit-arithmetic-tests
#+begin_src clojure :tangle no
  (deftest arithmetic-test
    (is (= "3/5 0 1 10 10 -1 0 0 1 8 8 1 1/2 1 1 "
           (capture-output '((print (+ 0.3 0.3)
                                    (+ )
                                    (+ 1)
                                    (+ 1 2 3 4)
                                    (+ 1 2.0 3 4)

                                    (- 1)
                                    (- 4 2 2)
                                    (- 4 2 2.0)
                                    
                                    (* )
                                    (* 2 2 2)
                                    (* 2.0 2 2)
                                    
                                    (/ 1)
                                    (/ 2)
                                    (/ 4 2 2)
                                    (/ 4 2 2.0))))))

    (is (= "true true false false true true false true true true "
           (capture-output '((print (pos? 1)
                                    (pos? 0.2)
                                    (pos? 0)
                                    (neg? 1)
                                    (neg? -1)
                                    (zero? 0)
                                    (zero? 10)
                                    (zero? (- 1 1))
                                    (zero? (- 1.2 1.2))
                                    (zero? (+ 1.2 -1.2)))))))

    (is (= "1 2 1 2 1 2 1 2 "
           (capture-output '((let [a 1
                                   b 2]
                               (+ 1 a)
                               (+ b a)
                               (print a b)
                               (* 2 a)
                               (* b a)
                               (print a b)
                               (/ 2 a)
                               (/ b a)
                               (print a b)
                               (- 2 a)
                               (- b a)
                               (print a b)))))))
#+end_src

*** Bit Operations

#+name: runtime-clojure-bit-operations
#+begin_src clojure :tangle no
  (defn bit-not [x] "__result = VAR(~NUMBER(x)->getNumerator());")

  (defn bit-and [x y] "__result = VAR((NUMBER(x)->getNumerator() &
                                       NUMBER(y)->getNumerator()));")

  (defn bit-or [x y] "__result = VAR((NUMBER(x)->getNumerator() |
                                      NUMBER(y)->getNumerator()));")

  (defn bit-xor [x y] "__result = VAR((NUMBER(x)->getNumerator() ^
                                       NUMBER(y)->getNumerator()));")

  (defn bit-shift-left [x n] "__result = VAR((NUMBER(x)->getNumerator() <<
                                              NUMBER(n)->getNumerator()));")

  (defn bit-shift-right [x n] "__result = VAR((NUMBER(x)->getNumerator() >>
                                               NUMBER(n)->getNumerator()));")
#+end_src

**** Tests

#+name: runtime-clojure-bit-operations-tests
#+begin_src clojure :tangle no
  (deftest bit-operations-test
    (is (= "-5 -1 7 1 0 0 0 1 8 16 2 1 "
           (capture-output '((print (bit-not  4)
                                    (bit-not  0)
                                    (bit-or   4 3)
                                    (bit-or   0 1)
                                    (bit-and  4 3)
                                    (bit-and  0 1)
                                    (bit-xor  4 4)
                                    (bit-xor  1 0)
                                    (bit-shift-left 4 1)
                                    (bit-shift-left 4 2)
                                    (bit-shift-right 4 1)
                                    (bit-shift-right 4 2)))))))
#+end_src

*** Arduino

#+name: runtime-clojure-arduino
#+begin_src clojure :tangle no
  (defn pin-mode [pin mode]
    "if (KEYWORD(mode)->equals(Keyword(\":input\")) == true)
        pinMode(NUMBER(pin)->intValue(), INPUT);
     else
        pinMode(NUMBER(pin)->intValue(), OUTPUT);")

  (defn digital-write [pin mode]
    "if (KEYWORD(mode)->equals(Keyword(\":high\"))  == true)
        digitalWrite(NUMBER(pin)->intValue(), HIGH);
     else
        digitalWrite(NUMBER(pin)->intValue(), LOW);")

  (defn sleep [timeout] "::delay(NUMBER(timeout)->intValue());")
#+end_src

* Example Code

In order to compile the samples,

#+begin_example
lein run -in sample.clj
#+end_example

output will be placed in a directory called /solution//,

** Arduino LED
#+begin_src clojure :mkdirp yes :tangle ferret/examples/led.clj
  (pin-mode 13 :output)
  
  (forever
   (digital-write 13 :high)
   (sleep 500)
   (digital-write 13 :low)
   (sleep 500))
#+end_src 
** FFI

Example build options map,

#+BEGIN_EXAMPLE
  {:include-path ["/usr/local/Cellar/opencv/2.4.9/include/"]
   :library-path ["/usr/local/Cellar/opencv/2.4.9/lib/"]
   :link ["opencv_core"
          "opencv_highgui"]
   :compiler-options ["-Wall"]
   :name "cv-webcam"
   :delete-solution-folder true}
#+END_EXAMPLE

#+begin_src clojure :mkdirp yes :tangle ferret/examples/webcam.clj
  (native-declare "#include \"opencv/cv.h\"
                   #include \"opencv/highgui.h\"")
  
  (defn wait-key [i] "__result = var((char)cvWaitKey(NUMBER(i)->intValue()));")
  
  (defn video-capture [i]
    "cv::VideoCapture *cap = new cv::VideoCapture(NUMBER(i)->intValue());
     if (cap->isOpened())
      __result = var(new Pointer(cap));")
  
  (defn named-window [n] "cv::namedWindow(STRING(n)->toString(),1);")
  
  (defn query-frame [c]
    "cv::VideoCapture *cap = static_cast<cv::VideoCapture*>(POINTER(c)->ptr);
     cap->grab();
     cv::Mat *image = new cv::Mat;
     cap->retrieve(*image, 0);
     __result = var(new Pointer(image));")
  
  (defn show-image [f img]
    "cv::Mat *i = static_cast<cv::Mat*>(POINTER(img)->ptr);
     imshow(STRING(f)->toString(), *i);")
  
  (def cam (video-capture 0))
  
  (named-window "cam")
  
  (while (not= (wait-key 1) \q)
    (let [f (query-frame cam)]
      (show-image "cam" f)))
#+end_src 

* Misc

  #+name: core-code-generation-misc
  #+begin_src clojure
    ;; I/O

    (defn read-from-url [f]
      (with-open [in (.getResourceAsStream (ClassLoader/getSystemClassLoader) f)
                  rdr (BufferedReader. (InputStreamReader. in))]
        (apply str (interpose \newline (line-seq rdr)))))

    (defn copy-to-solution [fin fout]
      (FileUtils/copyURLToFile (ClassLoader/getSystemResource fin) (file fout)))

    (defn delete-recursively [file]
      (let [func (fn [func f]
                   (when (.isDirectory f)
                     (doseq [f2 (.listFiles f)]
                       (func func f2)))
                   (clojure.java.io/delete-file f))]
        (when (.exists file)
          (func func file))))

    (defn init-solution-dir []
      (doto (file "./solution/")
        (delete-recursively)
        (.mkdir))
      (copy-to-solution "ferret.h" "./solution/ferret.h"))

    (defn write-to-solution [s f]
      (FileUtils/writeStringToFile (file (str "./solution/" f)) s))

    (defn append-to! [r ks v]
      (dosync 
       (let [cv (reduce (fn[h v] (v h)) @r ks)]
         (alter r assoc-in ks (conj cv v)))))

    (defn to-str? [f]
      (or (true? f) (false? f) (symbol? f)))

    (defn is-special-form? [s f]
      (and (seq? f)
           (= (first f) s)))
  #+end_src

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn compile-options [& [options]]
      (merge {:compiler "g++"
              :include-path []
              :library-path []
              :link []
              :compiler-options ["-Werror" "-Wall"]
              :source-extension "cpp"}
             options))

    (defn compile->cpp [form options]
      (init-solution-dir)
      (let [source (emit-source form)]
        (write-to-solution (solution-template source) (str "solution." (:source-extension options)))))

    (defn compile->binary [options]
      (let [command (flatten [(:compiler options)
                              (map #(str %) (:compiler-options options))
                              (map #(str "-I" %) (:include-path options))
                              (map #(str "-L" %) (:library-path options))
                              (map #(str "-l" %) (:link options))
                              (str "solution." (:source-extension options))])
            ret (with-sh-dir "solution/"
                  (apply sh command))]
        (println "Running=>" command)
        (println "Return=>" ret)
        (if (not= 0 (:exit ret))
          (System/exit 1)
          (do (when (:name options)
                (with-sh-dir "solution/"
                  (sh "mv" "a.out" (str "../" (:name options)))))
              (when (:delete-solution-folder options)
                (sh "rm" "-rf" "solution/"))
              true))))

    (defn -main [& args]
      (let [opts [["-i" "--input FILE" "Input File"
                   :parse-fn #(read-string (str \( (FileUtils/readFileToString (file %)) \)))]
                  ["-c" "--compile" "Compile Solution"]
                  ["-o" "--compile-options FILE" "Compile Options File"
                   :parse-fn #(read-string (FileUtils/readFileToString (file %)))]
                  ["-h" "--help"]]
            args (parse-opts args opts)
            options (compile-options (->> args :options :compile-options))]
        (if (->> args :options :input)
          (do (compile->cpp (->> args :options :input) options)
              (when (->> args :options :compile)
                (compile->binary options)
                (shutdown-agents)))
          (println "No Input File."))))
  #+end_src

* Files                                                            :noexport:
** project.clj
#+begin_src clojure :mkdirp yes :tangle ferret/project.clj
  (defproject ferret "1.0.0-SNAPSHOT"
    :dependencies [[org.clojure/clojure "1.7.0"]
                   [org.clojure/tools.cli "0.3.3"]
                   [org.bituf/clj-stringtemplate "0.2"]
                   [org.clojars.amit/commons-io "1.4.0"]]
    :repl-options {:host "0.0.0.0"
                   :port 7888
                   :init-ns ferret.core}
    :main ferret.core
    :aot [ferret.core]
    :jar-name "interim.jar"
    :uberjar-name "ferret-app.jar")
#+end_src 
** src/core.clj
#+begin_src clojure :noweb yes :mkdirp yes :tangle ferret/src/ferret/core.clj
  (ns ferret.core
    (:gen-class)
    (:use [clojure.java.io]
          [clojure.walk :only [macroexpand-all]])
    (:require [clojure.zip :as zip]
              [clojure.tools.cli :refer [parse-opts]])
    (:use [ferret.string-template]
          [ferret.template]
          [clojure.java.shell])
    (:import (org.apache.commons.io FileUtils)
             (java.io BufferedReader StringReader InputStreamReader)))

  <<core-code-generation-misc>>

  <<core-transformation-form-fns>>

  <<core-transformation-vector-list>>

  <<core-transformation-vector-list>>

  <<core-transformation-expand-macros>>

  <<core-transformation-add-built-in>>

  <<core-transformation-closure-conversion>>

  <<core-transformation-symbol-conversion>>

  <<core-transformation-do-fn>>

  <<core-transformation-let-fn>>

  <<core-transformation-process>>

  <<core-code-generation-emit>>

  <<core-code-generation-emit-source-methods>>

  <<core-code-generation-emit-source>>

  <<core-code-compile-code>>
#+end_src 
** src/template.clj
#+begin_src clojure :mkdirp yes :noweb yes :tangle ferret/src/ferret/template.clj
  (ns ferret.template
    (:use [ferret.string-template]))

  (defn indexed
    "Returns a lazy sequence of [index, item] pairs, where items come
    from 's' and indexes count up from zero.

    (indexed '(a b c d))  =>  ([0 a] [1 b] [2 c] [3 d])"
    [s]
    (map vector (iterate inc 0) s))

  <<code-templates>>
#+end_src 
** src/string_template.clj
#+begin_src clojure :noweb yes :mkdirp yes :tangle ferret/src/ferret/string_template.clj
  (ns ferret.string-template
    (:import org.antlr.stringtemplate.StringTemplateGroup)
    (:import org.antlr.stringtemplate.StringTemplate)
    (:use ferret.string-template-internal))


  (defn create-view "Return new view template - useful as mentioned here:
    http://hardlikesoftware.com/weblog/2006/12/12/using-json-with-stringtemplate/"
    ([]
      (StringTemplate.))
    ([^String template]
      (StringTemplate. template)))


  (defn get-view-from-classpath "Return the view template from classpath"
    [^String view-name]
    (let [st-group (StringTemplateGroup. "default")]
      (.getInstanceOf st-group view-name)))


  (defn get-view-from-dir "Return the view template from specified directory"
    [^String view-name ^String root-dir]
    (let [st-group (StringTemplateGroup. "default" root-dir)]
      (.getInstanceOf st-group view-name)))


  (defn reset-view! "Reset view template with supplied content"
    [^StringTemplate view ^String template]
    (.setTemplate view template))


  (defn fill-view! "Fill view template with key/value pairs"
    ;;;
    ;; Fill template with key and value
    ([^StringTemplate template k v]
      (.setAttribute template (stringify k) (each-kv-to-sv v))
      template)
    ;;;
    ;; Fill template with key/value from map
    ([^StringTemplate template kv-map]
      (.setAttributes template (kv-to-sv kv-map))
      template))


  (defn render-view "Return rendered view for the template"
    [^StringTemplate template]
    (.toString template))
#+end_src

#+begin_src clojure :noweb yes :mkdirp yes :tangle ferret/src/ferret/string_template_internal.clj
  (ns ferret.string-template-internal)


  (defn stringify [any]
    (if (keyword? any)
      (name any)
      (str any)))


  (declare kv-to-sv)
  (declare scan-kv-to-sv)


  (defn each-kv-to-sv "If element is a collection type, do deep transformation"
    [each]
    (if (map? each)
      (kv-to-sv each)
      (if (or (vector? each) (list? each) (seq? each) (set? each))
        (scan-kv-to-sv each)
        each)))


  (defn scan-kv-to-sv
    "Scans a collection and turns any contained map within from kv to sv"
    [coll]
    (map each-kv-to-sv coll))


  (defn kv-to-sv
    "Transforms keyword-value map {:a 10 :b 20 :c 30}
     to string-value map {\"a\" 10 \"b\" 20 \"c\" 30}"
    [mp]
    (let [m (into {} mp)
          k (keys m)
          v (vals m)]
      (zipmap
        (map stringify k)
        (scan-kv-to-sv v))))

#+end_src

** test/core.clj
#+begin_src clojure :noweb yes :mkdirp yes :tangle ferret/test/ferret/test/core.clj
    (ns ferret.test.core
      (:use [ferret.core] :reload)
      (:use [clojure.test]
            [clojure.java.shell]))

  (defn capture-output [form]
    (let [options (compile-options)]
      (compile->cpp form options)
      (compile->binary options)
      (with-sh-dir "solution/"
        (let [r (sh "./a.out")]
          (:out r)))))

    <<compiler-transformation-tests>>
    <<runtime-clojure-bit-operations-tests>>
    <<runtime-clojure-bit-arithmetic-tests>>
    <<runtime-clojure-logical-operators-tests>>
    <<runtime-clojure-conditionals-tests>>
    <<runtime-clojure-sequences-tests>>
    <<native-string-tests>>
    <<native-keyword-tests>>
#+end_src 

** resources/ferret.h
#+begin_src c++ :mkdirp yes :noweb yes :tangle ferret/resources/ferret.h
  #ifndef H_FERRET
  #define H_FERRET

  #ifdef __AVR__
  # define AVR_GCC TRUE
  #else
  # define GNU_GCC TRUE
  #endif

  #include <stdlib.h>
  #include <stdio.h>

  #ifdef GNU_GCC
  #include <iostream>
  #include <sstream>
  #endif

  #ifdef AVR_GCC
  #include "Arduino.h"
  #endif

  //
  // Compiler Specific
  //

  #ifdef AVR_GCC
  extern "C" void __cxa_pure_virtual(void); 
  void __cxa_pure_virtual(void) {}; 

  static FILE uartout = {0};

  static int uart_putchar (char c, FILE *stream){
    Serial.write(c);
    return 0 ;
  }

  #define OUTPUT_STREAM &uartout

  #define INIT_ENV                                                        \
    init();                                                               \
    Serial.begin(9600);                                                   \
    fdev_setup_stream (&uartout, uart_putchar, NULL, _FDEV_SETUP_WRITE);  \

  #endif

  #ifdef GNU_GCC
  #define OUTPUT_STREAM stdout
  #define INIT_ENV 
  #endif

  #define VAR ferret::var

  <<runtime-native-math-config>>

  #define MIN(a,b) ((a)<(b)?(a):(b))
  #define ABS(a) ((a)<0 ? -(a) : (a))

  <<runtime-native-object-casting-macros>>
  <<runtime-native-lambda-invoke-macros>>

  namespace ferret{

    //
    // Objects
    //

    class var;

    <<runtime-native-object-types-enum>>
    <<runtime-native-object>>
    <<runtime-native-var>>
    <<runtime-native-number>>
    <<runtime-native-pointer>>
    <<runtime-native-boolean>>
    <<runtime-native-keyword>>
    <<runtime-native-lambda>>
    <<runtime-native-character>>
    <<native-seekable-interface>>
    <<runtime-native-sequence>>
    <<runtime-native-string>>
    <<runtime-native-var-descriptions>>
  }
  #endif

#+end_src 
** resources/runtime.clj

#+begin_src clojure :mkdirp yes :noweb yes :tangle ferret/resources/runtime.clj
  <<runtime-clojure-defn>>
  <<runtime-clojure-looping>>
  <<runtime-clojure-first>>
  <<runtime-clojure-sequence>>
  <<runtime-clojure-logical-operators>>
  <<runtime-clojure-conditionals>>
  <<runtime-clojure-math>>
  <<runtime-clojure-bit-operations>>
  <<runtime-clojure-console-io>>
  <<runtime-clojure-arduino>>
#+end_src
