#+title: Ferret: An Experimental Clojure Compiler
#+tags: clojure c++ arduino avr-gcc gcc
#+STARTUP: hidestars
#+TAGS: noexport(e)
#+EXPORT_EXCLUDE_TAGS: noexport
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-dark.min.css" />
#+OPTIONS: toc:nil
#+TOC: headlines 3

* Example Code
** OpenCV

Following /build.options/ file links the resulting code with
OpenCV.

#+BEGIN_EXAMPLE
  {:include-path ["/usr/local/Cellar/opencv/2.4.9/include/"]
   :library-path ["/usr/local/Cellar/opencv/2.4.9/lib/"]
   :link ["opencv_core"
          "opencv_highgui"]
   :compiler-options ["-Wall"]
   :name "cv-webcam"}
#+END_EXAMPLE

Compile the file using,

#+BEGIN_EXAMPLE
  lein run -i examples/webcam.clj -o build.options 
#+END_EXAMPLE

Display webcam in a window.

#+begin_src clojure :mkdirp yes :tangle ferret/examples/webcam.clj
  (native-header "opencv/cv.h"
                 "opencv/highgui.h")
  
  (defn wait-key [i] "__result = var((char)cvWaitKey(NUMBER(i)->intValue()));")
  
  (defn video-capture [i]
    "cv::VideoCapture *cap = new cv::VideoCapture(NUMBER(i)->intValue());
     if (cap->isOpened())
      __result = var(new Pointer(cap));")
  
  (defn named-window [n] "cv::namedWindow(STRING(n)->toString(),1);")
  
  (defn query-frame [c]
    "cv::VideoCapture *cap = static_cast<cv::VideoCapture*>(POINTER(c)->ptr);
     cap->grab();
     cv::Mat *image = new cv::Mat;
     cap->retrieve(*image, 0);
     __result = var(new Pointer(image));")
  
  (defn show-image [f img]
    "cv::Mat *i = static_cast<cv::Mat*>(POINTER(img)->ptr);
     imshow(STRING(f)->toString(), *i);")
  
  (def cam (video-capture 0))
  
  (named-window "cam")
  
  (while (not= (wait-key 1) \q)
    (let [f (query-frame cam)]
      (show-image "cam" f)))
#+end_src 

* Compiler

Compiler has two major parts, transformation and code
generation. During transformation we make passes over the code, with
each pass code becomes more and more like C++ basically after the final
pass it is C++ written with s-expressions. Then during code generation
we iterate over the code and spit valid C++.

** Transformation

Forms go through nine transformations before they are passed to the
code generation phase.

#+name: core-transformation-process
#+begin_src clojure :tangle no
  (defn process [form]
    (->> (import-modules-all form)
         (add-built-in)
         (expand-macros-all)
         (vector->list)
         (let->fn)
         (do->fn)
         (closure-conversion)
         (symbol-conversion)
         (replace-fn-call-sites)))
#+end_src

*** Import Modules

Import other ferret files using,

#+BEGIN_SRC clojure :tangle no
  (require '[package.io :as io])
#+END_SRC

Compiler will look for a file under current working directory called,
/package/io.clj/ all expression in the that file will be added to the
front of the current form with symbols renamed to /some-fn/ =>
/io/some-function/.

#+name: core-transformation-add-built-in
#+begin_src clojure :tangle no
  (defn import-modules [form]
    (let [package-list (select-form form (is-form? 'require))
          imports (->> package-list
                       (map rest)
                       (map first)
                       (map rest)
                       (map first)
                       (map (fn [[mod _ as]]
                              [(str (.replace (str mod) "." "/") ".clj") as]))
                       (map (fn [[mod as]]
                              [(read-clojure-file mod) as]))
                       (map (fn [[mod as]]
                              (let [symbols (->> (select-form
                                                  (expand-macros-all mod) (is-form? 'def))
                                                 (map second)
                                                 (into #{}))
                                    mod (morph-form mod symbol?
                                                    (fn [f]
                                                      (if (symbols f)
                                                        (symbol (str as "/" f))
                                                        f)))]
                                mod)))
                       (reduce (fn[mod form]
                                 (reduce (fn[h v] (cons v h)) form mod)) [])
                       vec)
          form-no-require (if (and (= (count form) 1)
                                   (= (first (first form)) 'require))
                            (list )
                            (remove-form form (is-form? 'require)))]
      (apply list (reduce (fn[h v] (conj h v)) imports form-no-require))))

  (defn import-modules-all [form]
    (loop [f form]
      (let [expanded (import-modules f)]
        (if (= f expanded)
          expanded
          (recur expanded)))))
#+end_src

**** Tests

Create some dummy libs under /examples/modules/,

#+begin_src clojure :mkdirp yes :tangle ferret/examples/modules/module-a.clj
  (defn helper-a []
    (print "Module A"))
#+end_src 

#+begin_src clojure :mkdirp yes :tangle ferret/examples/modules/module-b.clj
  (require '[examples.modules.module-c :as mod-c])

  (defn helper-b []
    (mod-c/helper-c))
#+end_src 

#+begin_src clojure :mkdirp yes :tangle ferret/examples/modules/module-c.clj
  (defn helper-c []
    (print "Module C"))
#+end_src 

Run import tests,

#+name: compiler-import-module-test
#+begin_src clojure :tangle no
  (deftest import-module-test
    (is (= "Module AModule C"
           (capture-output '((require '[examples.modules.module-a :as mod-a])
                             (require '[examples.modules.module-b :as mod-b])
                             (mod-a/helper-a)
                             (mod-b/helper-b))))))
#+end_src

*** Add Runtime

In order to keep the generated C++ code compact only the functions used
will be present in the generated source file. Which means if you don't
use /println/ anywhere in the code it won't be defined in the final
C++ file, but if you use it, it and everything it uses will be
defined, in the case of /println/ it will pull /apply/, /print/ and
/newline/ with it.

#+name: core-transformation-add-built-in
#+begin_src clojure :tangle no
  (defn add-built-in
    ([form]
     (let [runtime-form (read-string (str \( (read-from-url "runtime.clj") \)))
           built-in-defn (expand-macros-all runtime-form)
           built-in-order (->> (filter #(not= 'defobject (first %)) built-in-defn)
                               (map second))
           built-in (->> built-in-defn
                         (reduce (fn[h v] (assoc h (second v) v)) {}))
           fns (atom {})
           _ (add-built-in (->> form expand-macros-all vector->list) built-in fns)
           sorted-fns (->> @fns
                           (sort-by #(.indexOf built-in-order (key %)))
                           (map #(second %)))
           def-objects (filter #(= 'defobject (first %)) built-in-defn)]
       (concat def-objects sorted-fns form)))
    ([form built-in fns]
     (morph-form form symbol?
                 #(do (if-let [f (built-in %)]
                        (when (not (@fns %))
                          (swap! fns assoc % f)
                          (add-built-in f built-in fns))) %))))
#+end_src

*** Expand Macros

First we read all the macros present in /runtime.clj/ then add to that
user defined macros, they are evaluated in a temporary namespace,
using /morph-form/ we iterate all the macros used in the code that we
are compiling and expand them in the temporary namespace then the node
is replaced with its expanded form.

#+name: core-transformation-expand-macros
#+begin_src clojure :tangle no
  (declare expand-macros-all)

  (defn expand-macros [form]
    (let [macros (->> (read-string (str \( (read-from-url "runtime.clj") \)))
                      ;;get built in macros
                      (filter (is-form? 'defmacro))
                      ;;merge user defined macros
                      (concat (filter (is-form? 'defmacro) form)))
          form (remove-form form (is-form? 'defmacro))
          temp-ns (gensym)]
      
      (create-ns temp-ns)
      (binding [*ns* (the-ns temp-ns)]
        (refer 'clojure.core :exclude (concat (map second macros) ['fn 'def]))
        (use '[ferret.core :only [symbol-conversion]])
        (doseq [m macros]
          (eval m)))

      (let [form (morph-form form
                             (apply is-form? (map second macros))
                             (fn [f]
                               (binding [*ns* (the-ns temp-ns)]
                                 (macroexpand-all f))))
            form (morph-form form
                             (is-form? 'let)
                             (fn [[_ bindings & body]]
                               (let [form (cons 'let* (cons bindings (expand-macros-all body)))]
                                 (->> form vector->list expand-macros-all))))]
        (remove-ns temp-ns)
        form)))

  (defn expand-macros-all [form]
    (loop [f form]
      (let [expanded (expand-macros f)]
        (if (= f expanded)
          expanded
          (recur expanded)))))
#+end_src

*** vector->list

Since there is no support for vectors, they are converted to
lists. Also zippers do not iterate over vectors.

#+name: core-transformation-vector-list
#+begin_src clojure :tangle no
  (defn vector->list [form]
    (morph-form form vector? #(reverse (into '() %))))
#+end_src

*** let->fn

let forms are transformed into nested functions which are then called
immediately, bindings are setup in the outer function, expressions are
placed in the inner function which takes the bindings as arguments.

So following form,

#+begin_src clojure :tangle no
  (let->fn '(let [a 1
                  b 2]
              (+ a b)))
#+end_src

after transformation becomes,

#+begin_src clojure :tangle no
  ((fn []
     (define-var a 1)
     (define-var b 2)
  
     ((fn (a b)
        (+ a b)) a b)))
#+end_src

#+name: core-transformation-let-fn
#+begin_src clojure :tangle no
  (defn let->fn [form]
    (morph-form form
                (is-form? 'let*)
                (fn [[_ bindings & body]]
                  (let [bindings (partition 2 bindings)
                        vars (flatten (map first bindings))
                        defs (map #(cons 'define-var %) bindings)
                        body-fn (cons (concat ['fn vars] body) vars)]
                    (list (concat ['fn []] defs [body-fn]))))))
#+end_src

*** do->fn

A similar method is used for the do form, expressions are wrapped in a fn
that takes no parameters and executed in place.

#+begin_src clojure :tangle no
  (do->fn '(do (+ 1 1)))
#+end_src

#+begin_src clojure :tangle no
  ((fn [] (+ 1 1)))
#+end_src

#+name: core-transformation-do-fn
#+begin_src clojure :tangle no
  (defn do->fn [form]
    (morph-form form
                (is-form? 'do)
                #(list (concat ['fn []] (rest %)))))
#+end_src

*** Closure Conversion

/closure-conversion/ handles the problem of free variables, 

#+begin_src clojure :tangle no
  (defn make-adder [x]
    (fn [n] (+ x n)))
#+end_src

in the above snippet x is a free variable, the function /make-adder/
returns, has to have a way of referencing that variable when it is
used. The way we do this is that, every function will pass its arguments to
inner functions (if any) it contains.

#+begin_src clojure :tangle no
  (closure-conversion '(fn [x]
                          (fn [n] (+ x n))))
#+end_src

Above form will be converted to,

#+begin_src clojure :tangle no
  (define-lambda G__265 (x) (n) (+ x n))
  (define-lambda G__266 () (x) (lambda-object G__265 x))
#+end_src

What this means is, define a functor named /G__265/ that holds a
reference to /x/, and another functor /G__266/ that has no state. When
we create an instance of /G__265/ we pass /x/ to its
constructor. Since every thing is already converted to fns this
mechanism allows variables to be referenced down the line and solves
the free variable problem.

#+name: core-transformation-closure-conversion 
#+begin_src clojure :tangle no
  (defn lambda-defined? [fns env args body]
    (let [f (concat [env args] body)
          name (reduce (fn[h v]
                         (let [[_ n & r] v]
                           (if (= r f) n))) nil @fns)]
      (when name
        (apply list 'lambda-object name env))))
  
  (defn define-lambda [fns env args body]
    (let [n (gensym)]
      (dosync (alter fns conj (concat ['define-lambda n env args] body)))
      (apply list 'lambda-object n env)))
  
  (defn closure-conversion
    ([form]
       (let [fns (ref [])
             form (closure-conversion form fns)]
         (vector->list (concat form @fns))))
    ([form fns & env]
       (morph-form form
                   (is-form? 'fn)
                   (fn [[_ args & body]]
                     (let [env (if (nil? env) '() (first env))
                           body (closure-conversion body fns (concat args env))]
                       (if-let [n (lambda-defined? fns env args body)]
                         n
                         (define-lambda fns env args body)))))))
#+end_src

*** Symbol Conversion

Next step converts all symbols that are not legal C++ identifiers
into valid ones.

#+name: core-transformation-symbol-conversion
#+begin_src clojure :tangle no
  (defn symbol-conversion [form]
    (let [c (comp #(symbol (clojure.string/escape
                            (str %)
                            {\- \_ \* "_star_" \+ "_plus_" \/ "_slash_"
                             \< "_lt_" \> "_gt_" \= "_eq_" \? "_QMARK_"
                             \! "_BANG_"}))
                  #(cond (= 'not %) '_not_
                         :default %))]
      (morph-form form symbol? c)))

#+end_src

*** Replace Fn Call Sites

Final step replaces all functions calls with new function
objects /define_lambda/ are renamed to /fn/. This removes all globals
variables unless the /fn/ defined is a closure. In which case it is
left as a global variable and the class implementation is prepended
with the global name for readability.

#+BEGIN_EXAMPLE
  (process '((let [a 1]
               (defn adder [x]
                 (+ a x)))
             (defn my-inc [x] (+ 1 x))))

  (replace-fn-call-sites
   '((define_lambda G__3885 (a) (x) (_plus_ a x))
     (define_lambda G__3886 () (a) (def adder (lambda_object G__3885 a)))
     (define_lambda G__3887 () () (define_var a 1) ((lambda_object G__3886) a))
     (define_lambda G__3888 () (x) (_plus_ 1 x))
     ((lambda_object G__3887))
     (def my_inc (lambda_object G__3888))))

  ((define_lambda adder_G__3885 (a) (x) (_plus_ a x))
   (define_lambda G__3886 () (a) (def adder (lambda_object adder_G__3885 a)))
   (define_lambda G__3887 () () (define_var a 1) ((lambda_object G__3886) a))
   (define_lambda my_inc () (x) (_plus_ 1 x))
   ((lambda_object G__3887)))
#+END_EXAMPLE

#+name: core-transformation-symbol-conversion
#+begin_src clojure :tangle no
  (defn select-def-fn [form]
    (->> (select-form form (is-form? 'def))
         (filter (fn [[_ name val]]
                   (and (seq? val)
                        (= 'lambda_object (first val)))))))

  (defn replace-fn-call-sites-pure [form fn-defs fn-table]
    (let [no-global-fn (reduce (fn[h v]
                                 (remove-form h (fn [f]
                                                  (and (seq? f)
                                                       (= 'def (first f))
                                                       (every? true? (map = f v))))))
                               form fn-defs)        
          embeded-fn-calls (reduce (fn[h [name gensym]]
                                     (morph-form h symbol?
                                                 (fn [f]
                                                   (if (= f name)
                                                     (list 'lambda_object gensym)
                                                     f))))
                                   no-global-fn fn-table)
          embed-fn-names (reduce (fn[h [name gensym]]
                                   (morph-form h symbol?
                                               (fn [f]
                                                 (if (= f gensym)
                                                   name
                                                   f))))
                                 embeded-fn-calls fn-table)]
      embed-fn-names))

  (defn replace-fn-call-sites [form]
    (let [pure-fn-defs (->> (select-def-fn form)
                            (filter #(= 2 (-> % last count))))
          pure-fn-table (map (fn [[_ name [_ gensym]]] [name gensym]) pure-fn-defs)
          form (replace-fn-call-sites-pure form pure-fn-defs pure-fn-table)
          closure-fn-defs (->> (select-def-fn form)
                               (filter #(not= 2 (-> % last count))))
          closure-fn-table (map (fn [[_ name [_ gensym]]] [name gensym]) closure-fn-defs)]
      (reduce (fn[h [name gensym]]
                (morph-form h symbol?
                            (fn [f]
                              (if (= f gensym)
                                (symbol (str name "_" gensym))
                                f))))
              form closure-fn-table)))
#+end_src

*** Helpers

During each pass we iterate over the nodes in the form using
/morph-form/ and /remove-form/, they both take a s-expression and a
predicate if the predicate returns true, morph-form will call /f/
passing the current node as an argument and replace that node with
/f/'s return value, remove-form on the other hand does what its name
suggests and removes the node when predicate returns true.

#+name: core-transformation-form-fns
#+begin_src clojure :tangle no
  (defn morph-form [tree pred f]
    (loop [loc (zip/seq-zip tree)]
      (if (zip/end? loc)
        (zip/root loc)
        (recur
         (zip/next
          (if (pred (zip/node loc))
            (zip/replace loc (f (zip/node loc)))
            loc))))))

  (defn remove-form [tree pred]
    (loop [loc (zip/seq-zip tree)]
      (if (zip/end? loc)
        (zip/root loc)
        (recur
         (zip/next
          (if (pred (zip/node loc))
            (zip/remove loc)
            loc))))))

  (defn select-form [tree pred]
    (loop [loc (zip/seq-zip tree)
           nodes []]
      (if (zip/end? loc)
        nodes
        (recur
         (zip/next loc)
         (if (pred (zip/node loc))
           (conj nodes (zip/node loc))
           nodes)))))

  (defn is-form? [& s]
    (fn [f]
      (and (seq? f)
           (some true? (map #(= % (first f)) s)))))
#+end_src

*** Tests

#+name: compiler-transformation-tests
#+begin_src clojure :tangle no
  (deftest transformation-test
    (is (seq? (vector->list [1 2 [2 [5 4] 3]])))
    (is (= (symbol-conversion '(make-adder 2)) '(make_adder 2)))
    (is (= (symbol-conversion '(make-adder* 2)) '(make_adder_star_ 2)))

    (let [form (closure-conversion '((def make-adder (fn [n] (fn [x] (+ x n))))))]
      (is (= (first (second form)) 'define-lambda))
      (is (= (last (second form)) '(+ x n)))
      (is (= (second (first form)) 'make-adder))
      (is (= (first (first form)) 'def))))

  (deftest transformation-macro-test
    (is (= "1 1 1 true false true true true (3 3)012343"
           (capture-output '((defmacro my-when [test & body]
                               (list 'if test (cons 'do body)))

                             (defmacro some-list [a]
                               (let [a (inc a)]
                                 (list 'list a a)))
                             
                             (print (my-when (< 2 3) 1)

                                    (when (< 2 3) 1)

                                    (when (< 2 3) 1)
                                    
                                    (let [a 1]
                                      (and (> a 0)
                                           (< a 10)))

                                    (let [a 11]
                                      (and (> a 0)
                                           (< a 10)))
                                    
                                    (and true true)

                                    (or true false)

                                    (let [a 11]
                                      (or (> a 0)
                                          (< a 10)))

                                    (some-list 2))
                             
                             (dotimes [i 5] (print i))
                             (let [a 1]
                               (defn adder [x]
                                 (+ a x)))
                             (defn my-inc [x] (+ 1 (adder x)))
                             (print (my-inc 1)))))))

  (deftest transformation-special-forms-test
    (is (= "10 89 11 3 1 5 51111111111"
           (capture-output '((def make-adder
                               (fn [n] (fn [x] (+ x n))))
                             (def adder
                               (make-adder 1))

                             (def fibo (fn [n]
                                         (if (< n 2)
                                           1
                                           (+ (fibo (- n 1))
                                              (fibo (- n 2))))))

                             (def adder-let (let [a 1
                                                  b 2]
                                              (fn [n] (+ a b n))))

                             (def adder-let-2 (fn [n]
                                                (let [a 1
                                                      b 2]
                                                  (+ a b n))))

                             (native-declare "int i = 0;")
                             (defn inc-int [] "__result =  NEW_NUMBER(i++);")
                             
                             (print (adder 9)

                                    (fibo 10)

                                    ((fn [n] (+ n 1)) 10)

                                    (((fn [n] (fn [n] n)) 3) 3)

                                    (if (< 2 3 4 5 6)
                                      (do 1)
                                      (do 2))

                                    (adder-let 2)

                                    (adder-let-2 2))
                             
                             (while (< (inc-int) 10)
                               (print 1)))))))
#+end_src

** Code Generation

At this point all we need is a multi method that will emit correct
string based on the form.

#+name: core-code-generation-emit
#+begin_src clojure :tangle no  
  (defmulti emit (fn [form _]
                   (cond (is-special-form? 'defobject form) 'defobject
                         (is-special-form? 'define_lambda form) 'define_lambda
                         (is-special-form? 'lambda_object form) 'lambda_object
                         (is-special-form? 'define_var form) 'define_var
                         (is-special-form? 'native_declare form) 'native_declare
                         (is-special-form? 'native_define form) 'native_define
                         (is-special-form? 'if form) 'if
                         (is-special-form? 'def form) 'def
                         (to-str? form) :to-str
                         (keyword? form) :keyword
                         (number? form) :number
                         (nil? form) :nil
                         (char? form) :char
                         (string? form) :string
                         (or (true? form) (false? form)) :boolean
                         (seq? form) :sequence)))
#+end_src

Without preprocessing following forms,

#+begin_src clojure :tangle no
  (emit '(list 1 2 3) (ref {}))
  
  (emit '(+ 1 2) (ref {}))
  
  (emit '(if (< a b)
           b a)
        (ref {}))
#+end_src

would evaluate to,

#+begin_example
  "INVOKE(VAR(list), VAR(3),VAR(2),VAR(1))"
  "INVOKE(VAR(+), VAR(2),VAR(1))"
  "(BOOLEAN(INVOKE(VAR(<), VAR(b),VAR(a)))->asBool() ? (VAR)VAR(b) : (VAR)VAR(a))"  
#+end_example

So the actual compilation will just map emit to all forms passed and
/string-template/ will handle the job of putting them into an empty
C++ skeleton.

#+name: core-code-generation-emit-source
#+begin_src clojure :tangle no
  (defn emit-source [form]
    (let [state (ref {:lambdas [] :symbol-table #{} :native-declarations [] :native-defines []})
          body (doall (map #(emit % state) (process form)))]
      (assoc @state :body body)))
#+end_src

*** Code Emitting
**** Object Types

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit :to-str [form state] (str form))

  (defmethod emit :char [form state] (str "NEW_CHARACTER('" form "')"))

  (defmethod emit :string [form state] (str "NEW_STRING(\"" form "\")"))

  (defmethod emit :boolean [form state] (str "NEW_BOOLEAN(" form ")"))

  (defmethod emit :nil [form state] "NIL")

  (defmethod emit :keyword [form state]
    (str "NEW_KEYWORD(" (reduce (fn[h v] (+ h (int v))) 0 (str form)) ")"))

  (defmethod emit :number [form state]
    (str "NEW_NUMBER("form (if (float? form) "f") ")"))

  (defmethod emit :sequence [[fn & args] state]
    (invoke-lambda (emit fn state) (doall (map #(emit % state) args))))

  (defmethod emit 'define_var [[_ name form] state]
    (str "VAR " name " = " (emit form state)))

  (defmethod emit 'native_declare [[_ declaration] state]
    (append-to! state [:native-declarations] declaration) "")

  (defmethod emit 'native_define [[_ define] state]
    (append-to! state [:native-defines] define) "")
#+end_src

**** Lambdas

List Destructuring,

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defn destructure-set-var [val arg accesor]
    (if (not= val '_)
      (str "VAR " val " = "
           (reduce (fn[h v] (str v "(" h ")")) arg accesor))
      ""))

  (defn destructure-arguments [args name]
    (let [[args va-args] (if (some #{'&} args)
                           (split-at (.indexOf args '&) args)
                           [args []])
          args (->> args
                    (map-indexed (fn [pos val]
                                   (vector pos val)))
                    (reduce (fn[h [pos val]]
                              (let [accesor (flatten [(repeat pos "REST") "FIRST"])]
                                (if (coll? val)
                                  (conj h (destructure-arguments
                                           val (reduce (fn[h v] (str v "(" h ")")) name accesor)))
                                  (conj h (destructure-set-var val name accesor))))) []))]
      [args (if (empty? va-args)
              []
              (destructure-set-var
               (last va-args) name (repeat (count args) "REST")))]))

  (defn destructure-lambda [args]
    (flatten (destructure-arguments args "_args_")))
#+end_src

#+name: clojure-destructure-tests
#+begin_src clojure :tangle no
  (deftest destructure-test
    (is (= "(1 2 3) 2 3 ((1 2 3))"
           (capture-output '((defn destructure-test-1 [[a b c]]
                               (list a b c))
                             (defn destructure-test-2 [[a [b] c]]
                               b)
                             (defn destructure-test-3 [[a [_ b] c]]
                               b)
                             (defn destructure-test-4 [& a]
                               a)
                             (print (destructure-test-1 (list 1 2 3))
                                    (destructure-test-2 (list 1 (list 2) 3))
                                    (destructure-test-3 (list 1 (list 2 3) 3))
                                    (destructure-test-4 (list 1 2 3))))))))
#+end_src

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit 'lambda_object [[_ name & env] state]
    (new-lambda name (filter #(not (= '& %)) env)))

  (defmethod emit 'define_lambda [[_ name env args & body] state]
    (let [native-declarations (filter #(and (seq? %)
                                            (= (first %) 'native_declare)) body)
          body (filter #(not (and (seq? %)
                                  (= (first %) 'native_declare))) body)
          body (cond  (empty? body) ["NIL"]
                      (and (= 1 (count body))
                           (string? (first body)))
                      ["VAR __result" body "__result"]
                      :default (doall (map #(emit % state) body)))
          env (filter #(not (= '& %)) env)]
      (doseq [dec native-declarations] 
        (emit dec state))
      (append-to! state [:lambdas] {:name name :env env
                                    :args (destructure-lambda args)
                                    :body body}) ""))
#+end_src

**** Misc

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit 'defobject [[_ name & spec] state]
    (append-to! state [:native-declarations] (declare-object name spec))
    "")

  (defmethod emit 'if [[_ cond t f] state]
    (let [cond (emit cond state)
          t (emit t state)
          f (if (nil? f) "NIL" (emit f state))]
      (if-statement cond t f)))

  (defmethod emit 'def [[_ name & form] state]
    (append-to! state [:symbol-table] name)
    (str "(" name " = " (apply str (doall (map #(emit % state) form))) ")"))
#+end_src

*** Code Templates

#+name: code-templates
#+begin_src clojure :tangle no
  (defn new-lambda [n e]
    (let [view (create-view "(FN($name$$env:{,$it$}$))")]
      (fill-view! view "name" n)
      (fill-view! view "env" e)
      (render-view view)))

  (defn invoke-lambda [n args]
    (let [view (create-view "INVOKE($lambda$, $args:{$it$} ;separator=\",\"$)")]
      (fill-view! view "lambda" n)
      (fill-view! view "args" (reverse args))
      (render-view view)))

  (defn if-statement [cond t f]
    (apply str "(BOOLEAN(" cond ")->asBool() ? " t " : " f ")"))

  (defn declare-lambdas [lambdas]
    (let [view (create-view
                
    "$lambdas: {lambda|
        class $lambda.name$ : public Lambda{

        $lambda.env:{VAR $it$;} ;separator=\"\n\"$

        public:

          $lambda.name$ ($lambda.env:{VAR $it$} ;separator=\",\"$){ 
             $lambda.env:{this->$it$ = $it$;} ;separator=\"\n\"$
          }

          VAR invoke (VAR _args_){
            $lambda.args:{args | $args$; } ;separator=\"\n\"$

            $trunc(lambda.body):{$it$;} ;separator=\"\n\"$
            return $last(lambda.body):{ $it$;} ;separator=\"\n\"$
          }
        };};separator=\"\n\n\"$")]
      (fill-view! view "lambdas" lambdas)
      (render-view view)))

  (defn declare-object [name body]
    (let [specs (into {} (map #(vector (first %) (rest %)) body))
          interface (if (nil? (specs 'interface))
                      "Object"
                      (apply str (rest (str (first (specs 'interface))))))
          interface-only (cond (specs 'interface) false
                               (empty? (specs 'new)) true
                               :defaul false)
          view (create-view "
      namespace ferret{

       $if(object_type)$
         int $type$_TYPE = $type_val$;
       $endif$

       class $name$ : public $interface$ {
       public:

         $data:{$it$;} ;separator=\"\n\"$

         $interfaces:{virtual $it$ = 0;} ;separator=\"\n\"$

         $new:{it | $name$($first(it)$){
           $first(rest(it))$
         }} ;separator=\"\n\"$

         $if(object_type)$
          int getType(){ return $type$_TYPE;}
         $endif$

         $if(equals)$
          var equals(var o){
           $equals$
          }
         $endif$

         $if(toOutputStream)$
  #if !defined(DISABLE_OUTPUT_STREAM)
          var toOutputStream(){
           $toOutputStream$
          }
  #endif
         $endif$

         $fns:{it | $first(it)$($first(rest(it))$){
           $first(rest(rest(it)))$
         }} ;separator=\"\n\"$

         $ifdef_fns:{it | #$first(it)$
           $first(rest(it))$($first(rest(rest(it)))$){
           $first(rest(rest(rest(it))))$
         }
       #endif} ;separator=\"\n\"$
       };
       $post_code$
      }")]
      (fill-view! view "name" name)
      (fill-view! view "interface" interface)
      (fill-view! view "interface_only" interface-only)
      (fill-view! view "object_type" (cond (specs 'force_type) true
                                           interface-only false
                                           :default true))
      (fill-view! view "type" (.toUpperCase (str name)))
      (fill-view! view "type_val" (gensym ""))
      (fill-view! view "data" (specs 'data))
      (fill-view! view "new" (specs 'new))
      (fill-view! view "equals" (first (specs 'equals)))
      (fill-view! view "toOutputStream" (first (specs 'toOutputStream)))
      (fill-view! view "interfaces" (specs 'interfaces))
      (fill-view! view "fns" (filter #(= 3 (count %)) (specs 'fns)))
      (fill-view! view "ifdef_fns" (filter #(= 4 (count %)) (specs 'fns)))
      (fill-view! view "post_code" (first (specs 'post_code)))
      (render-view view)))

  (defn solution-template [source]
    (let [{:keys [body lambdas symbol-table native-declarations native-defines]} source
          view (create-view "
      $native_defines:{$it$} ;separator=\"\n\"$

      $object_interface$

      #ifdef GNU_GCC
        VAR _star_command_line_args_star_;
      #endif

      $symbols:{VAR $it$;} ;separator=\"\n\"$

      $native_declarations:{$it$} ;separator=\"\n\"$      

      namespace ferret{
        $lambdas:{$it$} ;separator=\"\n\"$
      }

      namespace ferret{
        void ProgramRun(){
         $body:{$it$;} ;separator=\"\n\"$ 
        }
      }

    #if !defined(DISABLE_MAIN_FUNCTION)
      int main(int argc, char* argv[]){
      
        INIT_ENV

      #ifdef GNU_GCC
        _star_command_line_args_star_ = NEW_SEQUENCE();
        for (int i = argc - 1; i > -1 ; i--)
          CONS(_star_command_line_args_star_,NEW_STRING(argv[i]));
      #endif

        ferret::ProgramRun();      
        return 0;
      }
    #endif")]
      (fill-view! view "object_interface" (read-from-url "Object.cpp"))
      (fill-view! view "body" (filter #(not (empty? %)) body))
      (fill-view! view "lambdas" (declare-lambdas lambdas))
      (fill-view! view "symbols" symbol-table)
      (fill-view! view "native_declarations" native-declarations)
      (fill-view! view "native_defines" native-defines)
      (render-view view)))
#+end_src    

* Runtime
** Native

On the C++ side we define our own object system, which includes the
following types,

Object Casting macros,

#+name: runtime-native-object-casting-macros
#+begin_src c++ :tangle no
  #define NIL (VAR())
  #define OBJECT(v) static_cast<ferret::Object*>(v.get())
  #define POINTER(v) static_cast<ferret::Pointer*>(v.get())
  #define NUMBER(v) static_cast<ferret::Number*>(v.get())
  #define CHARACTER(v) static_cast<ferret::Character*>(v.get())
  #define BOOLEAN(v) static_cast<ferret::Boolean*>(v.get())
  #define KEYWORD(v) static_cast<ferret::Keyword*>(v.get())
  #define ISEEKABLE(v) static_cast<ferret::ISeekable*>(v.get())
  #define CELL(v) static_cast<ferret::Cell*>(v.get())
  #define SEQUENCE(v) static_cast<ferret::Sequence*>(v.get())
  #define STRING(v) static_cast<ferret::String*>(v.get())
  #define LAMBDA(v) static_cast<ferret::Lambda*>(v.get())
  #define ATOM(v) static_cast<ferret::Atom*>(v.get())

  #define IS_NIL(o) (o.get() == NULL)
  #define IS_NOT_NIL(o) (o.get() != NULL)
  #define IS_TYPE(o,type) (OBJECT(o)->getType() == type)
#+end_src

*** Memory Pool

    When,

#+BEGIN_EXAMPLE
  MEMORY_POOL_SIZE
#+END_EXAMPLE

    is defined ferret program will use a memory pool instead of
    /mallac/,/free/, depending on the pool size ferret will allocate 
    /N x size_t/ bytes of memory on stack and all object creation
    happens in this memory pool useful when working with very limited
    amount of memory, such as micro controllers where you want
    complete control over the memory and you need deterministic timing
    requirements. Memory pooling also prevents heap fragmentation.

    (This should not be used in a multi threaded program.)

    For every page of memory allocated there is overhead of one
    /bool/ and one pointer to size_t.

    When /allocate/ is called the pool will scan the memory pool using
    the /used/ bool array to find a block of memory big enough to
    satisfy the request. If found, it will the mark the region as used and
    return a pointer from /pages/ array to the user which points to
    the memory block. First page of the memory block is used for book
    keeping information, it holds the amount of memory allocated.

    When a free request is received, we resolve the pointer in to the
    memory pool read the book keeping information on how much memory
    is allocated to this pointer and set these pages to unused.

    Memory pool has several advantages, it will avoid fragmentation,
    function related to each other will always keep their data close
    to each other in the array which improves data locality.

#+name: runtime-native-memory-pool
#+begin_src c++ :tangle no
  #ifdef MEMORY_POOL_SIZE
  template<typename PageSize, size_t poolSize>
  class MemoryPool{
  public:
    PageSize pool[poolSize];
    bool used[poolSize];
    PageSize* pages[poolSize];
    
    size_t calculateNeededPages(size_t size){
      float f = (float) (((float)size) / ((float)sizeof(PageSize))) ;
      return ((size_t) ceil(f)) ;
    }
      
    MemoryPool(){
      for(size_t i = 0; i < poolSize; i++){
        pool[i] = 0;
        used[i] = false;
        pages[i] = &pool[i];
      }
    }
    
    bool isPageRangeUsable(size_t begin,size_t end){
      for(int i=begin; i < end; i++)
        if (used[i] == true)
          return false;
      return true;
    }
    
    size_t nextAvaliblePage(size_t offset){
      for(int i=offset; i < poolSize; i++)
        if (used[i] == false)
          return i;
      return poolSize;
    }
      
    size_t findPage(size_t reqSize){
      size_t pagesNeeded = calculateNeededPages(reqSize);
      size_t offset = 0;
    
      for(;;){
        int page = nextAvaliblePage(offset);
    
        if ((page + pagesNeeded) > poolSize)
          break;
          
        if (isPageRangeUsable(page,(page + pagesNeeded)) == true)
          return page;

        offset++;
      }
        
      return -1;
    }
      
    void *allocate(size_t reqSize){
      reqSize += 1;
      size_t page = findPage(reqSize);
    
      if ( page == -1)
        return NULL;
    
      size_t length = calculateNeededPages(reqSize);
    
      pool[page] = reqSize;
      for(size_t i = page; i < (page+length); i++)
        used[i] = true;
        
      return pages[page+1];
    }
    
    void free(void *p){
      PageSize* ptr = static_cast<PageSize*>(p);
      ptrdiff_t index = (ptr - pool) -1;
      size_t length = calculateNeededPages(pool[index]);
        
      for(size_t i = index ; i < (index+length); i++)
        used[i] = false;
    }
  };

  MemoryPool<size_t,MEMORY_POOL_SIZE> ProgramMemory;
  #endif
#+end_src

#+name: runtime-clojure-memory-pool-tests
#+begin_src clojure :tangle no
  (deftest memory-pool-test
    (is (= "0 3 8 3 1 1 1 1 "
           (capture-output
            '((native-define "#define MEMORY_POOL_SIZE 2048")
              (native-declare "ferret::MemoryPool<size_t,10> mem;")
              (native-declare "void* ptr;")
              ((fn [] "std::cout << mem.nextAvaliblePage(0) << \" \";"))
              ((fn [] "mem.allocate(sizeof(size_t)*2);"))
              ((fn [] "std::cout << mem.nextAvaliblePage(0) << \" \";"))
              ((fn [] "ptr = mem.allocate(sizeof(size_t)*4);"))
              ((fn [] "std::cout << mem.nextAvaliblePage(2) << \" \";"))
              ((fn [] "mem.free(ptr);"))
              ((fn [] "std::cout << mem.nextAvaliblePage(2) << \" \";"))
              ((fn [] "std::cout << (NULL == mem.allocate(sizeof(size_t)*40)) << \" \";"))
              ((fn [] "std::cout << (NULL != mem.allocate(sizeof(size_t)*6)) << \" \";"))
              ((fn [] "std::cout << (NULL == mem.allocate(sizeof(size_t)*1)) << \" \";"))
              ((fn [] "std::cout << (NULL == mem.allocate(sizeof(size_t)*10)) << \" \";")))))))
#+end_src

*** Object

#+name: runtime-native-object
#+begin_src c++ :tangle no
  class Object{
  public:
    Object() : refCount(0) {}
    virtual ~Object() {};
    
    virtual int getType() = 0;
    
  #if !defined(DISABLE_OUTPUT_STREAM)
    virtual var toOutputStream() = 0;
  #endif
    
    virtual var equals(var o) = 0;
    
    void addRef() { refCount++; }
    bool subRef() { return (--refCount <= 0); }
    
    
    void* operator new(size_t size){
  #ifdef MEMORY_POOL_SIZE
      return ProgramMemory.allocate(size);
  #else
      return malloc(size);
  #endif
    }
    
    void  operator delete(void * ptr){
  #ifdef MEMORY_POOL_SIZE
      ProgramMemory.free(ptr);
  #else
      free(ptr);
  #endif
    }
    
  private:
    int refCount;
  };
#+end_src

All our types are derived from the base Object type,(defining
new/delete is needed because in avr-gcc they are not defined.)

*** Pointer

#+name: runtime-clojure-pointer-object
#+begin_src clojure :tangle no
  (defobject Pointer
    (data "void* ptr")
    (new ("void* p" "ptr = p;"))
    (equals
     "return NEW_BOOLEAN(ptr == POINTER(o)->ptr);")
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"Pointer\"); return NIL;"))
#+end_src

#+name: runtime-native-iseekable-macros
#+begin_src c++ :tangle no
  #define NEW_POINTER(p) (VAR(new ferret::Pointer(p)))
  #define TO_POINTER(p,type) ((type *)POINTER(p)->ptr)
#+end_src

*** Number

Math configuration,

#+name: runtime-native-math-config
#+begin_src c++ :tangle no
  #define NUMBER_PRECISION 1000 //used when reading floats.
  #define NUMBER_DATA_TYPE int
  #define NUMBER_TYPE_FORMAT "%d"
#+end_src

#+name: runtime-clojure-number-object
#+begin_src clojure :tangle no
  (defobject Number
    (data "NUMBER_DATA_TYPE numerator"
          "NUMBER_DATA_TYPE denominator")
    (new ("NUMBER_DATA_TYPE x"
          "numerator = x; denominator = 1;")
         ("NUMBER_DATA_TYPE n, NUMBER_DATA_TYPE dn"
          "numerator = n; denominator = dn; simplificate();")
         ("float x"
          "float decimal = (x - (NUMBER_DATA_TYPE)x) * (float)NUMBER_PRECISION;
           NUMBER_DATA_TYPE integer = (NUMBER_DATA_TYPE)x;
           numerator = decimal + (integer * NUMBER_PRECISION);
           denominator = NUMBER_PRECISION;
           simplificate();"))
    (equals "int self_type = getType();
             int other_type = OBJECT(o)->getType();
             if (self_type == NUMBER_TYPE && other_type == NUMBER_TYPE)
               if (getNumerator() == 0 && NUMBER(o)->getNumerator() == 0)
                 return NEW_BOOLEAN(true);
               else
                 return NEW_BOOLEAN((getNumerator() == NUMBER(o)->getNumerator()) &&
                                    (getDenominator() == NUMBER(o)->getDenominator()));
             else
               return NEW_BOOLEAN(false);")
    (toOutputStream
     "if (denominator == 1)
        fprintf(OUTPUT_STREAM, NUMBER_TYPE_FORMAT, numerator);
      else if (numerator == 0)
        fprintf(OUTPUT_STREAM, \"0\");
      else{
        fprintf(OUTPUT_STREAM, NUMBER_TYPE_FORMAT,numerator);
        fprintf(OUTPUT_STREAM, \"/\");
        fprintf(OUTPUT_STREAM, NUMBER_TYPE_FORMAT,denominator);
      }
      return NIL;")
    
    (fns
      ("NUMBER_DATA_TYPE getNumerator" "" "return numerator;")
      ("NUMBER_DATA_TYPE getDenominator" "" "return denominator;")
      ("float floatValue" "" "return (float)numerator/(float)denominator;")
      ("int intValue" ""
       "if (denominator == 1)
          return (int)numerator;
        else
          return (int)floatValue();")
      ("void simplificate" ""
       "int commondivisor = 1;
        for(NUMBER_DATA_TYPE i=2;i<=MIN(ABS(numerator), ABS(denominator));i++)
          if( numerator%i == 0 && denominator%i == 0 )
            commondivisor = i;
        numerator /= commondivisor;
        denominator /= commondivisor;")
      ("~Number" "" "")))
#+end_src

#+name: runtime-native-math-config
#+begin_src c++ :tangle no
  #define TO_INT(i) (NUMBER(i)->intValue())

  #define NEW_NUMBER(i) (VAR(new ferret::Number(i)))
  #define NEW_RATIO(n,dn) (VAR(new ferret::Number(n,dn)))
#+end_src

*** Keyword

#+name: runtime-clojure-keyword-object
#+begin_src clojure :tangle no
  (defobject Keyword
    (data "int id")
    (new ("int b" "id=b;")
         ("const char * str"
          "id = 0;
           for (int i = 0; str[i] != '\\0'; i++){
             id = id + (int)str[i];
           }"))
    (equals
     "if (!IS_TYPE(o,KEYWORD_TYPE))
        return NEW_BOOLEAN(false);
      return NEW_BOOLEAN(id == KEYWORD(o)->id);")
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"%d\", id); return NIL;")
    (fns ("bool equals" "Keyword k"
          "return (id == k.id);")))
#+end_src

#+name: runtime-native-iseekable-macros
#+begin_src c++ :tangle no
  #define NEW_KEYWORD(k) (VAR(new ferret::Keyword(k)))
#+end_src

#+name: native-keyword-tests
#+begin_src clojure :tangle no
  (deftest native-keyword-test
    (is (= "true false true"
           (capture-output '((print (= :test :test)
                                    (= :test :other_test)
                                    ((fn [keyword]
                                       "__result = NEW_BOOLEAN(keyword.equals(NEW_KEYWORD(\":space\")))")
                                     :space)))))))
#+end_src

*** Character

#+name: runtime-clojure-character-object
#+begin_src clojure :tangle no
  (defobject Character
    (data "char value")
    (new ("char c" "value = c;"))
    (equals
     "if (!IS_TYPE(o,CHARACTER_TYPE))
        return NEW_BOOLEAN(false);
      return NEW_BOOLEAN(value == CHARACTER(o)->value);")
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"%c\",value); return NIL;"))
#+end_src

#+name: runtime-native-iseekable-macros
#+begin_src c++ :tangle no
  #define NEW_CHARACTER(c) (VAR(new ferret::Character(c)))
#+end_src

*** Seekable Interface

#+name: runtime-clojure-seekable-interface
#+begin_src clojure :tangle no
  (defobject ISeekable
    (interfaces "var cons(var x)"
                "var first()"
                "var rest()"
                "bool isEmpty()")
    (fns ("virtual ~ISeekable" "" "")))
#+end_src

#+name: runtime-native-iseekable-macros
#+begin_src c++ :tangle no
  #define FIRST(coll) (ISEEKABLE(coll)->first())
  #define REST(coll) (ISEEKABLE(coll)->rest())
  #define ITERATE(c,i) for(var i = c; !ISEEKABLE(i)->isEmpty(); i = REST(i))

  #define NEW_SEQUENCE() (VAR(new ferret::Sequence()))
  #define CONS(s,v) (s = ISEEKABLE(s)->cons(v))
#+end_src

*** Sequence

#+name: runtime-clojure-cell-object
#+begin_src clojure :tangle no
  (defobject Cell
    (data "var data"
          "var next")
    (new ("" "")
         ("var d, var n" "data = d; next = n;"))
    (equals "if (!IS_TYPE(o,CELL_TYPE))
              return NEW_BOOLEAN(false);
             return NEW_BOOLEAN(data.equals(o));")
    (toOutputStream
     "OBJECT(data)->toOutputStream(); return NIL;"))
#+end_src

#+name: runtime-clojure-sequence-object
#+begin_src clojure :tangle no
  (defobject Sequence
    (interface :ISeekable)
    (data "var head")
    (new ("" "head = NULL;")
         ("var h" "head = h;"))
    (equals
     "if (!IS_TYPE(o,SEQUENCE_TYPE))
       return NEW_BOOLEAN(false);

      if(IS_NIL(head) && IS_NIL(SEQUENCE(o)->head))
        return NEW_BOOLEAN(true);

      var itOther = o;
      ITERATE(this,it){
        if (IS_NIL(itOther) || FIRST(it).equals(FIRST(itOther))  == false)
          return NEW_BOOLEAN(false);
        itOther = REST(itOther);
      }
      return NEW_BOOLEAN(true);")
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"(\");
      if (IS_NOT_NIL(head)){ 
        var f = this->first();
        f.toOutputStream();
        var r = this->rest();
        ITERATE(r,it){
          fprintf(OUTPUT_STREAM, \" \");
          FIRST(it).toOutputStream();
        }
      }
      fprintf(OUTPUT_STREAM, \")\");
      return NIL;")

    (fns
     ("var cons" "var x"
      "return var(new Sequence(var(new Cell(x,head))));")
     ("var first" ""
      "if (IS_NIL(head))
         return NIL;
        else
         return CELL(head)->data;")
     ("var rest" ""
      "if (IS_NIL(head) || IS_NIL(CELL(head)->next))
         return NEW_SEQUENCE();
        else
         return var(new Sequence(CELL(head)->next));")
     ("bool isEmpty" ""
      "return (IS_NIL(head));"))
    (post-code
     "ferret::var& ferret::var::operator, (const var& m){
        ,*this = static_cast<ferret::Sequence*>(m_ptr)->cons(m);
        return *this;
      }"))
#+end_src

*** String

#+name: runtime-clojure-string-object
#+begin_src clojure :tangle no
  (defobject String
    (interface :ISeekable)
    (data "var data")
    (new (""
          "data = NULL;")
         ("var s"
          "data = s;")
         ("const char * str"
          "int length = 0;
           for (length = 0; str[length] != '\\0'; length++);
           length--;
           var s = var(new Sequence());
           for (int i = length; i >= 0; i--)
             s = ISEEKABLE(s)->cons(VAR(new ferret::Character(str[i])));
           data = s;"))
    (equals
     "if (!IS_TYPE(o,STRING_TYPE))
       return NEW_BOOLEAN(false);
      return NEW_BOOLEAN(data.equals(STRING(o)->data));")
    (toOutputStream
     "ITERATE(data,it){ FIRST(it).toOutputStream(); }
      return NIL;")
    (fns
     ("var cons" "var x"
      "return ISEEKABLE(data)->cons(x);")
     ("var first" ""
      "return FIRST(data);")
     ("var rest" ""
      "return REST(data);")
     ("bool isEmpty" ""
      "return ISEEKABLE(data)->isEmpty();")
     ("ifdef GNU_GCC"
      "std::string toString" ""
      "std::stringstream ss;
       ITERATE(data,it){ss << CHARACTER(FIRST(it))->value;}
       return ss.str();")))
#+end_src

#+name: runtime-native-iseekable-macros
#+begin_src c++ :tangle no
  #define NEW_STRING(s) (VAR(new ferret::String(s)))
  #define TO_C_STR(s) (STRING(s)->toString().c_str())
#+end_src

#+name: native-string-tests
#+begin_src clojure :tangle no
  (deftest native-string-test
    (is (= "Some String false true false true"
           (capture-output '((print "Some String"
                                    (= "Some String" "Other String")
                                    (= "Some String" "Some String")
                                    (= "Some String" 1)
                                    ((fn [str] "__result = NEW_BOOLEAN((STRING(str)->toString() == \"String\"))")
                                     "String")
                                    ))))))
#+end_src
*** Boolean

#+name: runtime-clojure-boolean-object
#+begin_src clojure :tangle no
  (defobject Boolean
    (data "bool value")
    (new ("bool b" "value = b;"))
    (equals "if (!IS_TYPE(o,BOOLEAN_TYPE))
               return NEW_BOOLEAN(false);
             return NEW_BOOLEAN(value == BOOLEAN(o)->asBool());")
    (toOutputStream
     "if (value)
        fprintf(OUTPUT_STREAM, \"true\"); 
      else
      fprintf(OUTPUT_STREAM, \"false\"); 
      return NIL;")
    
    (fns
     ("bool asBool" "" "return value;"))
    
    (post-code "
    bool var::equals (var rhs){
      if (get() == rhs.get())
        return true;
      else
        return BOOLEAN(get()->equals(rhs))->asBool();
    }"))
#+end_src

#+name: runtime-native-iseekable-macros
#+begin_src c++ :tangle no
  #define NEW_BOOLEAN(b) (VAR(new ferret::Boolean(b)))
#+end_src

*** Atom

#+name: runtime-clojure-atom-object
#+begin_src clojure :tangle no
  (defobject Atom
    (data "var data"
          "#if defined(GNU_GCC)
            pthread_mutex_t lock;
           #endif \n")
    (new ("var d"
          "data = d;
           #if defined(GNU_GCC)
            pthread_mutex_init(&lock, NULL);
           #endif"))
    (equals "if (!IS_TYPE(o,ATOM_TYPE))
                 return NEW_BOOLEAN(false);
               return NEW_BOOLEAN(this == ATOM(o));")
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"atom <\"); 
      data.toOutputStream();
      fprintf(OUTPUT_STREAM, \">\"); 
      return NIL;")
    (fns
     ("~Atom" ""
      "#if defined(GNU_GCC)
           pthread_mutex_destroy(&lock);
       #endif")
     ("var swap" "var f,var args"
      "#if defined(GNU_GCC)
         pthread_mutex_lock(&lock);
       #endif

       CONS(args,data);
       data = LAMBDA(f)->invoke(args);

      #if defined(GNU_GCC)
         pthread_mutex_unlock(&lock);
      #endif

      return data;")))
#+end_src

#+name: runtime-clojure-atom-object
#+begin_src clojure :tangle no
  (defn atom [x]
    "__result = NEW_ATOM(x)")

  (defn swap! [a f & args]
    "__result = ATOM(a)->swap(f,args);")

  (defn reset! [a newval]
    (swap! a (fn [_ v] v) newval))

  (defn deref [a]
    "__result = ATOM(a)->data;")
#+end_src

#+name: runtime-native-iseekable-macros
#+begin_src c++ :tangle no
  #define NEW_ATOM(a) (VAR(new ferret::Atom(a)))
#+end_src

#+name: runtime-native-atom-tests
#+begin_src clojure :tangle no
  (deftest atom-tests
    (is (= "nil12(1 2 3)6truefalsefalse"
           (capture-output '((let [a (atom nil)
                                   b (atom nil)]
                               (print (deref a))
                               (reset! a 1)
                               (print (deref a))
                               (swap! a inc)
                               (print (deref a))
                               (reset! a (list 1 2 3))
                               (print (deref a))
                               (swap! a (fn [l] (reduce + l)))
                               (print (deref a))
                               (print (= a a))
                               (print (= a b))
                               (print (= a 1))))))))
#+end_src

*** Lambda

except functors, they derive from the class Lambda, which has a single
invoke method that takes a sequence of vars as argument, this allows us
to execute them in a uniform fashion.

#+name: runtime-clojure-lambda-interface
#+begin_src clojure :tangle no
  (defobject Lambda
    (interfaces "var invoke(var args)")
    (equals "if (!IS_TYPE(o,LAMBDA_TYPE))
                 return NEW_BOOLEAN(false);
               return NEW_BOOLEAN(this == LAMBDA(o));")
    (toOutputStream
     "fprintf(OUTPUT_STREAM, \"lambda\"); return NIL;")
    (force-type true))
#+end_src

Function invocation macros,

#+name: runtime-native-lambda-invoke-macros
#+begin_src c++ :tangle no
  #define VA_ARGS(...) , ##__VA_ARGS__
  #define INVOKE(f,...) LAMBDA(f)->invoke((ferret::var(new ferret::Sequence()) VA_ARGS(__VA_ARGS__)))
  #define FN(f,...) ferret::var(new ferret::f(__VA_ARGS__))
#+end_src

#+name: native-lambda-test
#+begin_src clojure :tangle no
  (deftest native-lambda-test
    (is (= "true false true false"
           (capture-output '((let [f1 (fn [])
                                   f2 (fn [])]
                               (print (= f1 f1)
                                      (= f1 f2)
                                      (= f1 (do f1))
                                      (= f2 (do f1)))))))))
#+end_src

*** var

Garbage collection is handled by reference counting, a /var/ holds a
pointer to an Object, everything is passed around as /vars/ it is
responsible for incrementing/decrementing the reference count, when it
reaches zero it will automatically free the Object. 

#+name: runtime-native-var
#+begin_src c++ :tangle no
  class var{
  public:
    var(Object* ptr=0) : m_ptr(ptr) { addRef(); }

    var(const var& p) : m_ptr(p.m_ptr) { addRef(); }
      
    ~var() { subRef(); }
      
    var& operator= (const var& p){
      return *this = p.m_ptr;
    }

    bool equals (var rhs);
      
    var& operator= (Object* ptr){
      if (m_ptr != ptr){
        subRef();
        m_ptr=ptr;
        addRef();
      }
      return *this;
    }
      
    var& operator, (const var& m);

  #if !defined(DISABLE_OUTPUT_STREAM)
    var toOutputStream() {
      if (m_ptr != NULL )
        m_ptr->toOutputStream();
      else
        fprintf(OUTPUT_STREAM, "nil");
      return var();
    }
  #endif
        
    Object* get() { return m_ptr; }
      
  private:
    void addRef(){
      // Only change if non-null
      if (m_ptr) m_ptr->addRef();
    }
      
    void subRef(){
      // Only change if non-null
      if (m_ptr){
        // Subtract and test if this was the last pointer.
        if (m_ptr->subRef()){
          delete m_ptr;
          m_ptr=0;
        }
      }
    }
      
    Object* m_ptr;
  };
#+end_src

*** Program Header

    Some options can be configured using /#define/ directives, these
    can be defined using /native-define/ from program code.

    When,

#+BEGIN_EXAMPLE
  #define MEMORY_POOL_SIZE 2048
#+END_EXAMPLE

    is defined program will will use a memory pool that's /2048 x size_t/.
    
    By default Numbers use int to hold data use,

#+BEGIN_EXAMPLE
  #define NUMBER_DATA_TYPE long
  #define NUMBER_DATA_TYPE_FORMAT "%ld"
#+END_EXAMPLE

    to switch to longs for number data.

    To disable output stream (usefull on micro controllers to reduce
    code size.) use,

#+BEGIN_EXAMPLE
  #define DISABLE_OUTPUT_STREAM true
#+END_EXAMPLE

    To disable main use,

#+BEGIN_EXAMPLE
  #define DISABLE_MAIN_FUNCTION true
#+END_EXAMPLE

    main won't be defined you need to call /ferret::ProgramRun()/
    manually to start the program.

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
  #if defined(__SAM3X8E__)
  # define AVR_GCC TRUE
  #elif defined(__AVR__)
  # define AVR_GCC TRUE
  #else
  # define GNU_GCC TRUE
  #endif

  #include <stdlib.h>
  #include <stdio.h>

  #ifdef GNU_GCC
  #include <iostream>
  #include <sstream>
  #endif

  #ifdef AVR_GCC
  #include "Arduino.h"
  #endif

  #ifdef MEMORY_POOL_SIZE
  #ifdef GNU_GCC
  #include <cmath>
  #else
  #include <math.h>
  #endif
  #endif

  //
  // Compiler Specific
  //

  #ifdef AVR_GCC
  extern "C" void __cxa_pure_virtual(void); 

  static FILE uartout = {0};

  static int uart_putchar (char c, FILE *stream){
    Serial.write(c);
    return 0 ;
  }

  #define OUTPUT_STREAM &uartout

  #if defined(__SAM3X8E__)
  #define INIT_OUTPUT_STREAM Serial.begin(9600);
  #endif


  #if !defined(__SAM3X8E__)
  #if !defined(DISABLE_OUTPUT_STREAM)
  #define INIT_OUTPUT_STREAM                                              \
    Serial.begin(9600);                                                   \
    fdev_setup_stream (&uartout, uart_putchar, NULL, _FDEV_SETUP_WRITE);

  #else
  #define INIT_OUTPUT_STREAM true;
  #endif
  #endif


  #define INIT_ENV                                \
    init();                                       \
    INIT_OUTPUT_STREAM                                                           
  #endif

  #ifdef GNU_GCC
  #define OUTPUT_STREAM stdout
  #define INIT_ENV 
  #endif

  #define VAR ferret::var

  #define MIN(a,b) ((a)<(b)?(a):(b))
  #define ABS(a) ((a)<0 ? -(a) : (a))
#+end_src

** Lisp

Once our object system is in place we can define rest of the runtime
(functions/macros) using our Clojure subset,

#+name: runtime-clojure-first
#+begin_src clojure :tangle no
  (defn first [x]
    "if(IS_NIL(x))
      __result = NIL;
    else
      __result = FIRST(x);")

  (defn nil? [x] "__result = NEW_BOOLEAN(IS_NIL(x))")

  (defn char? [x] "__result = IS_TYPE(x,CHARACTER_TYPE);")
#+end_src

We can embed C++ code into our functions, which is how most of the
primitive functions are defined such as the /first/ function above,
once primitives are in place rest can be defined in pure Clojure,

#+name: runtime-clojure-println
#+begin_src clojure :tangle no
  (defn println [& more]
    (apply print more)
    (newline))
#+end_src

As for macros, normal Clojure rules apply since they are expended using
Clojure, the only exception is that stuff should not expand to fully
qualified Clojure symbols, so the symbol /fn/ should not expand to
/clojure.core/fn/,

#+name: runtime-clojure-defn
#+begin_src clojure :tangle no
  (defmacro defn [name args & body]
    (list 'def name (cons 'fn `( ~args ~@body))))

  (defmacro native-header [& body]
    (cons 'native-declare
          (->> (map #(str "#include \"" (str %) "\"\n") body)
               (apply str)
               (list))))

  (defmacro defnative [name args & form]
    (let [includes (->> (filter #(seq? (nth % 2)) form)
                        (map #(cons (nth % 1) (apply list (nth % 2))))
                        (map (fn* ([form]
                                   (let [[guard & headers] form]
                                     (str "\n#if " guard " \n"
                                          (apply str (map #(str "#include \"" % "\"\n") headers))
                                          "#endif\n")))))
                        (map #(list 'native-declare %)))
          body (->> (map #(vector (second %) (last %)) form)
                    (map #(str "\n#if " (first %) " \n"
                               (second %)
                               "\n#endif\n"))
                    (apply str))
          pre-ample (->> (map #(vector (second %) (drop-last (drop 3 %))) form)
                         (map #(str "\n#if " (first %) " \n"
                                    (apply str (map (fn* ([line] (str line "\n"))) (second %)))
                                    "\n#endif\n"))
                         (map #(list 'native-declare %)))]
      (list 'def name (cons 'fn `( ~args ~@includes ~@pre-ample  ~body)))))
#+end_src

*** Misc

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defn identity [x] x)

  (defnative sleep [timeout]
    (on "defined GNU_GCC"
        ("unistd.h")
        "::sleep(TO_INT(timeout));")
    (on "defined AVR_GCC"
        "::delay(TO_INT(timeout));"))

  (defnative get-char []
    (on "defined GNU_GCC"
        "__result = NEW_CHARACTER(getchar());"))

  (defmacro defcallback [callback out in & pass-vars]
    (list 'do
          (list 'native-declare
                `~(str "\n" out " " (symbol-conversion callback) "_callack" "(" in "){\n"
                       "INVOKE(" (str (symbol-conversion callback) "_callback_fn")
                       (str \, (apply str (interpose " , " (reverse pass-vars)))) ");"
                       "\n}\n"))
          (list 'def `~(symbol (str callback "-callback-fn")) `~callback)))

  (defnative sh [cmd]
    (on "defined GNU_GCC"
        ("memory")
        "std::shared_ptr<FILE> pipe(popen(TO_C_STR(cmd), \"r\"), pclose);
         if (!pipe) 
            __result = NIL;
         char buffer[128];
         std::string result = \"\";
         while (!feof(pipe.get()))
          if (fgets(buffer, 128, pipe.get()) != NULL)
           result += buffer;
         __result = NEW_STRING(result.c_str());"))

  (defnative memory-pool-free-pages []
    (on "defined MEMORY_POOL_SIZE"
        "int count = 0;
         for(int i = 0; i < MEMORY_POOL_SIZE; i++)
           if(ProgramMemory.used[i] == false)
             count++;
         __result = NEW_NUMBER(count);"))

  (defnative memory-pool-print-snapshot []
    (on "defined MEMORY_POOL_SIZE"
        "for(int i = 0; i < MEMORY_POOL_SIZE; i++)
           fprintf(OUTPUT_STREAM, \"%d\",ProgramMemory.used[i]);
        fprintf(OUTPUT_STREAM, \"\\n\");
         __result = NIL;"))
#+end_src

*** Console I/O

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defn print [& more]
    "var f = ISEEKABLE(more)->first();
     f.toOutputStream();
     var r = ISEEKABLE(more)->rest();
     ITERATE(r,it){
      fprintf(OUTPUT_STREAM, \" \");
      FIRST(it).toOutputStream();
     }")

  (defn newline []
    "fprintf(OUTPUT_STREAM, \"\\n\");")

  <<runtime-clojure-println>>
#+end_src

*** Looping

#+name: runtime-clojure-looping
#+begin_src clojure :tangle no
  (defmacro doseq [binding & body]
    (list '_doseq_ (second binding) (cons 'fn `( [~(first binding)] ~@body))))

  (defn _doseq_ [seq f] "ITERATE(seq,it){INVOKE(f,FIRST(it));}")

  (defmacro dotimes [binding & body]
    (list '_dotimes_ (second binding) (cons 'fn `( [~(first binding)] ~@body))))

  (defn _dotimes_ [t f] "for(int i = 0; i < TO_INT(t); i++) INVOKE(f,NEW_NUMBER(i));")
#+end_src

*** Conditionals

#+name: runtime-clojure-conditionals
#+begin_src clojure :tangle no
  (defmacro when [test & body]
    (list 'if test (cons 'do body)))

  (defmacro cond
    [& clauses]
    (when clauses
      (list 'if (first clauses)
            (if (next clauses)
              (second clauses)
              (throw (IllegalArgumentException.
                      "cond requires an even number of forms")))
            (cons 'cond (next (next clauses))))))

  (defmacro while [test & body]
    (list '_while_ (list 'fn [] test) (cons 'fn `( [] ~@body))))

  (defn _while_ [pred fn]
    "while(BOOLEAN(INVOKE(pred))->asBool() == true)
       INVOKE(fn);")

  (defmacro forever [& body]
    (cons 'while `(true  ~@body)))
#+end_src

#+name: runtime-clojure-conditionals-tests
#+begin_src clojure :tangle no
  (deftest conditionals-test
    (is (= "2 1 -1 2 2 2 1"
           (capture-output '((print (if 1 2)
                                    (if (zero? 0) 1 -1)
                                    (if (zero? 1) 1 -1)
                                    (when true 2)
                                    (when (integer? 2) 2)
                                    (cond (float? 2.1) 2
                                          (integer? 2) 4
                                          :default 1)
                                    (cond (float? 2) 2.1
                                          (integer? 2.1) 4
                                          :default 1)))))))
#+end_src

*** Sequence

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn _reduce_2_arg_ [f coll]
    "var first = FIRST(coll);
     var rest = REST(coll);
     var acc = INVOKE(f,first,FIRST(rest));
     ITERATE(REST(rest),it){
       acc = INVOKE(f, FIRST(it), acc);
     }
     return acc;")

  (defn _reduce_3_arg_ [f val coll]
    "ITERATE(coll,it){
       val = INVOKE(f, FIRST(it), val);
     }
     return val;")

  (defmacro reduce [& args]
    (if (= 2 (count args))
      (cons '_reduce_2_arg_ `~args)
      (cons '_reduce_3_arg_ `~args)))
#+end_src

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn list [& xs] "__result = xs;")

  (defn list? [x] "__result = NEW_BOOLEAN(IS_TYPE(x,SEQUENCE_TYPE);")

  (defn empty? [x] "__result = NEW_BOOLEAN(ISEEKABLE(x)->isEmpty())")

  (defn rest [x] "if (IS_NIL(x) || ISEEKABLE(x)->isEmpty())
                    __result = NEW_SEQUENCE();
                  else 
                    __result = REST(x);")

  (defn cons [x seq] "if IS_NIL(seq)
                       seq = NEW_SEQUENCE();
                      __result = CONS(seq,x);")

  (defn apply [f args] "__result = LAMBDA(f)->invoke(args);")

  (defn conj [coll & xs]
    (reduce (fn[h v] (cons v h)) (if (nil? coll) (list) coll) xs))

  (defn reverse [s]
    (reduce conj (list) s))
#+end_src

#+name: runtime-clojure-sequence-count
#+begin_src clojure :tangle no
  (defn count [s] (reduce inc 0 s))
#+end_src

#+name: runtime-clojure-sequences-tests
#+begin_src clojure :tangle no
  (deftest sequences-test
    (is (= "(1 2 3 4) 1 (2 3 4) (3 4) (3 3 4) 3 4 (4 3 2 1 1 2) (4 3 2 1) 21 21 (nil) (1) () nil 0"
           (capture-output '((print (list 1 2 3 4)
                                    (first (list 1 2 3 4))
                                    (rest (list 1 2 3 4))
                                    (rest (rest (list 1 2 3 4)))
                                    (cons 3 (rest (rest (list 1 2 3 4))))
                                    (first (cons 3 (rest (rest (list 1 2 3 4)))))
                                    (count (list 1 2 3 4))
                                    (conj (list 1 2) 1 2 3 4)
                                    (conj nil 1 2 3 4)
                                    (reduce + (list 1 2 3 4 5 6))
                                    (apply + (list 1 2 3 4 5 6))
                                    (cons nil nil)
                                    (cons 1 nil)
                                    (rest (list))
                                    (first (rest (rest (list))))
                                    (count (list )))))))
    (is (= "(6 5 4 3 2 1) (6 5 4 3 2) (4 3 2 1 0) (. o l l e H) true"
           (capture-output '((print (reverse (list 1 2 3 4 5 6))
                                    (reduce (fn [h v]
                                              (conj h (inc v))) (list) (list 1 2 3 4 5))
                                    (reduce (fn [h v]
                                              (conj h (dec v))) (list) (list 1 2 3 4 5))
                                    (reduce (fn [h v]
                                              (conj h v)) (list) "Hello.")
                                    (= (list ) (list )))))))

    (is (= "(1 2 3 4 5 6) (7 6 5 4 3 2) (1 7 6 5 4 3 2) true"
           (capture-output '((let [l1 (list 1 2 3 4 5 6)
                                   l2 (reduce (fn[h v] (conj h (inc v))) (list) l1)
                                   l3 (cons 1 l2)]
                               (print l1 l2 l3 (empty? (rest nil)))))))))
#+end_src

*** Logical Operators

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn = [a & more]
    (if (empty? more)
      true
      (and ((fn [a b] "__result = NEW_BOOLEAN(a.equals(b));") a (first more))
           (apply = more))))

  (defmacro not= [& test]
    (list 'not (cons '= `( ~@test))))

  (defn < [a & more]
    (if (empty? more)
      true
      (and ((fn [a b] "
      NUMBER_DATA_TYPE an = NUMBER(a)->getNumerator();
      NUMBER_DATA_TYPE adn = NUMBER(a)->getDenominator();

      NUMBER_DATA_TYPE bn = NUMBER(b)->getNumerator();
      NUMBER_DATA_TYPE bdn = NUMBER(b)->getDenominator();

      __result = NEW_BOOLEAN((an * bdn) < (bn * adn));") a (first more))
           (apply < more))))

  (defn > [a & more]
    (if (empty? more)
      true
      (and ((fn [a b] "
      NUMBER_DATA_TYPE an = NUMBER(a)->getNumerator();
      NUMBER_DATA_TYPE adn = NUMBER(a)->getDenominator();

      NUMBER_DATA_TYPE bn = NUMBER(b)->getNumerator();
      NUMBER_DATA_TYPE bdn = NUMBER(b)->getDenominator();

      __result =  NEW_BOOLEAN((an * bdn) > (bn * adn));") a (first more))
           (apply > more))))

  (defn >= [a & more]
    (if (empty? more)
      true
      (and ((fn [a b] "
      NUMBER_DATA_TYPE an = NUMBER(a)->getNumerator();
      NUMBER_DATA_TYPE adn = NUMBER(a)->getDenominator();

      NUMBER_DATA_TYPE bn = NUMBER(b)->getNumerator();
      NUMBER_DATA_TYPE bdn = NUMBER(b)->getDenominator();

      return NEW_BOOLEAN((an * bdn) >= (bn * adn));") a (first more))
           (apply >= more))))

  (defn <= [a & more]
    (if (empty? more)
      true
      (and ((fn [a b] "
      NUMBER_DATA_TYPE an = NUMBER(a)->getNumerator();
      NUMBER_DATA_TYPE adn = NUMBER(a)->getDenominator();

      NUMBER_DATA_TYPE bn = NUMBER(b)->getNumerator();
      NUMBER_DATA_TYPE bdn = NUMBER(b)->getDenominator();

      __result = NEW_BOOLEAN((an * bdn) <= (bn * adn));") a (first more))
           (apply <= more))))

  (defmacro and
    ([] true)
    ([x] x)
    ([x & next]
     (list 'if x `(and ~@next) false)))

  (defmacro or
    ([] nil)
    ([x] x)
    ([x & next]
     (list 'if x x `(or ~@next))))

  (defn not [x]
    "if (!IS_TYPE(x,BOOLEAN_TYPE))
        return NEW_BOOLEAN(false);
        __result = NEW_BOOLEAN(!BOOLEAN(x)->asBool());")
#+end_src

#+name: runtime-clojure-logical-operators-tests
#+begin_src clojure :tangle no
  (deftest logical-operators-test
    (is (= "true true false true false true true true false true true false true false true true"
           (capture-output '((print (< 2)
                                    (< 2 3 4 5)
                                    (< 2 3 6 5)
                                    (> 2)
                                    (> 2 3 4 5)
                                    (> 6 5 4 3)
                                    (>= 2)
                                    (>= 5 4 3 2 2 2)
                                    (>= 5 1 3 2 2 2)
                                    (<= 2)
                                    (<= 2 2 3 4 5)
                                    (<= 2 2 1 3 4)
                                    (= 2)
                                    (= 2 3)
                                    (= 2 2 2 2)
                                    (= 2 2.0 2))))))

    (is (= "false true false true false falsetrue false true true"
           (capture-output '((print (= 2 2 2 2 3 5)
                                    (= (list 1 2) (list 1 2))
                                    (= (list 1 2) (list 1 3))
                                    (= true true)
                                    (not (= true true))
                                    (not 1))
                             (let [a (fn [x] (+ 1 x))
                                   b (fn [x] (inc x))]
                               (print (= a a)
                                      (= a b)
                                      (= nil ((fn [] )))
                                      (= nil ((fn [x y] ) 1 2)))))))))
#+end_src

*** Math

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn integer? [x] "__result = NEW_BOOLEAN(IS_TYPE(x,NUMBER_TYPE) &&
                                            (NUMBER(x)->getDenominator() == 1));")

  (defn float? [x] "__result = NEW_BOOLEAN(IS_TYPE(x,NUMBER_TYPE) &&
                                          (NUMBER(x)->getDenominator() != 1));")

  (defn + [& xs]
    (reduce (fn[h v] "
        NUMBER_DATA_TYPE hn = NUMBER(h)->getNumerator();
        NUMBER_DATA_TYPE hdn = NUMBER(h)->getDenominator();

        NUMBER_DATA_TYPE vn = NUMBER(v)->getNumerator();
        NUMBER_DATA_TYPE vdn = NUMBER(v)->getDenominator();

        NUMBER_DATA_TYPE ndn = (hdn * vdn);

        __result = NEW_RATIO(((hn * vdn) + (vn * hdn)),ndn);") 0 xs))

  (defn inc [x]
    (+ x 1))

  <<runtime-clojure-sequence-count>>

  (defn * [& xs]
    (reduce (fn[h v] "
        NUMBER_DATA_TYPE hn = NUMBER(h)->getNumerator();
        NUMBER_DATA_TYPE hdn = NUMBER(h)->getDenominator();

        NUMBER_DATA_TYPE vn = NUMBER(v)->getNumerator();
        NUMBER_DATA_TYPE vdn = NUMBER(v)->getDenominator();

        NUMBER_DATA_TYPE ndn = (hdn * vdn);

        __result = NEW_RATIO(((hn * vdn) * (vn * hdn)),ndn);") 1 xs))

  (defn - [& xs]
    (if (= (count xs) 1)
      (* -1 (first xs))
      (reduce (fn[h v] "
        NUMBER_DATA_TYPE hn = NUMBER(h)->getNumerator();
        NUMBER_DATA_TYPE hdn = NUMBER(h)->getDenominator();

        NUMBER_DATA_TYPE vn = NUMBER(v)->getNumerator();
        NUMBER_DATA_TYPE vdn = NUMBER(v)->getDenominator();

        NUMBER_DATA_TYPE ndn = (hdn * vdn);

        __result = NEW_RATIO(((hn * vdn) - (vn * hdn)),ndn);") (first xs) (rest xs))))

  (defn / [& xs]
    (if (= (count xs) 1)
      (apply / (cons 1 xs))
      (reduce (fn[h v] "
        NUMBER_DATA_TYPE hn = NUMBER(h)->getNumerator();
        NUMBER_DATA_TYPE hdn = NUMBER(h)->getDenominator();

        NUMBER_DATA_TYPE vn = NUMBER(v)->getNumerator();
        NUMBER_DATA_TYPE vdn = NUMBER(v)->getDenominator();

        __result = NEW_RATIO((hn * vdn),(vn * hdn));") (first xs) (rest xs))))

  (defn dec [x]
    (- x 1))

  (defn pos? [x]
    (> x 0))

  (defn neg? [x]
    (< x 0))

  (defn zero? [x]
    (= x 0))
#+end_src

#+name: runtime-clojure-bit-arithmetic-tests
#+begin_src clojure :tangle no
  (deftest arithmetic-test
    (is (= "3/5 0 1 10 10 -1 0 0 1 8 8 1 1/2 1 1"
           (capture-output '((print (+ 0.3 0.3)
                                    (+ )
                                    (+ 1)
                                    (+ 1 2 3 4)
                                    (+ 1 2.0 3 4)

                                    (- 1)
                                    (- 4 2 2)
                                    (- 4 2 2.0)
                                    
                                    (* )
                                    (* 2 2 2)
                                    (* 2.0 2 2)
                                    
                                    (/ 1)
                                    (/ 2)
                                    (/ 4 2 2)
                                    (/ 4 2 2.0))))))

    (is (= "true true false false true true false true true true"
           (capture-output '((print (pos? 1)
                                    (pos? 0.2)
                                    (pos? 0)
                                    (neg? 1)
                                    (neg? -1)
                                    (zero? 0)
                                    (zero? 10)
                                    (zero? (- 1 1))
                                    (zero? (- 1.2 1.2))
                                    (zero? (+ 1.2 -1.2)))))))

    (is (= "1 21 21 21 2"
           (capture-output '((let [a 1
                                   b 2]
                               (+ 1 a)
                               (+ b a)
                               (print a b)
                               (* 2 a)
                               (* b a)
                               (print a b)
                               (/ 2 a)
                               (/ b a)
                               (print a b)
                               (- 2 a)
                               (- b a)
                               (print a b)))))))
#+end_src

*** Bit Operations

#+name: runtime-clojure-bit-operations
#+begin_src clojure :tangle no
  (defn bit-not [x] "__result = NEW_NUMBER(~NUMBER(x)->getNumerator());")

  (defn bit-and [x y] "__result = NEW_NUMBER((NUMBER(x)->getNumerator() &
                                              NUMBER(y)->getNumerator()));")

  (defn bit-or [x y] "__result = NEW_NUMBER((NUMBER(x)->getNumerator() |
                                             NUMBER(y)->getNumerator()));")

  (defn bit-xor [x y] "__result = NEW_NUMBER((NUMBER(x)->getNumerator() ^
                                              NUMBER(y)->getNumerator()));")

  (defn bit-shift-left [x n] "__result = NEW_NUMBER((NUMBER(x)->getNumerator() <<
                                                     NUMBER(n)->getNumerator()));")

  (defn bit-shift-right [x n] "__result = NEW_NUMBER((NUMBER(x)->getNumerator() >>
                                                      NUMBER(n)->getNumerator()));")
#+end_src

#+name: runtime-clojure-bit-operations-tests
#+begin_src clojure :tangle no
  (deftest bit-operations-test
    (is (= "-5 -1 7 1 0 0 0 1 8 16 2 1"
           (capture-output '((print (bit-not  4)
                                    (bit-not  0)
                                    (bit-or   4 3)
                                    (bit-or   0 1)
                                    (bit-and  4 3)
                                    (bit-and  0 1)
                                    (bit-xor  4 4)
                                    (bit-xor  1 0)
                                    (bit-shift-left 4 1)
                                    (bit-shift-left 4 2)
                                    (bit-shift-right 4 1)
                                    (bit-shift-right 4 2)))))))
#+end_src

*** Concurrency

Runs the given lambda in a posix thread,

#+name: runtime-clojure-bit-operations
#+begin_src clojure :tangle no
  (defnative pthread-create [f]
    (on "defined GNU_GCC"
        ("pthread.h")
        "void *PTHREAD_LAMBDA_INVOKER(void *data) {
            ferret::var fn = ferret::var(static_cast<ferret::Object*>(data));
            OBJECT(fn)->subRef();
            INVOKE(fn);
            pthread_exit(NULL);
         }"
        "pthread_t th;
         OBJECT(f)->addRef();
         if(::pthread_create(&th, 0, &PTHREAD_LAMBDA_INVOKER, static_cast<void*>(f.get())))
           return NIL;
         __result = NEW_NUMBER(pthread_detach(th));"))
#+end_src

#+name: runtime-clojure-bit-operations-tests
#+begin_src clojure :tangle no
  (deftest pthreads-test
    (is (= "Thread-1Thread-2"
           (capture-output '((defn print-some [y x]
                               (fn []
                                 (sleep y)
                                 (print x)))
                             (pthread-create (print-some 0 "Thread-1"))
                             (pthread-create (print-some 1 "Thread-2"))
                             (sleep 3))))))
#+end_src

*** State Machines

This macro allows users to define state machines using the following
DSL,

#+begin_src clojure :tangle no
  (defmachine two-state-machine
    (state off (println "Off"))
    (state on (println "On"))
    (transitions
     (off
      (fn [] true) on)
     (on
      (fn [] true) off)))


  (dotimes [i 10]
    (two-state-machine))
#+end_src

Each transition takes a list of /fn/ /state/ pairs first function that
returns true returns the next state.

#+name: runtime-clojure-state-machine
#+begin_src clojure :tangle no
  (defmacro defmachine [name & form]
    (let [transitions
          (->> (last form)
               rest
               (map (fn*
                     ([x]
                      (let [[state & states] x
                            states (->> (partition 2 states)
                                        (map #(list (list (first %)) (second %))))
                            states (->> (clojure.core.protocols/coll-reduce
                                         states (fn*
                                                 ([h v]
                                                  (conj h (second v) (first v)))) (list))
                                        (cons 'cond))]
                        [(list '= 'state state) (concat states [true state])])))))
          start-state (-> transitions first first last)
          transitions (clojure.core.protocols/coll-reduce
                       transitions (fn*
                                    ([h v]
                                     (conj h (first v) (second v)))) ['cond])
          
          states (->> (filter #(= (first %) 'state) form)
                      (map rest)
                      (map (fn*
                            ([x]
                             [(first x)
                              (->> (rest x)
                                   (cons [])
                                   (cons 'fn))]))))
          states (clojure.core.protocols/coll-reduce
                  states (fn*
                          ([h v]
                           (conj h (first v) (second v)))) [])]
      (list 'def name
            `(let* [~@states
                    ~'curr-state ~(list 'atom start-state)]
                   ~(list 'fn []
                          `~(list 'swap! 'curr-state
                                  (list 'fn ['state]
                                        (list 'state)
                                        `(~@transitions))))))))
#+end_src

#+name: runtime-clojure-state-machine-tests
#+begin_src clojure :tangle no
  (deftest state-machine-test
    (is (= "10 0 10"
           (capture-output '((def state (atom 0))
                             (defmachine two-state-machine
                               (state off (swap! state inc))
                               (state on (swap! state inc))
                               (transitions
                                (off
                                 (fn [] true) on)
                                (on
                                 (fn [] true) off)))
                             (dotimes [_ 10]
                               (two-state-machine))
                             (print (deref state))
                             (print " ")
                             (reset! state 0)
                             (print (deref state))

                             (defmachine three-state-machine
                               (state a (swap! state inc))
                               (state b (swap! state inc))
                               (state c (swap! state inc))
                               (state no-op (swap! state inc))
                               (transitions
                                (a
                                 (fn [] false) no-op
                                 (fn [] true) b)
                                (b
                                 (fn [] true) c)
                                (c
                                 (fn [] false) no-op
                                 (fn [] false) no-op
                                 (fn [] true) a
                                 (fn [] false) no-op)))
                             (dotimes [_ 10]
                               (three-state-machine))
                             (print " ")
                             (print (deref state)))))))
#+end_src

*** Arduino

#+name: runtime-clojure-arduino
#+begin_src clojure :tangle no
  (defn pin-mode [pin mode]
    "if (mode.equals(NEW_KEYWORD(\":input\")) == true)
        pinMode(NUMBER(pin)->intValue(), INPUT);
     else
        pinMode(NUMBER(pin)->intValue(), OUTPUT);")

  (defn digital-write [pin mode]
    "if (mode.equals(NEW_KEYWORD(\":high\"))  == true)
        digitalWrite(NUMBER(pin)->intValue(), HIGH);
     else
        digitalWrite(NUMBER(pin)->intValue(), LOW);")
#+end_src

* Misc
** I/O

  #+name: core-code-generation-misc
  #+begin_src clojure
    ;; I/O
    (defn read-clojure-file [f]
      (try
        (read-string (str \( (FileUtils/readFileToString (file f)) \)))
        (catch Exception e
          (println "Error Reading," f e)
          (System/exit 1))))

    (defn copy-to-solution [fin fout]
      (FileUtils/copyURLToFile (ClassLoader/getSystemResource fin) (file fout)))

    (defn delete-recursively [file]
      (let [func (fn [func f]
                   (when (.isDirectory f)
                     (doseq [f2 (.listFiles f)]
                       (func func f2)))
                   (clojure.java.io/delete-file f))]
        (when (.exists file)
          (func func file))))

    (defn write-to-solution [s f]
      (FileUtils/writeStringToFile (file (str "./" f)) s))

    (defn append-to! [r ks v]
      (dosync 
       (let [cv (reduce (fn[h v] (v h)) @r ks)]
         (alter r assoc-in ks (conj cv v)))))

    (defn to-str? [f]
      (symbol? f))

    (defn is-special-form? [s f]
      (and (seq? f)
           (= (first f) s)))
  #+end_src

** Main

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn compile-options [& [options]]
      (merge {:compiler "g++"
              :include-path []
              :library-path []
              :link []
              :compiler-options ["-Werror" "-Wall"]
              :source-extension "cpp"}
             options))

    (defn compile->cpp [form options]
      (let [source (emit-source form)]
        (write-to-solution (solution-template source) (str "solution." (:source-extension options)))))

    (defn compile->binary [options extra-source-files]
      (let [command (flatten [(:compiler options)
                              (map #(str %) (:compiler-options options))
                              (map #(str "-I" %) (:include-path options))
                              (map #(str "-L" %) (:library-path options))
                              (map #(str "-l" %) (:link options))
                              (map #(let [extension (org.apache.commons.io.FilenameUtils/getExtension %)]
                                      [(cond (= extension "c") ["-x" "c"]
                                             (= extension "c++") ["-x" "c++"]
                                             :default "")
                                       %])
                                   extra-source-files)
                              ["-x" "c++"]
                              (str "solution." (:source-extension options))])
            ret (with-sh-dir "./"
                  (apply sh command))]
        (println "Running=>" command)
        (println "Return=>" ret)
        (if (not= 0 (:exit ret))
          (System/exit 1)
          (do (when (:name options)
                (with-sh-dir "./"
                  (sh "mv" "a.out" (str "./" (:name options)))))
              true))))

    (defn -main [& args]
      (let [opts [["-i" "--input FILE" "Input File"]
                  ["-c" "--compile" "Compile Solution"]
                  ["-o" "--compile-options FILE" "Compile Options File"
                   :parse-fn #(read-string (FileUtils/readFileToString (file %)))]
                  ["-f" "--source-files FILE" "Extra Source Files to Pass to GCC"]
                  ["-w" "--watch-input" "Automatically recompile input file on change."]
                  ["-h" "--help"]]
            args (parse-opts args opts)
            input (if (and (->> args :options :input)
                           (.exists (file (->> args :options :input))))
                    (->> args :options :input)
                    (do (println "No Input File.")
                        (System/exit 1)))
            options (compile-options (->> args :options :compile-options))
            extra-source-files (cond (not (empty? (:arguments args))) (:arguments args)
                                     (not (empty? (:extra-source-files options))) (:extra-source-files options)
                                     :default [])
            build-fn (fn []
                       (let [input (read-clojure-file input)]
                         (compile->cpp input options)
                         (when (->> args :options :compile)
                           (compile->binary options extra-source-files))))]
        (if (nil? (->> args :options :watch-input))
          (build-fn)
          (do (watcher/watcher [input]
                               (watcher/rate 1000)
                               (watcher/on-change (fn [_] (build-fn))))
              @(promise)))
        (shutdown-agents)))
  #+end_src

* Files                                                            :noexport:
** project.clj
#+begin_src clojure :mkdirp yes :tangle ferret/project.clj
  (defproject ferret "1.0.0-SNAPSHOT"
    :dependencies [[org.clojure/clojure "1.7.0"]
                   [org.clojure/tools.cli "0.3.3"]
                   [org.bituf/clj-stringtemplate "0.2"]
                   [org.clojars.amit/commons-io "1.4.0"]
                   [watchtower "0.1.1"]]
    :repl-options {:host "0.0.0.0"
                   :port 7888
                   :init-ns ferret.core}
    :main ferret.core
    :aot [ferret.core]
    :jar-name "interim.jar"
    :uberjar-name "ferret-app.jar")
#+end_src 
** src/core.clj
#+begin_src clojure :noweb yes :mkdirp yes :tangle ferret/src/ferret/core.clj
  (ns ferret.core
    (:gen-class)
    (:use [clojure.java.io]
          [clojure.walk :only [macroexpand-all]])
    (:require [clojure.zip :as zip]
              [clojure.tools.cli :refer [parse-opts]]
              [watchtower.core :as watcher])
    (:use [ferret.string-template]
          [ferret.template]
          [clojure.java.shell])
    (:import (org.apache.commons.io FileUtils)))

  <<core-code-generation-misc>>

  <<core-transformation-form-fns>>

  <<core-transformation-vector-list>>

  <<core-transformation-vector-list>>

  <<core-transformation-expand-macros>>

  <<core-transformation-add-built-in>>

  <<core-transformation-closure-conversion>>

  <<core-transformation-symbol-conversion>>

  <<core-transformation-do-fn>>

  <<core-transformation-let-fn>>

  <<core-transformation-process>>

  <<core-code-generation-emit>>

  <<core-code-generation-emit-source-methods>>

  <<core-code-generation-emit-source>>

  <<core-code-compile-code>>
#+end_src 
** src/template.clj
#+begin_src clojure :mkdirp yes :noweb yes :tangle ferret/src/ferret/template.clj
  (ns ferret.template
    (:use [ferret.string-template])
    (:import (java.io BufferedReader InputStreamReader)))

  (defn read-from-url [f]
    (with-open [in (.getResourceAsStream (ClassLoader/getSystemClassLoader) f)
                rdr (BufferedReader. (InputStreamReader. in))]
      (apply str (interpose \newline (line-seq rdr)))))

  (defn indexed
    "Returns a lazy sequence of [index, item] pairs, where items come
    from 's' and indexes count up from zero.

    (indexed '(a b c d))  =>  ([0 a] [1 b] [2 c] [3 d])"
    [s]
    (map vector (iterate inc 0) s))

  <<code-templates>>
#+end_src 
** src/string_template.clj
#+begin_src clojure :noweb yes :mkdirp yes :tangle ferret/src/ferret/string_template.clj
  (ns ferret.string-template
    (:import org.antlr.stringtemplate.StringTemplateGroup)
    (:import org.antlr.stringtemplate.StringTemplate)
    (:use ferret.string-template-internal))


  (defn create-view "Return new view template - useful as mentioned here:
    http://hardlikesoftware.com/weblog/2006/12/12/using-json-with-stringtemplate/"
    ([]
      (StringTemplate.))
    ([^String template]
      (StringTemplate. template)))


  (defn get-view-from-classpath "Return the view template from classpath"
    [^String view-name]
    (let [st-group (StringTemplateGroup. "default")]
      (.getInstanceOf st-group view-name)))


  (defn get-view-from-dir "Return the view template from specified directory"
    [^String view-name ^String root-dir]
    (let [st-group (StringTemplateGroup. "default" root-dir)]
      (.getInstanceOf st-group view-name)))


  (defn reset-view! "Reset view template with supplied content"
    [^StringTemplate view ^String template]
    (.setTemplate view template))


  (defn fill-view! "Fill view template with key/value pairs"
    ;;;
    ;; Fill template with key and value
    ([^StringTemplate template k v]
      (.setAttribute template (stringify k) (each-kv-to-sv v))
      template)
    ;;;
    ;; Fill template with key/value from map
    ([^StringTemplate template kv-map]
      (.setAttributes template (kv-to-sv kv-map))
      template))


  (defn render-view "Return rendered view for the template"
    [^StringTemplate template]
    (.toString template))
#+end_src

#+begin_src clojure :noweb yes :mkdirp yes :tangle ferret/src/ferret/string_template_internal.clj
  (ns ferret.string-template-internal)


  (defn stringify [any]
    (if (keyword? any)
      (name any)
      (str any)))


  (declare kv-to-sv)
  (declare scan-kv-to-sv)


  (defn each-kv-to-sv "If element is a collection type, do deep transformation"
    [each]
    (if (map? each)
      (kv-to-sv each)
      (if (or (vector? each) (list? each) (seq? each) (set? each))
        (scan-kv-to-sv each)
        each)))


  (defn scan-kv-to-sv
    "Scans a collection and turns any contained map within from kv to sv"
    [coll]
    (map each-kv-to-sv coll))


  (defn kv-to-sv
    "Transforms keyword-value map {:a 10 :b 20 :c 30}
     to string-value map {\"a\" 10 \"b\" 20 \"c\" 30}"
    [mp]
    (let [m (into {} mp)
          k (keys m)
          v (vals m)]
      (zipmap
        (map stringify k)
        (scan-kv-to-sv v))))

#+end_src

** test/core.clj
#+begin_src clojure :noweb yes :mkdirp yes :tangle ferret/test/ferret/test/core.clj
    (ns ferret.test.core
      (:use [ferret.core] :reload)
      (:use [clojure.test]
            [clojure.java.shell]))

  (defn capture-output [form]
    (let [options (compile-options)]
      (compile->cpp form options)
      (compile->binary options [])
      (with-sh-dir "./"
        (let [r (sh "./a.out")]
          (:out r)))))

    <<compiler-transformation-tests>>
    <<compiler-import-module-test>>
    <<runtime-clojure-bit-operations-tests>>
    <<runtime-clojure-bit-arithmetic-tests>>
    <<runtime-clojure-logical-operators-tests>>
    <<runtime-clojure-conditionals-tests>>
    <<runtime-clojure-sequences-tests>>
    <<clojure-destructure-tests>>
    <<native-string-tests>>
    <<native-keyword-tests>>
    <<runtime-clojure-memory-pool-tests>>
    <<runtime-clojure-state-machine-tests>>
    <<runtime-native-atom-tests>>
    <<native-lambda-test>>
#+end_src 

** resources/Object.cpp

#+begin_src c++ :mkdirp yes :noweb yes :tangle ferret/resources/Object.cpp
  <<runtime-native-program-header>>

  <<runtime-native-object-casting-macros>>

  <<runtime-native-lambda-invoke-macros>>

  <<runtime-native-iseekable-macros>>

  <<runtime-native-math-config>>

  namespace ferret{
    class var;
    <<runtime-native-memory-pool>>
    <<runtime-native-object>>
    <<runtime-native-var>>
  }
#+end_src 

** resources/runtime.clj

#+begin_src clojure :mkdirp yes :noweb yes :tangle ferret/resources/runtime.clj
  <<runtime-clojure-boolean-object>>
  <<runtime-clojure-pointer-object>>
  <<runtime-clojure-number-object>>
  <<runtime-clojure-seekable-interface>>
  <<runtime-clojure-lambda-interface>>
  <<runtime-clojure-keyword-object>>
  <<runtime-clojure-cell-object>>
  <<runtime-clojure-sequence-object>>
  <<runtime-clojure-character-object>>
  <<runtime-clojure-string-object>>
  <<runtime-clojure-atom-object>>
  <<runtime-clojure-defn>>
  <<runtime-clojure-looping>>
  <<runtime-clojure-first>>
  <<runtime-clojure-sequence>>
  <<runtime-clojure-logical-operators>>
  <<runtime-clojure-conditionals>>
  <<runtime-clojure-math>>
  <<runtime-clojure-bit-operations>>
  <<runtime-clojure-console-io>>
  <<runtime-clojure-misc>>
  <<runtime-clojure-state-machine>>
  <<runtime-clojure-arduino>>
#+end_src
