#+title: Ferret Programmer's Manual
#+STARTUP: hidestars
#+TAGS: noexport(e)
#+EXPORT_EXCLUDE_TAGS: noexport
#+SETUPFILE: org-mode-assets/org-mode.setup
#+OPTIONS: H:10

* Getting Started
** What Is Ferret

Ferret is a free software Clojure implementation, it compiles a
restricted subset of the Clojure language to self contained *ISO
C++11* which allows for the use of Clojure in real time embedded
control systems. 

Generated code can be used on any platform that has a *C++11*
compliant compiler. it has been verified to run on architectures
ranging from embedded systems with as little as 2KB of RAM to general
purpose computers running Linux/Mac OS X/Windows.

 - General Purpose Computers
   - Clang on Mac OS X
   - GCC & Clang on Linux
 - Microcontrollers
   - Arduino 
     - Uno / Atmega328
     - Due / AT91SAM3X8E
     - 101 / Intel Curie
   - SparkFun SAMD21 Mini / ATSAMD21G18 - ARM Cortex-M0+

** Features

 - Tailored for Real Time Control Applications. (Deterministic Execution.)
 - Immutable Data Structures
 - Functional
 - Macros
 - Easy FFI (Inline C,C++)
 - Easily Embeddable (i.e Ferret fns are just C++ functors.)
 - Memory Pooling (Ability to run without heap.)
 - Destructuring
 - Module System

** Download

Ferret is available as prebuilt and source code distributions. See
[[Building From Sources]] for links to source distribution.

#+BEGIN_HTML
  <img src="https://badge.fury.io/gh/nakkaya%2Fferret.svg" style="float: left; padding-right: 1cm;">
  <img src="https://travis-ci.org/nakkaya/ferret.svg?branch=master" style="margin-left: 0;">
#+END_HTML

   - [[http://dropbox.nakkaya.com/builds/ferret][Executable]] (Requires Bash and JVM)
   - [[http://dropbox.nakkaya.com/builds/ferret.jar][Standalone Jar]] (Requires JVM)

** A glimpse of Ferret

On any system, we can just compile a program directly into an
executable. Here's a program that sums the first 5 positive numbers.

#+begin_src clojure
  ;;; lazy-sum.clj
  (defn positive-numbers
    ([]
     (positive-numbers 1))
    ([n]
     (cons n (lazy-seq (positive-numbers (inc n))))))

  (println (->> (positive-numbers)
                (take 5)
                (apply +)))
#+end_src

We can compile this program using *ferret*, creating an executable named
*a.out*.

#+BEGIN_EXAMPLE
  $ ./ferret -i lazy-sum.clj
  $ g++ -std=c++11 -pthread lazy-sum.cpp
  $ ./a.out
  15
#+END_EXAMPLE

Output will be placed in a a file called *lazy-sum.cpp*. When *-c*
flag is used ferret will call *g++* or if set *CXX* environment
variable on the resulting *cpp* file.

#+BEGIN_EXAMPLE
  $ ./ferret -i lazy-sum.clj -c
  $ ./a.out
  15
#+END_EXAMPLE

Following shows a blink example for Arduino.

#+begin_src clojure
  ;;; blink.clj
  (pin-mode 13 :output)

  (forever
   (digital-write 13 :high)
   (sleep 500)
   (digital-write 13 :low)
   (sleep 500))
#+end_src

#+BEGIN_EXAMPLE
  $ ./ferret -i blink.clj
  $ mkdir blink
  $ mv blink.cpp blink/blink.ino
#+END_EXAMPLE

Then upload as usual. 

For more embedded usage examples see,

 - [[http://nakkaya.com/2016/06/10/ferret-a-hard-real-time-clojure-for-lisp-machines/][Ferret - A Hard Real-Time Clojure for Lisp Machines]] -
   Implementation of a line following robot in Ferret.
 - [[https://git.nakkaya.com/nakkaya/solarcar-tracker][solarcar-tracker]] - A Tracking device for the [[http://solarcar.neu.edu.tr][Ra27 solar car]]. (GPS,
   IMU etc.) (Raspberry Pi)
 - [[https://git.nakkaya.com/nakkaya/solarcar-turn-indicator/tree/master][solarcar-turn-indicator]] - Controller for the turn indicator
   assembly on the [[http://solarcar.neu.edu.tr][Ra27 solar car]]. (Atmega MCU)

** Memory Management

Ferret is designed to be used on embedded systems which means,

 - Latency is more important then through put.
 - Can't have unpredictable GC pauses when running.

So the default memory management is done using reference
counting. Unlike other lisp implementations, Ferret supports various
memory management schemes,

 - *malloc/free* - Allocations are handled by the system
   implementation. (Default memory management.)
 - *Memory Pooling* - On memory constraint systems such as
   microcontrollers Ferret can use a memory pool to avoid heap
   fragmentation and calling malloc/free. Effectively running with
   no heap, allocating all memory at compile time on the stack.
 - *Third party allocators* (i.e tcmalloc)

To enable memory pooling,

#+BEGIN_EXAMPLE
  (configure-runtime! FERRET_MEMORY_POOL_SIZE 256)
#+END_EXAMPLE

This will create a pool object as a global variable that holds an
array of *256 / sizeof(long)*. 

By default page size is =sizeof(long)=. This can be changed using,

#+BEGIN_EXAMPLE
  (configure-runtime! FERRET_MEMORY_POOL_PAGE_TYPE char)
#+END_EXAMPLE

Memory pooling is intended for embedded systems where calling
malloc/free is not desired.

Steps for using *tcmalloc* on Mac OS X, install dependencies, 

#+BEGIN_EXAMPLE
  brew install google-perftools
#+END_EXAMPLE

Then from your program you can link to it using,

#+begin_src clojure
  (configure-ferret! :compiler-options ["-std=c++11"
                                        "-L/usr/local/Cellar/gperftools/2.4/lib/"
                                        "-ltcmalloc"])
#+end_src

** Accessing C,C++ Libraries

You can declare global level things using,

#+begin_src clojure
  (native-declare "int i = 0;")
#+end_src

this will define an *int* called *i* as a global variable. If a
function only contains a string such as,

#+begin_src clojure
  (defn inc-int [] "__result =  obj<Number>(i++);")
#+end_src

It is assumed to be a native function string it is taken as C++
code. You can then use it like any other ferret function.

#+begin_src clojure
  (while (< (inc-int) 10)
    (print 1))
#+end_src

Another option is to use the *cxx* macro,

#+begin_src clojure
  (let [msg "Hello World!"]
    (cxx "::std::cout << msg.cast<String>()->to_string() << ::std::endl;"))

  (def dac-0 (cxx "__result =  obj<Number>(DAC0);"))
#+end_src

In addition to *defn* form there is also a *defnative* form which
allows you to define different function bodies for different *#define*
directives,

#+begin_src clojure
  (defnative get-char []
    (on "defined GNU_GCC"
        "__result = obj<Number>(getchar());"))
#+end_src

This function when compiled on a system that defines =GNU_GCC= will
return the result of *getchar* as a *Number* , on ANY other system it
will return *nil*. You can have multiple *on* blocks per *defnative*,

#+begin_src clojure
  (defnative sleep [t]
    (on "defined FERRET_STD_LIB"
        ("chrono" "thread")
        "auto duration = ::std::chrono::milliseconds(t.to<number_t>());
         ::std::this_thread::sleep_for(duration);")
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::delay(t.to<number_t>());"))
#+end_src

This way a single function can be defined for multiple
systems. Reverse is also possible, since all built in data structures
are immutable you can freely call Ferret code from C++,

#+begin_src c++
  var alist = runtime::list(obj<Number>(1),obj<Number>(2),obj<Number>(3));

  int sum = 0;
  for(auto it : runtime::range(alist)){
    sum += it.to<number_t>();
   }

  ::std::cout << sum << ::std::endl;

  //or

  var res = _plus_().invoke(alist);
  res.stream_console();
  ::std::cout << ::std::endl;
#+end_src

* Overview

This is a literate program, inspired by Donald Knuth (Knuth, Donald
“Literate Programming (1984)” Literate Programming CSLI, p99). It is
intended to be read like a novel from cover to cover. The ideas are
expressed clearly but they are grounded in the actual source code.

This document is not intended to be a full Clojure tutorial. It is a
specification of the subset of Clojure implemented by Ferret, and
the particular workings of the Object / Runtime system.

** Language 

Ferret is a functional, lazy language. All functions should mimic
their Clojure counter parts. If they don't it is considered a bug. (or
not possible to implement with the current implementation.)

** Structure

The compiler and the C++ runtime needed is split into three sections.

 - [[Compiler]]
 - [[Native Core]]
 - [[Clojure Core]]

*[[Compiler]]* section contains the actual compiler written in Clojure. It
takes the Clojure code and converts it to a Intermediate
representation by taking the Clojure form and running it [[Compilation][through some
transformations]]. This IR is then run through [[Code Generation]] module to
create C++ code. *[[Native Core]]* contains the C++ runtime needed to
support Ferret such as [[Object System]], [[Memory Pool][ Memory Pooling]], [[Reference Counting][Garbage
Collection]]. It is written in a mixture of C++ and Ferret DSL. *[[Clojure
Core]]* corresponds to *clojure.core*, contains all functions.

** Compiled Code

The generated code is self contained *ISO C++11*, it is not tied to
any one compiler, generated code should be portable between any
Operating System / Microcontroller that support a *C++11* compliant
compiler.

Generated C++ code has the following structure, (All Ferret code is
defined within *ferret* namespace. All Ferret macros starts with
*FERRET_*.)

 - Detect Hardware
 - Include files
 - Ferret Header (resources/ferret.h)
 - Ferret Native Runtime Prototypes (runtime::first, runtime::rest
   etc.)
 - Native Declarations
 - Object Definitions
 - Symbol Definitions
 - Native Runtime Implementations
 - Lambda Prototypes
 - Lambda Implementations
 - Ferret Main
 - Hardware Dependent Main Functions

** Building From Sources

The code in this document is the executable source. Use the *build*
script in the source distribution to extract source code.

The latest sources are available at,

  - [[https://git.nakkaya.com/nakkaya/ferret][git.nakkaya.com]]
  - [[https://github.com/nakkaya/ferret][Github]]

Dependencies,

 - Java
 - Emacs >= 24.5
 - Clojure
 - Leiningen

Assuming all of the above is in your path just run,

#+BEGIN_EXAMPLE
  ./build
#+END_EXAMPLE

This will extract the source from this file to *src/* directory and
build the *jar* and *executable* distributions. *build* script assumes
it is running on a **NIX* based system if not, open this file using
*emacs* and run,

#+BEGIN_EXAMPLE
  M-x org-babel-tangle
#+END_EXAMPLE

that will extract the source code then you can threat it as any other
Clojure/Lein project.

** License

Copyright 2015 Nurullah Akkaya

This file is part of Ferret.

Ferret is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. 

Ferret is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details. 

You should have received a copy of the GNU General Public License
along with Ferret. If not, see http://www.gnu.org/licenses/.

* Compiler

Compilation happens by taking the /form/ and running it through several
transformations. Each transformation turns the form into more and more
C++ written with s-expressions. This intermediate language is then run
through code generation to produce the C++ file.

** Compilation

Forms go through twelve transformations before they are passed to the
code generation phase.

#+name: core-compilation-process
#+begin_src clojure :tangle no
  (defn compile [form options]
    (->> (import-modules-all form)
         (process-reader-macros)
         (embed-ferret-core)
         (remove-assertions options)
         (expand-macros-all)
         (let->fn)
         (do->fn)
         (closure-conversion)
         (replace-fn-call-sites options)
         (escape-analysis)
         (symbol-conversion)))
#+end_src

*** Import Modules

Import other ferret files using,

#+BEGIN_SRC clojure :tangle no
  (require 'package.io)

  (require '[package.io :as io])

  (require '[package.io :as io]
           '[package.udp :as udp])
#+END_SRC

Compiler will look for a file under current working directory called,
/package/io.clj/ all expression in the that file will be added to the
front of the current form with symbols renamed to /some-fn/ =>
/io/some-function/.

#+name: core-compilation-embed-ferret-core
#+begin_src clojure :tangle no
  (defn import-modules-select-require [form]
    (let [norm-require (fn [f]
                         (if (symbol? f)
                           [f :as f]
                           f))]
      (->> (select-form form (is-form? 'require))
           (reduce (fn[h v]
                     (if (= 2 (count v))
                       ;; require single module
                       (conj h (norm-require (->> v last last)))
                       ;; require multiple modules
                       (concat h (map #(norm-require (last %)) (rest v))))) [])
           (map (fn [[mod _ as]] [mod as]))
           (reduce (fn[h [mod as]]
                     (if (h mod)
                       (assoc h mod (conj (h mod) as))
                       (assoc h mod [as]))) {}))))
#+end_src

Extract the list of packages and aliases from the form. Returns a map
of mod -> aliases pairs.

#+name: core-compilation-embed-ferret-core
#+begin_src clojure :tangle no
  (defn import-modules-load-modules [package-list]
    (reduce (fn[h [m aliases]]
              (let [mod (read-clojure-file
                         (str (.replace (str m) "." "/") ".clj"))
                    macro-symbols (->> (select-form mod (is-form? 'defmacro))
                                       (map second)
                                       (into #{}))
                    def-symbols (->> (select-form (expand-macros-all mod) (is-form? 'def))
                                     (map second)
                                     (into #{}))
                    replace? (set/union macro-symbols def-symbols)
                    mod (morph-form mod symbol?
                                    (fn [f]
                                      (if (replace? f)
                                        (symbol (str (.replace (str m) "." "_") "_" f))
                                        f)))]
                (reduce (fn [h v] (conj h v)) h mod)))
            (list ) package-list))
#+end_src

Loads all modules listed in the package list. When a module is loaded
all its symbols are replaced with its module name except /core/
functions. Module names acts as namespaces. Returns a form that the is
concatenation of all modules listed in form.

#+name: core-compilation-embed-ferret-core
#+begin_src clojure :tangle no
  (defn import-modules-convert-alias-to-module [package-list form]
    (let [alias-to-mod (reduce (fn[h [mod aliases]]
                                 (reduce (fn[h v] (assoc h v mod)) h aliases))
                               {} package-list)
          form (morph-form form symbol?
                           (fn [f]
                             (if-let [[_ alias fn] (re-find #"(.*?)/(.*)" (str f))]
                               (if-let [mod-sym (alias-to-mod (symbol alias))]
                                 (symbol (str (.replace (str mod-sym) "." "_") "_" fn))
                                 f)
                               f)))]
      form))
#+end_src

Convert all aliased symbols in the form to their fully qualified
modules names. So =helper-a= defined in module =util.db= becomes
=util_db_helper-a=.

#+name: core-compilation-embed-ferret-core
#+begin_src clojure :tangle no
  (defn import-modules [form]
    (let [package-list (import-modules-select-require form)
          form (remove-form form (is-form? 'require))
          modules (import-modules-load-modules package-list)
          form (import-modules-convert-alias-to-module package-list form)]
      (shake-concat modules form)))

  (defn import-modules-all [form]
    (loop [f form]
      (let [expanded (import-modules f)]
        (if (= f expanded)
          expanded
          (recur expanded)))))
#+end_src

Import all modules in the given form.

*** Process Reader Macros

Process some supported reader macros, /@/ and /#(some-fn)/ forms.

#+name: core-compilation-reader-macros
#+begin_src clojure :tangle no
  (defn process-reader-macros [form]
    (morph-form form
                (is-form? 'clojure.core/deref)
                (fn [f] (cons 'deref (rest f)))))
#+end_src

*** Add Runtime

/resources/core.clj/ contains the ferret core runtime when
tangled.

#+name: core-compilation-embed-ferret-core
#+begin_src clojure :tangle no
  (defn embed-ferret-core
    ([form]
     (shake-concat (-> (read-clojure-file-from-url "core.clj")
                       (remove-form (is-form? 'defmacro)))
                   form)))
#+end_src

*** Expand Macros

First we read all the macros present in /resources/core.clj/ then
add to that  user defined macros, they are evaluated in a temporary
namespace, using /morph-form/ we iterate all the macros used in the
code that we are compiling and expand them in the temporary namespace
then the node is replaced with its expanded form.

#+name: core-compilation-expand-macros
#+begin_src clojure :tangle no
  (declare expand-macros-all)
  (declare localize-fn-args)

  (defn expand-macros [form]
    (let [build-in-macros (->> (read-clojure-file-from-url "core.clj")
                               (filter (is-form? 'defmacro)))
          build-in-macro-symbols (into #{} (map second build-in-macros))
          form-macros (->> (filter (is-form? 'defmacro) form)
                           (filter (fn [[_ name]]
                                     (not (build-in-macro-symbols name)))))
          form-macro-symbols (map second form-macros)
          form (remove-form form (is-form? 'defmacro))
          temp-ns (gensym)]
      (create-ns temp-ns)
      (binding [*ns* (the-ns temp-ns)]
        (refer 'clojure.core :exclude (concat build-in-macro-symbols form-macro-symbols ['fn 'def]))
        (use '[ferret.core :only [symbol-conversion localize-fn-args]])
        
        (doseq [m build-in-macros]
          (eval m))
        
        (doseq [m form-macros]
          (eval m)))
      
      (let [form (morph-form form
                             (is-form? 'let)
                             (fn [[_ bindings & body]]
                               (let [bindings (map #(if (list? %)
                                                      (expand-macros-all %) %) bindings)
                                     form (cons 'let* (cons bindings (expand-macros-all body)))]
                                 (expand-macros-all form))))
            form (morph-form form
                             (apply is-form? (concat build-in-macro-symbols form-macro-symbols))
                             (fn [f]
                               (binding [*ns* (the-ns temp-ns)]
                                 (walk/macroexpand-all f))))]
        (remove-ns temp-ns)
        form)))

  (defn expand-macros-all-aux [form]
    (loop [f form]
      (let [expanded (expand-macros f)]
        (if (= f expanded)
          expanded
          (recur expanded)))))

  (def expand-macros-all (memoize expand-macros-all-aux))
#+end_src

Takes a *fn* form and converts all argument symbols with their unique
replacements,

#+begin_src clojure
  (fn [a b] (list a b))
  ;;becomes
  (fn [a__1510 b__1511] (list a__1510 b__1511))
#+end_src

#+name: core-compilation-expand-macros
#+begin_src clojure :tangle no
  (defn localize-fn-args [form]
    (let [valid-symbol? (fn [s] (and (not= s '&) (not= s '_)))
          [args & body] form]
      (if (string? (first body))
        (cons 'fn* `(~args ~@body))
        (let [unique-args (->> args
                               flatten
                               (filter valid-symbol?)
                               (map #(symbol (str % (gensym "__")))))
              replace? (->> (interleave (->> args
                                             flatten
                                             (filter valid-symbol?))
                                        unique-args)
                            (apply hash-map))
              unique-body (walk/prewalk
                           (fn [x]
                             (if (and (symbol? x)
                                      (replace? x))
                               (replace? x)
                               x)) body)
              args (->> (morph-form args #(replace? %)
                                    (fn [f] (replace? f)))
                        (into []))]
          (cons 'fn* `(~args ~@unique-body))))))
#+end_src

*** let->fn

/let/ forms are transformed into nested functions which are then
called immediately, bindings are setup in the outer function,
expressions are placed in the inner function which takes the bindings
as arguments.

So following form,

#+begin_src clojure :tangle no
  (let->fn '(let [a 1
                  b 2]
              (+ a b)))
#+end_src

after transformation becomes,

#+begin_src clojure :tangle no
  (define_lambda G__2708 (b a) () (_plus_ a b))
  (define_lambda G__2709 (a) (b) ((lambda_object G__2708 b a)))
  (define_lambda G__2710 () (a) ((lambda_object G__2709 a) 2))
  ((lambda_object G__2710) 1)
#+end_src

#+name: core-compilation-let-fn
#+begin_src clojure :tangle no
  (defn let->fn [form]
    (morph-form form
                (is-form? 'let*)
                (fn [[_ bindings & body]]
                  (let [bindings (partition 2 bindings)]
                    (if (empty? bindings)
                      (list (concat (list 'fn* []) body))
                      (let [closure-fn
                            (fn close [[arg val] & more]
                              (if (empty? more)
                                (list (concat (list 'fn* (list arg)) body) val)
                                (list (list 'fn* (list arg) (apply close more)) val)))]
                        (apply closure-fn bindings)))))))
#+end_src

*** do->fn

A similar method is used for the do form, expressions are wrapped in a fn
that takes no parameters and executed in place.

#+begin_src clojure :tangle no
  (do->fn '(do (+ 1 1)))
#+end_src

#+begin_src clojure :tangle no
  ((fn [] (+ 1 1)))
#+end_src

#+name: core-compilation-do-fn
#+begin_src clojure :tangle no
  (defn do->fn [form]
    (morph-form form
                (is-form? 'do)
                #(list (concat ['fn* []] (rest %)))))
#+end_src

*** Closure Conversion

/closure-conversion/ handles the problem of free variables, 

#+begin_src clojure :tangle no
  (defn make-adder [x]
    (fn [n] (+ x n)))
#+end_src

in the above snippet x is a free variable, when the function /make-adder/
returns, it need to have a way of referencing that variable when it is
used. The way we do this is that, every function will pass its arguments to
inner functions (if any) it contains.

#+begin_src clojure :tangle no
  (closure-conversion '(fn [x]
                          (fn [n] (+ x n))))
#+end_src

Above form will be converted to,

#+begin_src clojure :tangle no
  (define_lambda G__3154 (x) (n) (_plus_ x n))
  (define_lambda G__3155 () (x) (lambda_object G__3154 x))
  (lambda_object G__3155)
#+end_src

What this means is, define a functor named =G__3154= that holds a
reference to /x/, and another functor =G__3155= that has no state. When
we create an instance of =G__3154= we pass /x/ to its
constructor. Since every thing is already converted to fns this
mechanism allows variables to be referenced down the line and solves
the free variable problem.

#+name: core-compilation-closure-conversion 
#+begin_src clojure :tangle no
  (defn lambda-defined? [fns env args body]
    (let [f (concat [env args] body)
          name (reduce (fn[h v]
                         (let [[_ n & r] v]
                           (if (= r f) n))) nil @fns)]
      (when name
        (apply list 'fir-lambda-object name env))))

  (defn define-lambda [fns env args body]
    (let [n (gensym)]
      (dosync (alter fns conj (concat ['fir-define-lambda n env args] body)))
      (apply list 'fir-lambda-object n env)))

  (defn closure-conversion
    ([form]
     (let [fns (ref [])
           form (closure-conversion form fns)]
       (concat form @fns)))
    ([form fns & env]
     (morph-form form
                 (is-form? 'fn*)
                 (fn [[_ args & body]]
                   (let [env (if (nil? env) '() (first env))
                         fn-env (->> args
                                     (remove #(and (seq? %)
                                                   (= 'ferret-compiler-no-closure (first %)))))
                         fn-args (->> args
                                      (map #(if (and (seq? %)
                                                     (= 'ferret-compiler-no-closure (first %)))
                                              (second %)
                                              %)))
                         body (closure-conversion body fns (concat fn-env env))]
                     (if-let [n (lambda-defined? fns env args body)]
                       n
                       (define-lambda fns env fn-args body)))))))
#+end_src

*** Symbol Conversion

Some symbols valid in Clojure are not valid C++ identifiers. This
transformation converts all symbols that are not legal C++ identifiers
into legal ones.

#+name: core-compilation-symbol-conversion
#+begin_src clojure :tangle no
  (defn symbol-conversion [form]
    (let [c (comp #(symbol (clojure.string/escape
                            (str %)
                            {\- \_ \* "_star_" \+ "_plus_" \/ "_slash_"
                             \< "_lt_" \> "_gt_" \= "_eq_" \? "_QMARK_"
                             \! "_BANG_" \# "_"}))
                  #(cond (= 'not %) '_not_
                         :default %))]
      (morph-form form symbol? c)))
#+end_src

*** Remove Assertions

#+name: core-compilation-remove-assertions
#+begin_src clojure :tangle no
  (defn remove-assertions [options form]
    (if (:release options)
      (do (info "option => release mode")
          (remove-form form (is-form? 'assert)))
      form))
#+end_src

*** Optimizations
**** Replace Fn Call Sites

Final step replaces all functions calls with new function
objects =define_lambda= are renamed to /fn/. This removes all globals
variables unless the /fn/ defined is a closure. In which case it is
left as a global variable and the class implementation is prepended
with the global name for readability.

#+BEGIN_EXAMPLE
  (compile '((let [a 1]
               (defn adder [x]
                 (+ a x)))
             (defn my-inc [x] (+ 1 x))))

  (replace-fn-call-sites
   '((define_lambda G__3885 (a) (x) (_plus_ a x))
     (define_lambda G__3886 () (a) (def adder (lambda_object G__3885 a)))
     (define_lambda G__3887 () () (define_var a 1) ((lambda_object G__3886) a))
     (define_lambda G__3888 () (x) (_plus_ 1 x))
     ((lambda_object G__3887))
     (def my_inc (lambda_object G__3888))))

  ((define_lambda adder_G__3885 (a) (x) (_plus_ a x))
   (define_lambda G__3886 () (a) (def adder (lambda_object adder_G__3885 a)))
   (define_lambda G__3887 () () (define_var a 1) ((lambda_object G__3886) a))
   (define_lambda my_inc () (x) (_plus_ 1 x))
   ((lambda_object G__3887)))
#+END_EXAMPLE

#+name: core-compilation-symbol-conversion
#+begin_src clojure :tangle no
  (defn select-def-fn [form]
    (->> (select-form form (is-form? 'def))
         (filter (fn [[_ name val]]
                   (and (seq? val)
                        (= 'fir-lambda-object (first val)))))))

  (defn replace-fn-call-sites-pure [form fn-defs fn-table]
    (let [no-global-fn (reduce (fn[h v]
                                 (remove-form h (fn [f]
                                                  (and (seq? f)
                                                       (= 'def (first f))
                                                       (every? true? (map = f v))))))
                               form fn-defs)        
          embeded-fn-calls (reduce (fn[h [name gensym]]
                                     (morph-form h symbol?
                                                 (fn [f]
                                                   (if (= f name)
                                                     (list 'fir-lambda-object gensym)
                                                     f))))
                                   no-global-fn fn-table)
          embed-fn-names (reduce (fn[h [name gensym]]
                                   (morph-form h symbol?
                                               (fn [f]
                                                 (if (= f gensym)
                                                   name
                                                   f))))
                                 embeded-fn-calls fn-table)]
      embed-fn-names))

  (defn replace-fn-call-sites [options form]
    (if (:global-functions options)
      form
      (let [pure-fn-defs (->> (select-def-fn form)
                              (filter #(= 2 (-> % last count))))
            pure-fn-table (map (fn [[_ name [_ gensym]]] [name gensym]) pure-fn-defs)
            form (replace-fn-call-sites-pure form pure-fn-defs pure-fn-table)
            closure-fn-defs (->> (select-def-fn form)
                                 (filter #(not= 2 (-> % last count))))
            closure-fn-table (map (fn [[_ name [_ gensym]]] [name gensym]) closure-fn-defs)]
        (reduce (fn[h [name gensym]]
                  (morph-form h symbol?
                              (fn [f]
                                (if (= f gensym)
                                  (symbol (str name "_" gensym))
                                  f))))
                form closure-fn-table))))
#+end_src

**** Tree Shaking

Concats two forms. Shakes the first form by removing any symbols not
present in second form.

In order to keep the generated C++ code compact only the functions used
will be present in the generated source file. Which means if you don't
use /println/ anywhere in the code it won't be defined in the final
C++ file, but if you use it, it and everything it uses will be
defined, in the case of /println/ it will pull /apply/, /print/ and
/newline/ with it.

#+name: core-compilation-shake-concat
#+begin_src clojure
  (defn shake-concat
    ([header form]
     (let [header-no-macro (expand-macros-all header)
           header-symbols (->> (select-form header-no-macro (is-form? 'def))
                               (map second))
           header-fns (reduce (fn[h v] (assoc h (second v) v)) {} header-no-macro)
           objects (select-form header (is-form? 'defobject))
           macros (select-form header (is-form? 'defmacro))
           requires (select-form header (is-form? 'require))
           native-headers (select-form header (is-form? 'native-header))
           native-declarations (select-form header (is-form? 'native-declare))
           fns (atom {})
           _ (shake-concat (expand-macros-all (concat macros form)) header-fns fns)
           include-fns (->> @fns
                            (sort-by #(.indexOf header-symbols (key %)))
                            (map #(second %)))]
       (concat requires native-headers objects native-declarations include-fns macros form)))
    ([form built-in fns]
     (morph-form form symbol?
                 #(do (if-let [f (built-in %)]
                        (when (not (@fns %))
                          (swap! fns assoc % f)
                          (shake-concat f built-in fns))) %))))
#+end_src

**** Escape Analysis


     Determines that a certain allocation never escapes the local
     function. This means that allocation can be done on the stack.

#+name: core-compilation-escape-analysis-post
#+begin_src clojure
  (defn escape-analysis [form]
    (->> (escape-fn-calls form)
         (escape-fn-dispatch)
         (escape-lambdas)))
#+end_src

***** Escape Function Calls

#+name: core-compilation-escape-analysis
#+begin_src clojure
  (defn escape-fn-calls [form]
    (morph-form form
                (fn [f]
                  (and (seq? f)
                       (is-special-form? 'fir-lambda-object (first f))))
                (fn [f]
                  (let [[fn & args] f
                        fn (cons 'fir-invoke-lambda-stack (rest fn))]
                    (cons fn args)))))
#+end_src

***** Escape Dispatch Functions

#+name: core-compilation-escape-analysis
#+begin_src clojure
  (defn escape-fn-dispatch [form]
    (morph-form form
                (fn [f]
                  (is-special-form? 'fir-dispatch-lambda f))
                (fn [f]
                  (morph-form f
                              (fn [f]
                                (is-special-form? 'fir-lambda-object f))
                              (fn [f]
                                (cons 'fir-invoke-lambda-stack (rest f)))))))
#+end_src

***** Escape Lambda Classes

#+name: core-compilation-escape-analysis
#+begin_src clojure
  (defn escape-lambdas [form]
    (let [stack-lambda-pred (fn [f]
                              (and (seq? f)
                                   (is-special-form? 'fir-lambda-object (first f))))
          heap-lambdas (->> (select-form form (fn [f]
                                                (and (seq? f)
                                                     (is-special-form? 'fir-lambda-object f))))
                            (map second)
                            (into #{}))
          stack-lambdas (->> (select-form form (fn [f]
                                                 (and (seq? f)
                                                      (is-special-form? 'fir-invoke-lambda-stack f))))
                             (map second)
                             (into #{}))
          escapeable-lambdas (clojure.set/difference stack-lambdas heap-lambdas)]
      (morph-form form
                  (fn [f]
                    (and (seq? f)
                         (= (first f) 'fir-define-lambda)
                         (escapeable-lambdas (second f))))
                  #(cons 'fir-define-lambda-stack (rest %)))))
#+end_src

*** Helpers

During each pass we iterate over the nodes in the form using
/morph-form/ and /remove-form/, they both take a s-expression and a
predicate if the predicate returns true, morph-form will call /f/
passing the current node as an argument and replace that node with
/f/'s return value, remove-form on the other hand does what its name
suggests and removes the node when predicate returns true.

#+name: core-compilation-form-fns
#+begin_src clojure :tangle no
  (defn morph-form [tree pred f]
    (walk/prewalk (fn [x]
                    (if (pred x)
                      (f x)
                      x)) tree))

  (defn collect-form [tree pred f]
    (let [acc (atom [])]
      (doall (morph-form tree pred (fn [x] (swap! acc conj (f x)))))
      @acc))

  (defn remove-form [tree pred]
    (if (every? true? (map #(pred %) tree))
      (list )
      (loop [loc (zip/seq-zip tree)]
        (if (zip/end? loc)
          (zip/root loc)
          (recur
           (zip/next
            (if (pred (zip/node loc))
              (zip/remove loc)
              loc)))))))

  (defn select-form [tree pred]
    (loop [loc (zip/seq-zip tree)
           nodes []]
      (if (zip/end? loc)
        nodes
        (recur
         (zip/next loc)
         (if (pred (zip/node loc))
           (conj nodes (zip/node loc))
           nodes)))))

  (defn is-form? [& s]
    (fn [f]
      (and (seq? f)
           (some true? (map #(= % (first f)) s)))))
#+end_src

#+name: core-code-generation-misc
#+begin_src clojure :tangle no
  (declare process-reader-macros)

  (defn read-clojure-file [f]
    (try
      (->> (read-string (str \( (FileUtils/readFileToString (file f)) \)))
           (process-reader-macros))
      (catch Exception e
        (warn "error reading =>" f)
        (System/exit 1))))

  (defn read-clojure-file-from-url [f]
    (try
      (->> (read-string (str \( (read-from-url f) \)))
           (process-reader-macros))
      (catch Exception e
        (warn "error reading =>" f)
        (System/exit 1))))

  (defn is-special-form? [s f]
    (and (seq? f)
         (= (first f) s)))
#+end_src

** Code Generation

 Once compilation is complete the form is in a state that is very
 close to C++. running /emit/ on the form converts it into C++.

#+name: core-code-generation-emit
#+begin_src clojure :tangle no  
  (defmulti emit (fn [form _]
                   (cond (is-special-form? 'fir_define_lambda form) 'fir_define_lambda
                         (is-special-form? 'fir_define_lambda_stack form) 'fir_define_lambda_stack
                         (is-special-form? 'fir_dispatch_lambda form) 'fir_dispatch_lambda
                         (is-special-form? 'fir_lambda_object form) 'fir_lambda_object
                         (is-special-form? 'fir_invoke_lambda_stack form) 'fir_invoke_lambda_stack
                         (is-special-form? 'fir_define_var form) 'fir_define_var
                         (is-special-form? 'defobject form) 'defobject
                         (is-special-form? 'native_header form) 'native_header
                         (is-special-form? 'native_declare form) 'native_declare
                         (is-special-form? 'native_define form) 'native_define
                         (is-special-form? 'if form) 'if
                         (is-special-form? 'def form) 'def
                         (symbol? form) :symbol
                         (keyword? form) :keyword
                         (number? form) :number
                         (nil? form) :nil
                         (char? form) :char
                         (string? form) :string
                         (or (true? form) (false? form)) :boolean
                         (seq? form) :invoke-lambda)))

  (defn emit-ast
    [ast state]
    (reduce (fn[h v]
              (conj h (emit v state)))
            [] ast))
#+end_src

Without preprocessing following forms,

#+begin_src clojure :tangle no
  (emit '(list 1 2 3) (ref {}))
  
  (emit '(+ 1 2) (ref {}))
  
  (emit '(if (< a b)
           b a)
        (ref {}))
#+end_src

would evaluate to,

#+begin_example
  "run(list,obj<Number>(1),obj<Number>(2),obj<Number>(3))"
  "run(+,obj<Number>(1),obj<Number>(2))"
  "((<,b,a) ? a : b)"
#+end_example

So the actual compilation will just map emit to all forms passed and
/string-template/ will handle the job of putting them into an empty
C++ skeleton.

#+name: core-code-generation-misc
#+begin_src clojure :tangle no
  (defn append-to! [r ks v]
    (let [cv (reduce (fn[h v] (v h)) @r ks)]
      (swap! r assoc-in ks (conj cv v))))
#+end_src

#+name: core-code-generation-emit-source
#+begin_src clojure :tangle no
  (defn emit-source [form options]
    (let [state (atom {:native-headers []
                       :native-declarations []
                       :objects []
                       :symbol-table #{}
                       :lambdas []
                       :native-defines []})
          ast (compile form options)
          body (emit-ast ast state)]
      (when (:ast options)
        (pprint/pprint ast))
      (assoc @state :body body)))
#+end_src

*** Code Emitting
**** Object Types

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit :symbol [form state] (str form))

  (defmethod emit :string [form state] (str "obj<String>(\"" form "\")"))

  (defmethod emit :boolean [form state] (str "obj<Boolean>(" form ")"))

  (defmethod emit :nil [form state] "nil()")

  (defmethod emit :keyword [form state]
    (str "obj<Keyword>(" (reduce (fn[h v] (+ h (int v))) 0 (str form)) ")"))

  (defmethod emit :char [form state] (str "obj<Number>((number_t)" (int form) ")"))

  (defmethod emit :number [form state]
    (let [number (rationalize form)]
      (if (ratio? number)
        (let [num (numerator number)
              denom (denominator number)]
          (str "obj<Number>((number_t)" num ",(number_t)" denom ")"))
        (str "obj<Number>((number_t)" number ")"))))
#+end_src

**** Special Forms

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit 'def [[_ name & form] state]
    (append-to! state [:symbol-table] name)
    (str "(" name " = " (apply str (emit-ast form state)) ")"))

  (defmethod emit 'if [[_ cond t f] state]
    (let [cond (emit cond state)
          t (emit t state)
          f (if (nil? f) "nil()" (emit f state))]
      (apply str "(" cond " ? " t " : " f ")")))

  (defmethod emit :invoke-lambda [[fn & args] state]
    (invoke-lambda (emit fn state) (emit-ast args state)))

  (defmethod emit 'defobject [[_ name & spec] state]
    (append-to! state [:objects] (define-object name spec)) "")

  (defmethod emit 'fir_define_var [[_ name form] state]
    (str "var " name " = " (emit form state)))

  (defmethod emit 'native_header [[_ & declarations] state]
    (append-to! state [:native-headers] declarations) "")

  (defmethod emit 'native_declare [[_ declaration] state]
    (append-to! state [:native-declarations] declaration) "")

  (defmethod emit 'native_define [[_ define] state]
    (append-to! state [:native-defines] define) "")
#+end_src

**** Lambdas

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit 'fir_lambda_object [f state]
    (lambda-object-heap f))

  (defmethod emit 'fir_invoke_lambda_stack [f state]
    (lambda-object-stack f))

  (defn emit-define-lambda-aux [name env args body state]
    (let [native-declarations (filter #((is-form? 'native_declare) %) body)
          body (filter #(not ((is-form? 'native_declare) %)) body)
          body (cond  (empty? body)
                      ["nil();"]
                      (and (= 1 (count body))
                           (seq? (first body))
                           (= 'fir_dispatch_lambda (first (first body))))
                      [(emit (first body) state) "nil();"]
                      (and (= 1 (count body))
                           (string? (first body)))
                      (let [inline (first body) 
                            body (if (= (last inline) \;)
                                   inline
                                   (str inline \;))]
                        (if (neg? (.indexOf body "__result"))
                          [body "nil();"]
                          ["var __result;" body "__result;"]))
                      :default (reduce (fn[h v]
                                         (conj h (str v \;)))
                                       [] (emit-ast body state)))
          env (->> env
                   (flatten)
                   (filter #(and (not (= '& %))
                                 (not (= '_ %)))))]
      (doseq [dec native-declarations] 
        (emit dec state))
      [name env (lambda-arguments args) body]))

  (defmethod emit 'fir_define_lambda [[_ name env args & body] state]
    (let [[name env args body] (emit-define-lambda-aux name env args body state)]
      (append-to! state [:lambdas]
                  {:name name :env env :args args :body body}) ""))

  (defmethod emit 'fir_define_lambda_stack [[_ name env args & body] state]
    (let [[name env args body] (emit-define-lambda-aux name env args body state)]
      (append-to! state [:lambdas]
                  {:name name :env env :args args :body body :stack true}) ""))
#+end_src

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit 'fir_dispatch_lambda [[_ args-symbol & fns] state]
    (let [fns (->> fns
                   (partition 2))
          nil-dispatch (filter #(= (first %) 0) fns)]
      (str
       (if (not (empty? nil-dispatch))
         (str "if (" args-symbol ".is_nil())
                return " (lambda-object-stack
                          (->> nil-dispatch first second)) ".invoke(nil());")
         "")
       "switch(runtime::count(" args-symbol ")) {"
       (->> fns
            (map (fn [[count fn]]
                   (if (= count 'true)
                     (str "default: "
                          " return " (lambda-object-stack fn) ".invoke(" args-symbol ");")
                     (str "case " count " : "
                          " return " (lambda-object-stack fn) ".invoke(" args-symbol ");"))))
            (apply str)) "}")))
#+end_src

*** Code Templates
**** Objects

#+name: code-templates
#+begin_src clojure :tangle no
  (defn define-object [name body]
    (let [specs (into {} (map #(vector (first %) (rest %)) body))
          interface (if (nil? (specs 'interface))
                      "Object"
                      (apply str (rest (str (first (specs 'interface))))))
          interface-only (cond (specs 'interface) false
                               (empty? (specs 'new)) true
                               :defaul false)
          fns (specs 'fns)
          raw-fns (filter #(= 1 (count %)) fns)
          fns (filter #(= 3 (count %)) fns)]
      (-> (create-view "
       $if(object_type)$
         namespace runtime {
          namespace type {
           const size_t $type$ = $type_val$;}}
       $endif$

       $if(template)$
         template<$template:{$it$} ;separator=\",\"$>
       $endif$
       class $name$ : public $interface$ {
         $data:{$it$} ;separator=\"\n\"$
       public:
         $interfaces:{virtual $it$ = 0;} ;separator=\"\n\"$

         $new:{it | $name$($first(it)$){
           $first(rest(it))$
         }} ;separator=\"\n\"$

         $if(object_type)$
          size_t type(){ return runtime::type::$type$;}
         $endif$

         $if(equals)$
          var equals(var o){
           $equals$
          }
         $endif$

         $if(stream_console)$
         #if !defined(FERRET_DISABLE_STD_OUT)
          var stream_console(){
           $stream_console$
          }
         #endif
         $endif$

         $raw_fns:{it | $it$ } ;separator=\"\n\"$

         $fns:{it | $first(it)$($first(rest(it))$){
           $first(rest(rest(it)))$
         }} ;separator=\"\n\"$

         $ifdef_fns:{it | #$first(it)$
           $first(rest(it))$($first(rest(rest(it)))$){
           $first(rest(rest(rest(it))))$
         }
       #endif} ;separator=\"\n\"$
       };
       $post_code$")
          (fill-view! "name"           name)
          (fill-view! "template"       (specs 'template))
          (fill-view! "interface"      interface)
          (fill-view! "interface_only" interface-only)
          (fill-view! "object_type"    (cond (specs 'force_type) true
                                             interface-only false
                                             :default true))
          (fill-view! "type"           (str name))
          (fill-view! "type_val"       (gensym ""))
          (fill-view! "data"           (specs 'data))
          (fill-view! "new"            (specs 'new))
          (fill-view! "equals"         (first (specs 'equals)))
          (fill-view! "stream_console" (first (specs 'stream_console)))
          (fill-view! "interfaces"     (specs 'interfaces))
          (fill-view! "fns"            fns)
          (fill-view! "raw_fns"        raw-fns)
          (fill-view! "ifdef_fns"      (filter #(= 4 (count %)) (specs 'fns)))
          (fill-view! "post_code"      (first (specs 'post_code)))
          (render-view))))
#+end_src    

**** Lambdas

#+name: code-templates
#+begin_src clojure :tangle no
  (let [env (fn [[_ _ & env]]
              (->> env
                   (flatten)
                   (filter #(and (not (= '& %))
                                 (not (= '_ %))))))]
    (defn lambda-object-heap [l]
      (let [n (second l)
            e (env l)]
        (if (empty? e)
          (str "obj<" n ">()")
          (str "obj<" n ">(" (apply str (interpose \, e)) ")"))))

    (defn lambda-object-stack [l]
      (let [n (second l)
            e (env l)]
        (if (empty? e)
          (str n "()")
          (str n "(" (apply str (interpose \, e)) ")")))))

  (defn invoke-lambda [n args]
    (if (empty? args)
      (str "run(" n ")")
      (str "run(" n ","  (apply str (interpose \, args))")")))
#+end_src    

Initialize function arguments. Clojure style list structuring is supported.

#+name: code-templates
#+begin_src clojure :tangle no
  (let [set-var (fn [val arg accesor]
                  (str "var " val " = "
                       (reduce (fn[h v] (str v "(" h ")")) arg accesor)))
        nth (fn [pos]
              (flatten [(repeat pos "runtime::rest") "runtime::first"]))]
    
    (defn lambda-arguments
      ([args]
       (flatten (lambda-arguments args "_args_")))
      ([args name]
       (let [[args va-args] (if (some #{'&} args)
                              (split-at (.indexOf args '&) args)
                              [args []])]
         [(->> (map-indexed (fn [pos val] (vector pos val)) args)
               (filter #(not= (second %) '_))
               (reduce
                (fn [h [pos val]]
                  (let [accesor (nth pos)]
                    (conj h
                          (if (coll? val)
                            (lambda-arguments
                             val (reduce (fn[h v] (str v "(" h ")")) name accesor))
                            (set-var val name accesor))))) []))
          (if (empty? va-args)
            []
            (set-var (last va-args) name (repeat (count args) "runtime::rest")))]))))
#+end_src

#+name: code-templates
#+begin_src clojure :tangle no
  (defn lambda-definitions [lambdas]
    (-> (create-view
         "$lambdas: {lambda|
           $if(!lambda.stack)$
            class $lambda.name$  : public Lambda{
           $else$
            class $lambda.name$  \\{
           $endif$
             $lambda.env:{var $it$;} ;separator=\"\n\"$
           public:
             $if(lambda.env)$
               explicit $lambda.name$ ($lambda.env:{var $it$} ;separator=\",\"$) :
                 $lambda.env:{$it$($it$)} ;separator=\",\"$ { }
             $endif$
             $if(lambda.args)$
                 var invoke (var _args_);
             $else$
                 var invoke (var);
             $endif$
           };};separator=\"\n\n\"$")
        (fill-view! "lambdas" lambdas)
        (render-view)))

  (defn lambda-implementations [lambdas]
    (-> (create-view
         "$lambdas: {lambda|
           $if(lambda.args)$
               inline var $lambda.name$::invoke (var _args_)
           $else$
               inline var $lambda.name$::invoke (var)
           $endif$
               {
                 $lambda.args:{args | $args$; } ;separator=\"\n\"$
     
                 $trunc(lambda.body):{$it$} ;separator=\"\n\"$
                 return $last(lambda.body):{$it$} ;separator=\"\n\"$
               }
           };separator=\"\n\n\"$")
        (fill-view! "lambdas" lambdas)
        (render-view)))
#+end_src    

**** Program

#+name: code-templates
#+begin_src clojure :tangle no :noweb yes
  (defn solution-template [source]
    (let [{:keys [body lambdas symbol-table native-headers objects
                  native-declarations native-defines]} source
          native-headers (->> native-headers flatten (into #{}))]
      (-> (create-view "
          $native_defines:{$it$} ;separator=\"\n\"$

          $ferret_header$

          $native_headers:{#include \"$it$\"} ;separator=\"\n\"$

          // Runtime Prototypes
          namespace ferret{
           <<runtime-native-prototypes>>
           <<runtime-native-iterate-macro>>
          }

          // Objects
          namespace ferret{
           $objects:{$it$} ;separator=\"\n\"$
          }

          // Symbols
          namespace ferret{
           $symbols:{var $it$;} ;separator=\"\n\"$
          }

          $native_declarations:{$it$} ;separator=\"\n\"$

          // Runtime Implementations
          namespace ferret{
           <<runtime-native-math-misc>>
           <<runtime-native-implementations>>
           <<runtime-native-ranged-for>>
          }

          // Lambda Prototypes
          namespace ferret{
            $lambda_classes:{$it$} ;separator=\"\n\"$
          }

          // Command Line Arguments
          #if defined(FERRET_STD_LIB) &&                    \\
              !defined(FERRET_DISABLE_CLI_ARGS) &&   \\
              !defined(FERRET_DISABLE_STD_MAIN)
            ferret::var _star_command_line_args_star_;
          #endif

          // Lambda Implementations
          namespace ferret{
            $lambda_bodies:{$it$} ;separator=\"\n\"$
          }

          // Program Run
          namespace ferret{
            void program_run(){
             $body:{$it$;} ;separator=\"\n\"$ 
            }
          }

         <<runtime-native-program-run-std-main>>
         <<runtime-native-program-arduino>>\n")
          (fill-view! "ferret_header"       (read-from-url "ferret.h"))
          (fill-view! "native_headers"      native-headers)
          (fill-view! "body"                (filter #(not (empty? %)) body))
          (fill-view! "lambda_classes"      (lambda-definitions lambdas))
          (fill-view! "lambda_bodies"       (lambda-implementations lambdas))
          (fill-view! "symbols"             symbol-table)
          (fill-view! "native_declarations" native-declarations)
          (fill-view! "objects"             objects)
          (fill-view! "native_defines"      native-defines)
          (render-view))))
#+end_src

** Main
*** Options

   Default compile options, 

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn compile-options [& [options]]
      (merge {:compiler "g++"
              :compiler-options ["-std=c++11"]
              :source-extension "cpp"
              :base-name "solution"}
             options))

    (defn cpp-file-name [options]
      (str (:output-path options) (:base-name options) "." (:source-extension options)))
  #+end_src

   Read the /cpp/ file parse build options embedded in it.

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn compile-options-parse-source [file]
      (try
        (let [program (slurp file)
              options (->> program
                           (re-seq #"(?s)Ferret Build Configuration Begin.*?//(.*?)// Ferret Build Configuration")
                           (map second)
                           (map #(.replaceAll % "//" ""))
                           (map #(.replaceAll % "\n" " "))
                           (map read-string))
              keys (->> options
                        (map #(keys %))
                        flatten
                        (into #{})
                        (into []))
              combine (fn [key]
                        (->> options
                             (reduce (fn[h v]
                                       (if (nil? (key v))
                                         h
                                         (apply merge (flatten [h (key v)])))) #{})
                             (into [])))]
          (compile-options
           (reduce (fn[h v]
                     (assoc h v (combine v))) {} keys)))
        (catch Exception e
          (compile-options {}))))
  #+end_src

   Takes the compiler CLI arguments and a file name, returns a map of
   build options.

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn build-specs [input args]
      (fn []
        (let [base-name (org.apache.commons.io.FilenameUtils/getBaseName input)
              path (str (org.apache.commons.io.FilenameUtils/getPrefix input)
                        (org.apache.commons.io.FilenameUtils/getPath input))
              default-compiled-file (file (str path base-name ".cpp"))
              default-options (compile-options-parse-source default-compiled-file)]
          (-> default-options
              (assoc :input-file input)
              (assoc :base-name base-name)
              (assoc :path path)
              (assoc :output-path path)
              (assoc :ast (->> args :options :ast))
              (assoc :compile-program (->> args :options :compile))
              (assoc :release (->> args :options :release))
              (assoc :format-code (not (->> args :options :disable-formatting)))
              (assoc :global-functions (->> args :options :global-functions))
              (assoc :extra-source-files
                     (cond (not (empty? (:arguments args)))
                           (:arguments args)
                           (not (empty? (:extra-source-files default-options)))
                           (:extra-source-files default-options)
                           :default []))))))
  #+end_src

*** Compile to C++

   Compile the form to C++,

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn compile->cpp [form options]
      (let [file-name (cpp-file-name options)
            source (emit-source form options)
            solution (solution-template source)]
        (FileUtils/writeStringToFile (file file-name) (.trim solution))
        (info "compiled" "=>" file-name)
        true))
  #+end_src

*** Compile to Binary

   Compile C++ code to binary,

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn cxx-command [options]
      (if (:command options)
        (flatten ["/usr/bin/env" "sh" "-c" (:command options)])
        (let [cxx (if (System/getenv "CXX")
                    (System/getenv "CXX")
                    (:compiler options))
              cxx-options (concat (map #(str %) (:compiler-options options))
                                  (if (System/getenv "CXXFLAGS")
                                    (seq (.split (System/getenv "CXXFLAGS") " "))))
              source-files (map #(let [extension (org.apache.commons.io.FilenameUtils/getExtension %)]
                                   [(cond (= extension "c") ["-x" "c"]
                                          (= extension "c++") ["-x" "c++"]
                                          :default "")
                                    %])
                                (:extra-source-files options))]
          (flatten [cxx cxx-options source-files
                    ["-x" "c++"] (str (:base-name options) "." (:source-extension options))]))))

    (defn compile->binary [options]
      (let [command (cxx-command options)]
        (info "building" "=>" (apply str (interpose " " command)))
        (let [build-dir (if (empty? (:output-path options))
                          "./"
                          (:output-path options))
              ret (try
                    (with-sh-dir build-dir
                      (apply sh command))
                    (catch Exception e
                      (warn (str "error executing C++ compiler."))
                      (warn (str "" (.getMessage e)))
                      (System/exit 1)))]
          (if (not= 0 (:exit ret))
            (do (warn "build error")
                (warn (:err ret))
                (System/exit 1)))
          true)))
  #+end_src

*** Build Solution

    Compile and build program,

   #+name: core-code-compile-code
   #+begin_src clojure
     (defn clang-format [options]
       (let [file (cpp-file-name options)
             source (try (with-sh-dir "./"
                           (sh "clang-format" "-style" "{Standard: Cpp11}" file))
                         (catch Exception e nil))]
         (if source
           (do (info "formatting code") 
               (spit file (:out source)))
           (trace "install clang-format for formatted output (optional)"))))

     (defn build-solution [spec-fn]
       (let [{:keys [input-file compile-program format-code]} (spec-fn)]
         (info "dir =>" (System/getProperty "user.dir"))
         (info "file =>" input-file)
         
         (compile->cpp (read-clojure-file input-file) (spec-fn))
         
         (when format-code
           (clang-format (spec-fn)))
         
         (when compile-program
           (compile->binary (spec-fn)))))
   #+end_src

*** Compiler Main

    Compiler options,

   #+name: core-code-compile-code
   #+begin_src clojure
     (def program-options [["-i" "--input FILE" "Input File" :default "./core.clj"]
                           ["-c" "--compile" "Compile Solution"]
                           ["-w" "--watch-input" "Automatically recompile input file on change."]
                           [nil "--release" "Compile in Release Mode. Strip Debug Information."]
                           [nil "--disable-formatting" "Disables Solution Formatting Using clang-format."]
                           [nil "--global-functions" "Disables replace-fn-call-sites Optimization."]
                           [nil "--ast" "Print Intermediate AST."]
                           ["-h" "--help" "Print Help"]])
   #+end_src

   Compiler /main/,

   #+name: core-code-compile-code
   #+begin_src clojure
     (defn -main [& args]
       (let [args (parse-opts args program-options)
             {:keys [help input watch-input]} (:options args)]

         (when help
           (println "Ferret Compiler")
           (println (:summary args))
           (System/exit 0))

         (when (not (.exists (file input)))
           (warn "no input file")
           (System/exit 1))

         (let [specs (build-specs input args)]
           (if (not watch-input)
             (build-solution specs)
             (do (watcher/watcher [input]
                                  (watcher/rate 1000)
                                  (watcher/on-change
                                   (fn [_] (build-solution specs))))
                 @(promise)))
           (shutdown-agents))))
   #+end_src

*** Logging

  #+name: core-logging
  #+begin_src clojure
    (def log-formatter (proxy [java.util.logging.Formatter] []
                         (format
                           [^java.util.logging.LogRecord record]
                           (let [level (-> record .getLevel .toString clojure.string/lower-case)
                                 now (.getTime (java.util.Calendar/getInstance))
                                 frmtr (java.text.SimpleDateFormat. "HH:mm:ss")]
                             (str (.format frmtr now) " "
                                  (if (= level "warning")
                                    (color/red level)
                                    (color/green level)) " "
                                    (.getMessage record) "\n")))))

    (def log-handler (proxy [java.util.logging.Handler] []
                       (publish [^java.util.logging.LogRecord record]
                         (when (and (.isLoggable ^java.util.logging.Handler this record)
                                    (instance? java.io.PrintWriter *out*))
                           (.print ^java.io.PrintWriter *out* 
                                   (.format ^java.util.logging.Formatter log-formatter record))))
                       (flush [] (.flush ^java.io.PrintWriter *out*))
                       (close [] 
                         ;;(.close *out*)
                         )))

    (.addHandler (java.util.logging.Logger/getLogger "") log-handler)

    (let [^java.util.logging.LogManager$RootLogger logger (java.util.logging.Logger/getLogger "")]
      (doseq [^java.util.logging.Handler handler (.getHandlers logger)]
        (. handler setFormatter log-formatter)))

    (defn set-log-level! [& [level]]
      (let [^java.util.logging.LogManager$RootLogger logger
            (java.util.logging.Logger/getLogger "")
            level (cond (nil? level) java.util.logging.Level/ALL
                        (= level :trace) java.util.logging.Level/FINEST
                        (= level :debug) java.util.logging.Level/FINE
                        (= level :info) java.util.logging.Level/INFO
                        (= level :warn) java.util.logging.Level/WARNING)]
        
        (.setLevel logger level)
        (doseq [^java.util.logging.Handler handler (.getHandlers logger)]
          (. handler setLevel level))))

    (set-log-level! :info)
  #+end_src

* Native Core

Runtime needed on the C++ side to support [[Clojure Core]]. [[Object System][Object system]],
[[Reference Counting][garbage collection]],[[Memory Pool][memory pooling]] and host specific initialization
code. (ie. printing on different embedded systems.)

** Object System

All Ferret objects derive from a [[Base]] class.

 - [[Pointer]] - For Holding references to native objects.
 - [[Number]] - All numbers are kept as ratios (two ints).
 - [[Keyword]] 
 - [[Sequence]]
 - [[Lazy Sequence]]
 - [[String]] - As [[Sequence]] of [[Number]]s
 - [[Boolean]]
 - [[Atom]] - Mimics Clojure atoms.

Interfaces,

 - [[Lambda]] - Provides *invoke* for callable objects.
 - [[Seekable]] - Provides *first*, *rest*, *cons* for [[Seekable]]
   containers.

*** Base

All our types are derived from the base Object type. Which is a
=typedef= of =ObjectBase<FERRET_RC_POLICY,FERRET_ALLOC_POLICY>=. See
[[Reference Counting]] for available reference counting policies and
[[Memory Allocation]] for available allocation policies.

#+name: runtime-native-object
#+begin_src c++ :tangle no
  template <typename RC, typename MEM>
  class ObjectBase : public RC, public MEM{
  public:
    ObjectBase() : RC(0) { }
    ObjectBase(const ObjectBase& other): RC(other) { }
    virtual ~ObjectBase() { };
    
    virtual size_t type() = 0;
    
  #if !defined(FERRET_DISABLE_STD_OUT)
    virtual var stream_console() = 0;
  #endif
    
    virtual var equals(var o) = 0;
  };

  #if defined(FERRET_DISABLE_MULTI_THREADING)
    #define FERRET_RC_POLICY RC
  #elif defined(FERRET_DISABLE_RC)
    #define FERRET_RC_POLICY NoRC
  #else
    #define FERRET_RC_POLICY AtomicRC
  #endif

  #if defined(FERRET_MEMORY_POOL_SIZE)
    #define FERRET_ALLOC_POLICY PoolAllocator
  #else
    #define FERRET_ALLOC_POLICY SystemAllocator
  #endif

  typedef ObjectBase<FERRET_RC_POLICY,FERRET_ALLOC_POLICY> Object;
#+end_src

*** Objects
**** Pointer

A /Pointer/ object keeps a reference to a C++ pointer.

#+begin_src clojure
  (let [pointer (cxx "__result = obj<Pointer>(new int(42))")
        value   (cxx "int *ptr = pointer.cast<Pointer>()->pointer<int>();
                      __result = obj<Number>(*ptr)")]
    (println value))

  ;; => 42
#+end_src

#+name: runtime-clojure-pointer-object
#+begin_src clojure :tangle no
  (defobject Pointer
    (data "void* ptr;")
    (equals
     "return obj<Boolean>(ptr == o.cast<Pointer>()->pointer<void>());")
    (stream_console
     "fprintf(FERRET_STD_OUT, \"Pointer<%p>\",ptr); return nil();")
    (fns
     ("explicit Pointer(void* p) : ptr(p) {}")
     ("template<typename T> T* pointer" ""
      "return ((T *)ptr);")
     ("template<typename T> T& reference" ""
      "return (*(pointer<T>()));"))
    (force-type))
#+end_src

A /HeavyPointer/ object contains a pointer and a function to be called
right before garbage collection. This is similar to /finalizer/ in
Java.

#+begin_src clojure
  (let [val (cxx "__result = obj<Pointer>(new int(0));")
        gc (fn []
             (cxx "delete val.cast<Pointer>()->pointer<int>();")
             (println "Cleanup..."))]
    (heavy-pointer val gc))

  ;; => Cleanup...
#+end_src

#+name: runtime-clojure-heavy-pointer-object
#+begin_src clojure :tangle no
  (defobject HeavyPointer
    (data "var pointer;"
          "var gc_fn;")
    (equals
     "return pointer.equals(o.cast<HeavyPointer>()->container());")
    (stream_console
     "return pointer.cast<Pointer>()->stream_console();")
    (fns
     ("explicit HeavyPointer(var p, var gc) : pointer(p), gc_fn(gc) {}")
     ("~HeavyPointer" "" "run(gc_fn);")
     ("var container" "" "return pointer;"))
    (force-type))

  (defn heavy-pointer [ptr gc]
    "__result = obj<HeavyPointer>(ptr,gc)")
#+end_src

A /Value/ object keeps a native object. Useful when working with
modern C++ libraries that use smart pointers for memory management.

#+begin_src clojure
  (let [obj-42 (cxx "__result = obj<Value<int>>(42)")
        val-42  (cxx "__result = obj<Number>(obj_42.cast<Value<int>>()->value())")]
    (println val-42))

  ;; => 42
#+end_src

#+name: runtime-clojure-pointer-object
#+begin_src clojure :tangle no
  (defobject Value
    (template "typename T")
    (data "T val;")
    (equals "return obj<Boolean>(this == o.get());")
    (stream_console
     "fprintf(FERRET_STD_OUT, \"Value<%p>\", (void*)&val); return nil();")
    (fns
     ("explicit Value(T & t) : val(t) {}")
     ("T value" "" "return val;"))
    (force-type))
#+end_src

**** Number

There is only one number type in ferret. All numbers are kept as
ratios. Default number size is /int/. A ratio is kept in memory as two
/number_t/ size members named /_numerator/ and /_denominator/.

Default number configuration,

#+name: runtime-native-number-config-macros
#+begin_src c++ :tangle no
  namespace ferret{
  #if !defined(FERRET_NUMBER_TYPE)
     #define FERRET_NUMBER_TYPE int
  #endif

    typedef FERRET_NUMBER_TYPE           number_t;                   // Number Container.
    const   int                          float_precision = 1000;     // Used When Reading Floats.
  #if !defined(FERRET_DISABLE_STD_OUT)
    const   char*                        number_format = "%d";       // Number Format String (fprinf)
  #endif
  }
#+end_src

Helper functions,

#+name: runtime-native-prototypes
#+begin_src c++ :tangle no
  namespace runtime{
    #undef min
    #undef abs

    template<typename T>
    T min(T a, T b);

    template<typename T>
    T abs(T a);
  }
#+end_src

#+name: runtime-native-math-misc
#+begin_src c++ :tangle no
  namespace runtime{
    template<typename T>
    T min(T a, T b){
      return ((a)<(b)?(a):(b));
    }

    template<typename T>
    T abs(T a){
      return ((a)<0 ? -(a) : (a));
    }
  }
#+end_src

Number Object,

#+name: runtime-clojure-number-object
#+begin_src clojure :tangle no
  (defobject Number
    (data "number_t _numerator;"
          "number_t _denominator;")
    (equals "if (numerator() == 0 && o.cast<Number>()->numerator() == 0)
               return obj<Boolean>(true);
             else
               return obj<Boolean>((numerator() == o.cast<Number>()->numerator()) &&
                                   (denominator() == o.cast<Number>()->denominator()));")
    (stream_console
     "if (_denominator == 1)
        fprintf(FERRET_STD_OUT, number_format, _numerator);
      else if (_numerator == 0)
        fprintf(FERRET_STD_OUT, \"0\");
      else{
        fprintf(FERRET_STD_OUT, number_format,_numerator);
        fprintf(FERRET_STD_OUT, \"/\");
        fprintf(FERRET_STD_OUT, number_format,_denominator);
      }
      return nil();")
    
    (fns
     ("explicit Number(number_t x) : _numerator(x), _denominator((number_t)1) {}")
     ("explicit Number(number_t n, number_t dn) : _numerator(n), _denominator(dn) {
         simplificate();
       }")
     ("explicit Number(float x){
           float decimal = (x - (number_t)x) * (float)float_precision;
           number_t integer = (number_t)x;
           _numerator = decimal + (integer * float_precision);
           _denominator = float_precision;
           simplificate();
       }")
     ("number_t numerator" "" "return _numerator;")
     ("number_t denominator" "" "return _denominator;")
     ("template<typename T> T as" "" "T::unimplemented_function;")
     ("void simplificate" ""
      "int commondivisor = 1;
        for(number_t i=2;i<=runtime::min(runtime::abs(_numerator), runtime::abs(_denominator));i++)
          if( _numerator%i == 0 && _denominator%i == 0 )
            commondivisor = i;
        _numerator /= commondivisor;
        _denominator /= commondivisor;")
     ("~Number" "" ""))
    (post-code "template<> float Number::as(){
                   return (float)_numerator/(float)_denominator;
                }
                template<> number_t Number::as(){
                   if (_denominator == 1)
                     return (number_t)_numerator;
                   else
                     return (number_t)as<float>();
                }
                template<> char Number::as(){
                   return as<number_t>();
                }
                template <> number_t var::to() { return cast<Number>()->as<number_t>(); }
                template <> float var::to() { return cast<Number>()->as<float>(); }
                template <> char var::to() { return cast<Number>()->as<char>(); }")
    (force-type))
#+end_src

**** Keyword

Each keyword in the program is converted to an /Keyword/ object. A
/Keyword/ holds a simple hash of the keyword as an integer.

#+name: runtime-clojure-keyword-object
#+begin_src clojure :tangle no
  (defobject Keyword
    (data "int id;")
    (equals "return obj<Boolean>(id == o.cast<Keyword>()->container());")
    (stream_console
     "fprintf(FERRET_STD_OUT, \"%d\", id); return nil();")
    (fns
     ("explicit Keyword(int id) : id(id) {}")
     ("explicit Keyword(const char * str){
           id = 0;
           for (int i = 0; str[i] != '\\0'; i++){
             id = id + (int)str[i];
           }
       }")
     ("int container" ""
      "return id;"))
    (force-type))
#+end_src

**** Sequence

Linked list container implementing the seekable interface.

#+name: runtime-clojure-sequence-object
#+begin_src clojure :tangle no
  (defobject EmptySequence
    (interface :ISeekable)
    (equals "(void)o; 
             return obj<Boolean>(true);")
    (stream_console
     "fprintf(FERRET_STD_OUT, \"()\");
      return nil();")
    (fns
     ("var cons" "var"
      "return var(this);")
     ("var first" ""
      "return nil();")
     ("var rest" ""
      "return nil();"))
    (force-type))

  (defobject Sequence
    (interface :ISeekable)
    (data "var data;"
          "var next;")
    (equals
     "var itOther = o;
      FERRET_ITERATE(var(this),it){
        if (itOther.is_nil() || runtime::first(it).equals(runtime::first(itOther))  == false)
          return obj<Boolean>(false);
        itOther = runtime::rest(itOther);
      }

      if (itOther.is_nil())
        return obj<Boolean>(true);
      else
        return obj<Boolean>(false);")
    
    (stream_console
     "fprintf(FERRET_STD_OUT, \"(\");
        data.stream_console();
        FERRET_ITERATE(next,it){
          fprintf(FERRET_STD_OUT, \" \");
          runtime::first(it).stream_console();
        }
      fprintf(FERRET_STD_OUT, \")\");
      return nil();")
    (fns
     ("explicit Sequence(var d = var(), var n = var()) : data(d), next(n) {}")
     ("var cons" "var x"
      "return obj<Sequence>(x, var(this));")
     ("var first" ""
      "return data;")
     ("var rest" ""
      "return next;"))
    (post-code "namespace runtime {
                 inline var list() { 
                   return obj<EmptySequence>();
                 }
                 inline var list(var v) { 
                   return obj<Sequence>(v,nil());
                 }
        
                 template <typename... Args>
                 inline var list(var first, Args... args) { 
                   return obj<Sequence>(first, list(args...));
                 }
               }")
    (force-type))
#+end_src

**** Lazy Sequence

A lazy list container implementing the seekable interface.

#+name: runtime-clojure-sequence-object
#+begin_src clojure :tangle no
  (defobject LazySequence
    (interface :ISeekable)
    (data "var head;"
          "var thunk;")
    (equals
     "var itOther = o;
      FERRET_ITERATE(var(this),it){
        if (itOther.is_nil() || runtime::first(it).equals(runtime::first(itOther))  == false)
          return obj<Boolean>(false);
        itOther = runtime::rest(itOther);
      }

      if (itOther.is_nil())
        return obj<Boolean>(true);
      else
        return obj<Boolean>(false);")
    (stream_console
     "fprintf(FERRET_STD_OUT, \"(\");
      head.stream_console();
      FERRET_ITERATE(runtime::rest(var(this)),it){
        fprintf(FERRET_STD_OUT, \" \");
        runtime::first(it).stream_console();
      }
      fprintf(FERRET_STD_OUT, \")\");
      return nil();")
    (fns
     ("explicit LazySequence(var t) : thunk(t) {}")
     ("explicit LazySequence(var h, var t) : head(h), thunk(t) {}")
     ("var cons" "var x"
      "return obj<LazySequence>(x,thunk);")
     ("var first" ""
      "return head;")
     ("var rest" ""
      "return run(thunk);"))
    (force-type))
#+end_src

#+name: runtime-clojure-sequence-object
#+begin_src clojure :tangle no
  (defn new-lazy-seq [f]
    "__result = obj<LazySequence>(f);")

  (defmacro lazy-seq [& body]
    `(~'new-lazy-seq (~'fn [] ~@body)))
#+end_src

**** String

Strings are represented as a linked list of characters.

#+name: runtime-clojure-string-object
#+begin_src clojure :tangle no
  (defobject String
    (interface :ISeekable)
    (data "var data;")
    (equals "return obj<Boolean>(container().equals(o.cast<String>()->container()));")
    (stream_console
     "FERRET_ITERATE(data,it){ 
       char ch = runtime::first(it).to<char>();
       fprintf(FERRET_STD_OUT, \"%c\",ch);
      }
      return nil();")
    (fns
     ("explicit String() : data(nullptr) {}")
     ("explicit String(var s) : data(s) {}")
     ("explicit String(const char * str) {
           int length = 0;
           for (length = 0; str[length] != '\\0'; ++length);
           for (int i = --length; i >= 0; i--)
             data = runtime::cons(obj<Number>((number_t)str[i]),data);
       }")
     ("explicit String(const char * str,int length) {
           for (int i = --length; i >= 0; i--)
             data = runtime::cons(obj<Number>((number_t)str[i]),data);
       }")
     ("var container" ""
      "return data;")
     ("var cons" "var x"
      "return data.cast<ISeekable>()->cons(x);")
     ("var first" ""
      "return runtime::first(data);")
     ("var rest" ""
      "return runtime::rest(data);")
     ("ifdef FERRET_STD_LIB"
      "::std::string to_string" ""
      "::std::stringstream ss;
       FERRET_ITERATE(data,it){ss << runtime::first(it).to<char>();}
       return ss.str();"))
    (post-code "#ifdef FERRET_STD_LIB
                  template<>
                  inline var obj<String>(std::string s) {
                    return var(new String(s.c_str(), s.size()));
                  }
                #endif")
    (force-type))
#+end_src

**** Boolean

A boolean object,

#+name: runtime-clojure-boolean-object
#+begin_src clojure :tangle no
  (defobject Boolean
    (data "bool value;")
    (equals "return obj<Boolean>(value == (bool)o);")
    (stream_console
     "if (value)
        fprintf(FERRET_STD_OUT, \"true\"); 
      else
      fprintf(FERRET_STD_OUT, \"false\"); 
      return nil();")
    (fns
     ("explicit Boolean(bool b) : value(b) {}")
     ("bool container" ""
      "return value;"))
    (post-code "var::operator bool() const {
                  if (m_ptr == nullptr)
                    return false;
                  else if (m_ptr->type() == runtime::type::Boolean)
                    return static_cast<Boolean*>(m_ptr)->container();
                  else
                    return true;
                 }
                 var var::equals (var rhs){
                   if (get() == nullptr && rhs.get() != nullptr)
                     return obj<Boolean>(false);
                   if (get() != nullptr && rhs.get() == nullptr)
                     return obj<Boolean>(false);

                   if (get() == rhs.get())
                     return obj<Boolean>(true);
                   else if (runtime::is_seqable(*this) && runtime::is_seqable(rhs))
                     return get()->equals(rhs);
                   else if (m_ptr->type() != rhs.cast<Object>()->type())
                     return obj<Boolean>(false);
                   else
                     return get()->equals(rhs);
                  }")
    (force-type))
#+end_src

**** Atom

Mimics Clojure's /atom/. It is thread safe when used on system where
=FERRET_STD_LIB= is defined.

#+name: runtime-clojure-atom-object
#+begin_src clojure :tangle no
  (defobject Atom
    (data "var data;"
          "FERRET_NEW_LOCK(lock)")
    (equals "return obj<Boolean>(this == o.cast<Atom>());")
    (stream_console
     "fprintf(FERRET_STD_OUT, \"atom <\");
      data.stream_console();
      fprintf(FERRET_STD_OUT, \">\");
      return nil();")
    (fns
     ("explicit Atom(var d) : data(d) {}")
     ("var swap" "var f,var args"
      "FERRET_WITH_LOCK(lock,{
         args = runtime::cons(data, args);
         data = f.cast<Lambda>()->invoke(args);
       });
      return data;")
     ("var deref" ""
      "FERRET_WITH_LOCK(lock,{
         return data;
       });"))
    (force-type))
#+end_src

Operations on /Atoms/

#+name: runtime-clojure-atom-object
#+begin_src clojure :tangle no
  (defn atom [x]
    "__result = obj<Atom>(x)")

  (defn swap! [a f & args]
    "__result = a.cast<Atom>()->swap(f,args);")

  (defn reset! [a newval]
    (swap! a (fn [old curr] curr) newval))

  (defn deref [a]
    "__result = a.cast<Atom>()->deref();")
#+end_src

*** Interfaces
**** Seekable

All sequence functions use this interface to iterate seekable
containers.

#+name: runtime-clojure-seekable-interface
#+begin_src clojure :tangle no
  (defobject ISeekable
    (interfaces "var cons(var x)"
                "var first()"
                "var rest()")
    (fns ("virtual ~ISeekable" "" "")))
#+end_src

C++ API for the interface,

#+name: runtime-native-prototypes
#+begin_src c++ :tangle no
  namespace runtime {
    var first(var coll);
    var rest(var coll);
    var cons(var x, var seq);
    var nth(var seq, var index);
    var nth(var seq, int index);
    size_t count(var seq);
    var is_seqable(var seq);
  }
#+end_src

Range-based for loop support for seekable containers.

#+name: runtime-native-ranged-for
#+begin_src c++ :tangle no
  namespace runtime {
    struct range{
      var p;

      explicit range(var v) : p(v) { }
      range begin() const { return range(p); }
      range end() const { return range(var()); }

      bool operator!=(const range& other){
        return (p != other.p);
      }

      const range& operator++(){
        p = runtime::rest(p);
        return *this;
      }

      var operator*(){
        return runtime::first(p);
      }

    };
  }
#+end_src

#+name: runtime-native-implementations
#+begin_src c++ :tangle no
  namespace runtime{
    var first(var coll){
      if (coll.is_nil())
        return nil();
      else
        return coll.cast<ISeekable>()->first();
    }

    var rest(var coll){
      if (coll.is_nil())
        return runtime::list();
      else
        return coll.cast<ISeekable>()->rest();
    }

    var cons(var x, var seq){
      if (seq.is_nil())
        return runtime::list(x);
      if (seq.equals(runtime::list()) == true)
        return runtime::list(x);
      return seq.cast<ISeekable>()->cons(x);
    }

    var nth(var seq, int index){
      int itIdx = 0;
      FERRET_ITERATE(seq,it){
        if (index == itIdx)
          return runtime::first(it);
        itIdx++;
      }
      return nil();
    }
    
    var nth(var seq, var idx){
      return nth(seq,idx.to<number_t>());
    }
    
    size_t count(var seq){
      size_t acc = 0;
      FERRET_ITERATE(seq,it){ acc++; }
      return acc;
    }

    var is_seqable(var seq){
      if(seq.is_type(runtime::type::Sequence) || 
         seq.is_type(runtime::type::LazySequence))
        return obj<Boolean>(true);
      else
        return obj<Boolean>(false);
    }
  }
#+end_src

#+name: runtime-native-iterate-macro
#+begin_src c++ :tangle no
  #define FERRET_ITERATE(c,i) for(var i = c; !i.is_nil(); i = runtime::rest(i))
#+end_src

**** Lambda

Every lambda object implements the /Lambda/ interface. All lambdas are
executed via /invoke/ method that takes a sequence of vars as argument
or /nil()/ if there are non, this allows us to execute them in a
uniform fashion.

#+name: runtime-clojure-lambda-interface
#+begin_src clojure :tangle no
  (defobject Lambda
    (interfaces "var invoke(var args)")
    (equals "return obj<Boolean>(this == o.cast<Lambda>());")
    (stream_console
     "fprintf(FERRET_STD_OUT, \"lambda\"); return nil();")
    (force-type true))
#+end_src

Function invocation,

#+name: runtime-native-prototypes
#+begin_src c++ :tangle no
  template<typename T, typename... Args>
  inline var run(T fn, Args... args);
        
  template<typename T>
  inline var run(T fn);

  template<>
  inline var run(var);
#+end_src

#+name: runtime-native-implementations
#+begin_src c++ :tangle no
  template<typename T, typename... Args>
  inline var run(T fn, Args... args) {
    return fn.invoke(runtime::list(args...));
  }

  template<typename T>
  inline var run(T fn) {
    return fn.invoke(nil());
  }

  template<>
  inline var run(var fn) {
    return fn.cast<Lambda>()->invoke(nil());
  }

  template<typename... Args>
  inline var run(var fn, Args... args) {
    return fn.cast<Lambda>()->invoke(runtime::list(args...));
  }
#+end_src

** Memory Management
*** Object Allocation

All object allocations are done using *obj* function. It will return a
new *var* containing a pointer to an [[Object System][Object]]. *nil* is represented as a
*var* pointing to *nullptr*.

#+BEGIN_EXAMPLE
  var two = obj<Number>(2);
  var some_nil = nil();
#+END_EXAMPLE

#+name: runtime-native-object-allocation
#+begin_src c++ :tangle no
  template<typename FT, typename... Args>
  inline var obj(Args... args) {
    return var(new FT(args...));
  }

  inline var nil(){
    return var();
  }
#+end_src

*** Reference Counting

Garbage collection is handled by reference counting. Reference count
is kept within the [[Base][ObjectBase]] using one of the following reference
counting policies.

 - AtomicRC - Atomic reference counting. (using =std::atomic=)
 - RC - Non Atomic reference counting. (using =size_t=)
 - NoRC - No reference counting.

#+name: runtime-native-reference-counting
#+begin_src c++ :tangle no
  #if defined(FERRET_STD_LIB)
  class AtomicRC{
  public:
    explicit AtomicRC(size_t start) : ref_count(start) { }
    explicit AtomicRC(const AtomicRC& other){ ref_count.exchange(other.ref_count); }
      
    void inc_ref() { ref_count++; }
    bool dec_ref() { return (--ref_count == 0); }
      
  private:
    ::std::atomic<size_t> ref_count;
  };
  #endif

  class RC{
  public:
    explicit RC(size_t start) : ref_count(start) { }
    explicit RC(const RC& other){ ref_count = other.ref_count; }
      
    void inc_ref() { ref_count++; }
    bool dec_ref() { return (--ref_count == 0); }
      
  private:
    size_t ref_count;
  };

  class NoRC{
  public:
    explicit NoRC(size_t) { }
    explicit NoRC(const NoRC& ){ }
      
    void inc_ref() { }
    bool dec_ref() { return false; }
  };
#+end_src 

A /var/ holds a pointer to an Object, everything is passed around as
/vars/ it is responsible for incrementing/decrementing the reference
count, when it reaches zero it will automatically free the Object.

#+name: runtime-native-var
#+begin_src c++ :tangle no
  class var{
  public:
    explicit var(Object* ptr = nullptr) : m_ptr(ptr) { inc_ref(); }

    var(const var& p) : m_ptr(p.m_ptr) { inc_ref(); }
      
    ~var() { dec_ref(); }
    
    var& operator= (const var& p){
      return *this = p.m_ptr;
    }
    
    var& operator= (Object* ptr){
      if (m_ptr != ptr){
        dec_ref();
        m_ptr=ptr;
        inc_ref();
      }
      return *this;
    }

    var equals (var rhs);
    
    operator bool() const;

  #if !defined(FERRET_DISABLE_STD_OUT)
    var stream_console() {
      if (m_ptr != nullptr )
        m_ptr->stream_console();
      else
        fprintf(FERRET_STD_OUT, "nil");
      return var();
    }
  #endif
        
    Object* get() { return m_ptr; }
    
    template<typename T>
    T* cast() { return static_cast<T*>(m_ptr); }

    template<typename T>
    T to() { T::unimplemented_function; }

    bool is_type(size_t type) { 
      return (static_cast<Object*>(m_ptr)->type() == type);
    }

    bool is_nil() { 
      return (m_ptr == nullptr);
    }

  private:
    void inc_ref(){
      // Only change if non-null
      if (m_ptr) m_ptr->inc_ref();
    }
      
    void dec_ref(){
      // Only change if non-null
      if (m_ptr){
        // Subtract and test if this was the last pointer.
        if (m_ptr->dec_ref()){
          delete m_ptr;
          m_ptr = nullptr;
        }
      }
    }
      
    Object* m_ptr;
  };
#+end_src

*** Memory Allocation

Ferret supports various memory allocation schemes,

 - *malloc/free* - Allocations are handled by the system
   implementation. (Default memory management.)
 - *Memory Pooling* - On memory constraint systems such as
   microcontrollers Ferret can use a memory pool to avoid heap
   fragmentation and calling malloc/free. Effectively running with
   no heap, allocating all memory at compile time on the stack.
 - *Third party allocators* (i.e tcmalloc)
 - *Third party garbage collectors* (i.e The Boehm-Demers-Weiser
   conservative garbage collector.)

**** Default Allocator

[[Object]]s are allocated from system implementation.

#+name: runtime-native-memory-system-allocator
#+begin_src c++ :tangle no
  class SystemAllocator{
  public:
    void* operator new(size_t size){ return ::malloc(size); }
    void  operator delete(void * ptr){ ::free(ptr); }
  };
#+end_src 

**** Pool Allocator

When =FERRET_MEMORY_POOL_SIZE= is defined Ferret programs will use a
memory pool called =program_memory= instead of /mallac/,/free/ for
memory allocation, depending on the pool size Ferret will allocate /N/
bytes of memory on stack and all memory allocation happens in this
memory pool useful when working with very limited amount of memory,
such as micro controllers where you want complete control over the
memory and you need deterministic timing requirements.

#+name: runtime-native-memory-pool-allocator
#+begin_src c++ :tangle no
  #ifdef FERRET_MEMORY_POOL_SIZE

   #if !defined(FERRET_MEMORY_POOL_PAGE_TYPE)
    #define FERRET_MEMORY_POOL_PAGE_TYPE long
    #define FERRET_MEMORY_POOL_PAGE_COUNT                                   \
      (FERRET_MEMORY_POOL_SIZE / sizeof(FERRET_MEMORY_POOL_PAGE_TYPE))
   #else
    #define FERRET_MEMORY_POOL_PAGE_COUNT FERRET_MEMORY_POOL_SIZE
   #endif

   MemoryPool<FERRET_MEMORY_POOL_PAGE_TYPE, FERRET_MEMORY_POOL_PAGE_COUNT> program_memory;

   class PoolAllocator{
   public:
     void* operator new(size_t size){ return program_memory.allocate(size); }
     void  operator delete(void * ptr){ program_memory.free(ptr); }
   };
  #endif
#+end_src 

When /allocate/ is called the pool will scan the memory pool using
the /used/ bit array to find a block of memory big enough to
satisfy the request. If found, it will the mark the region as used and
return a pointer from /pool/ array to the user which points to
the memory block.

When a free request is received, we resolve the pointer in to the
memory pool read the book keeping information on how much memory
is allocated to this pointer and set these pages to unused.

Memory pool has several advantages, it will avoid fragmentation,
function related to each other will always keep their data close
to each other in the array which improves data locality.

#+name: runtime-native-memory-pool-allocator-implementation
#+begin_src c++ :tangle no
  #ifdef FERRET_MEMORY_POOL_SIZE
    template<size_t pool_size>
    class BitArray {
    private:
      uint8_t bits[pool_size / 8 + 1];

      inline size_t index(size_t i){
        return i / 8;
      }

      inline size_t offset(size_t i){
        return i % 8;
      }

    public:
      BitArray() : bits{ false } { }

      inline void set(size_t b){
        bits[index(b)] |= 1 << (offset(b));
      }

      inline void clear(size_t b){
        bits[index(b)] &= ~(1 << (offset(b)));
      }

      inline int get(size_t b){
        return (bits[index(b)] & (1 << (offset(b))));
      }
    };

    template<typename page_size, size_t pool_size>
    class MemoryPool{
    public:
      BitArray<pool_size> used;
      page_size pool[pool_size];
      size_t offset;
      FERRET_NEW_LOCK(lock)

      MemoryPool() : pool{0}, offset(0) { }

      inline size_t chunk_length(size_t size){
        size_t d = (size / sizeof(page_size));
        size_t f = (size % sizeof(page_size));

        if (f == 0)
          return d;
        else
          return (d + 1);
      }

      inline bool chunk_usable(size_t begin, size_t end){
        for(size_t i=begin; i < end; i++)
          if (used.get(i) != 0)
            return false;
        return true;
      }

      inline size_t next_page(size_t begin){
        for(size_t i=begin; i < pool_size; i++)
          if (used.get(i) == 0)
            return i;
        return pool_size;
      }

      inline int scan_pool(size_t pages_needed, size_t offset = 0){
        for(;;){
          size_t begin = next_page(offset);
          size_t end   = begin + pages_needed;
    
          if (end > pool_size)
            return -1;
          
          if (chunk_usable(begin, end))
            return begin;
    
          offset = end;
        }
      }

      void *allocate(size_t req_size){
        FERRET_WITH_LOCK(lock,{
            size_t length = chunk_length(++req_size);
            int page      = scan_pool(length, offset);

            if (page == -1){
              page = scan_pool(length);
              if (page == -1)
                return nullptr;
            }
          
            pool[page] = length;
            offset = page + length;
            for(size_t i = page; i < offset; i++)
              used.set(i);

            return &pool[++page];
          });
      }

      void free(void *p){
        FERRET_WITH_LOCK(lock,{
            ptrdiff_t begin = (static_cast<page_size*>(p) - pool) - 1;
            size_t end = begin + pool[begin];

            for(size_t i = begin ; i < end; i++)
              used.clear(i);
          });
      }
    };
  #endif
#+end_src

** Configuration

Ferret defaults to running in safe mode, which means 

  - Multi threading is disabled.
  - Console output is disabled.

Safe mode only requires a C++11 compiler, no third party library is
required including the C++ standard library. Following options can be
configured using /#define/ directives, or using /native-define/ or
/configure-runtime!/ from program code. Unless these options are
overridden in source file, they are auto configured during compilation
on supported platforms. (i.e Multi threading will be enabled on
Linux or Mac OS X.) On unsupported platforms Ferret defaults to
running in safe mode.

#+BEGIN_EXAMPLE
  (configure-runtime! FERRET_DISABLE_STD_OUT true)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  |--------------------------------+--------------+----------------------------------------------------------|
  | Define                         | Defult Value | Description                                              |
  |--------------------------------+--------------+----------------------------------------------------------|
  | FERRET_SAFE_MODE               | false        | Force Safe Mode.                                         |
  | FERRET_DISABLE_CLI_ARGS        | false        | Disable command line arguments.                          |
  | FERRET_DISABLE_STD_OUT         | true         | Disables output stream. (Reduces code size.)             |
  | FERRET_DISABLE_MULTI_THREADING | true         | Disable atomic reference counting.                       |
  | FERRET_DISABLE_STD_MAIN        | false        | Disables auto execution of ferret::program_run()         |
  | FERRET_DISABLE_RC              | Not Defined  | Disable Reference Counting. (When using third party GCs) |
  | FERRET_PROGRAM_MAIN            | Not Defined  | A function to execute after ferret::program_run()        |
  | FERRET_UART_RATE               | 9600         | Set default UART rate.                                   |
  | FERRET_NUMBER_TYPE             | int          | Default number_t type.                                   |
  |--------------------------------+--------------+----------------------------------------------------------|
#+END_EXAMPLE

** Initialization
*** Detect Hardware

Check for supported hardware or platform. If running on a known
hardware or platform break out of *Safe Mode* and set a flag
indicating platform.

#+name: runtime-native-detect-hardware
#+begin_src c++ :tangle no
  # define FERRET_CONFIG_SAFE_MODE TRUE

  #if !defined(FERRET_SAFE_MODE)
    #if defined(__APPLE__) ||                       \
      defined(_WIN32) ||                            \
      defined(__linux__) ||                         \
      defined(__unix__) ||                          \
      defined(_POSIX_VERSION)
    
      # undef  FERRET_CONFIG_SAFE_MODE
      # define FERRET_STD_LIB TRUE
    #endif
    
    #if defined(__SAM3X8E__)
      # define FERRET_HARDWARE_ARDUINO TRUE
      # define FERRET_HARDWARE_ARDUINO_DUE TRUE
    #elif defined(__AVR__)
      # define FERRET_HARDWARE_ARDUINO TRUE
      # define FERRET_HARDWARE_ARDUINO_UNO TRUE
    #elif defined(ARDUINO_SAMD_ZERO) && defined(__SAMD21G18A__)
      # define FERRET_HARDWARE_ARDUINO TRUE
      # define FERRET_HARDWARE_SPARKFUN_SAMD21 TRUE
      # define FERRET_DISABLE_STD_OUT TRUE
    #elif defined(_VARIANT_ARDUINO_101_X_)
      # define FERRET_HARDWARE_ARDUINO TRUE
      # define FERRET_HARDWARE_ARDUINO_101 TRUE
      # define FERRET_DISABLE_STD_OUT TRUE
    #endif
    
    #if defined(FERRET_HARDWARE_ARDUINO)
      # undef  FERRET_CONFIG_SAFE_MODE
      # define FERRET_DISABLE_MULTI_THREADING TRUE
      # define FERRET_DISABLE_STD_MAIN TRUE
    #endif
  #endif

  #if defined(FERRET_CONFIG_SAFE_MODE)
    # define FERRET_DISABLE_MULTI_THREADING TRUE
    # define FERRET_DISABLE_STD_OUT TRUE
  #endif
#+end_src

*** Import libraries

#+name: runtime-native-program-includes
#+begin_src c++ :tangle no
  #ifdef FERRET_STD_LIB
   #include <iostream>
   #include <sstream>
   #include <cstdio>
   #include <cstdlib>
   #include <cstddef>
   #include <atomic>
   #include <mutex>
  #endif

  #ifdef FERRET_HARDWARE_ARDUINO
   #include <Arduino.h>
   #include <stdio.h>
   #include <stdlib.h>
   #include <stdint.h>
  #endif

  #ifdef FERRET_CONFIG_SAFE_MODE
   #include <stdio.h>
   #include <stdlib.h>
   #include <stdint.h>
  #endif
#+end_src

*** Initialize Hardware

Default output configuration,

#+name: runtime-native-hardware-initialize
#+begin_src c++ :tangle no
  #if !defined(FERRET_UART_RATE)
    # define FERRET_UART_RATE 9600
  #endif

  # define FERRET_STD_OUT stdout
#+end_src

Setup IO on supported embedded systems,

#+name: runtime-native-hardware-initialize
#+begin_src c++ :tangle no
  #ifdef FERRET_HARDWARE_ARDUINO_UNO
      #if !defined(FERRET_DISABLE_STD_OUT)
       static FILE uartout = {0};
       static int uart_putchar (char c, FILE *stream){
           Serial.write(c);
           return 0 ;
       }
       #define FERRET_STD_OUT &uartout
       #define FERRET_INIT_STD_OUT                                       \
           Serial.begin(FERRET_UART_RATE);                                     \
           fdev_setup_stream (&ferret::uartout, ferret::uart_putchar, NULL, _FDEV_SETUP_WRITE);
      #endif
  #endif

  #ifdef FERRET_HARDWARE_ARDUINO_DUE
      #if !defined(FERRET_DISABLE_STD_OUT)
        # define FERRET_STD_OUT stdout
        # define FERRET_INIT_STD_OUT Serial.begin(FERRET_UART_RATE);
      #endif
  #endif
#+end_src

*** Program Run

Unless =FERRET_DISABLE_STD_MAIN= is *defined* a =main= function is
defined which is the designated start of the program. =program_run=
function contains all compiled code. Executing this function has
equivalent semantics to loading the Clojure source file into a virgin
Clojure interpreter and then terminating its execution. If
=FERRET_PROGRAM_MAIN= is defined, it will be called right after
=program_run=.

#+name: runtime-native-program-run-std-main
#+begin_src c++ :tangle no
  #if !defined(FERRET_DISABLE_STD_MAIN)
   #if defined(FERRET_DISABLE_CLI_ARGS) || !defined(FERRET_STD_LIB)
    int main(){
   #else
    int main(int argc, char* argv[]){
   #endif

      using namespace ferret;

     #if defined(FERRET_STD_LIB) && !defined(FERRET_DISABLE_CLI_ARGS)
      for (int i = argc - 1; i > -1 ; i--)
        _star_command_line_args_star_ =  runtime::cons(obj<String>(argv[i]),_star_command_line_args_star_);
     #endif

      program_run();

     #if defined(FERRET_PROGRAM_MAIN)
      run(FERRET_PROGRAM_MAIN);
     #endif
       
      return 0;
    }
  #endif
#+end_src

When a supported Arduino board is [[Detect Hardware][detected]]. Instead of using a
standard =main= function, Ferret uses Arduino compatible boot
procedure. 

#+name: runtime-native-program-arduino
#+begin_src c++ :tangle no
  #if defined(FERRET_HARDWARE_ARDUINO)
    void setup(){
      #if defined(FERRET_INIT_STD_OUT)
         FERRET_INIT_STD_OUT
      #endif

      using namespace ferret;
      #if defined(FERRET_PROGRAM_MAIN)
        program_run();
      #endif
    }
    void loop(){
      using namespace ferret;
      #if !defined(FERRET_PROGRAM_MAIN)
        program_run();
      #endif          

      #if defined(FERRET_PROGRAM_MAIN)
        run(FERRET_PROGRAM_MAIN);
      #endif
    }
  #endif
#+end_src

*** Configure Locking

Locking macros. They are disabled when running single threaded or on
an embedded platform. (=FERRET_STD_LIB= not defined.)

#+name: runtime-native-locking-macros
#+begin_src c++ :tangle no
  #if defined(FERRET_STD_LIB) && !defined(FERRET_DISABLE_MULTI_THREADING)
   #define FERRET_NEW_LOCK(symbol) ::std::mutex symbol;
   #define FERRET_WITH_LOCK(lock,code)                         \
     {                                                         \
     ::std::lock_guard<::std::mutex> ferret_scope_guard(lock); \
     code;                                                     \
     }
  #else
   #define FERRET_NEW_LOCK(symbol)
   #define FERRET_WITH_LOCK(lock,code) code;
  #endif
#+end_src

** Debugging Macros

Helper macros, to be used when debugging on the native side.

#+name: runtime-native-debugging-macros
#+begin_src c++ :tangle no
  #define FERRET_PRT_MSG(msg)                     \
    fprintf(FERRET_STD_OUT, msg);           \
    fprintf(FERRET_STD_OUT, "\n");

  #define FERRET_PRT_OBJ(o)                       \
    o.stream_console();                           \
    fprintf(FERRET_STD_OUT, "\n");
#+end_src

* Clojure Core

Once our object system is in place we can define rest of the runtime
(functions/macros) using our Clojure subset,

#+name: runtime-clojure-first
#+begin_src clojure :tangle no
  (defn first [x]
    "__result = runtime::first(x);")

  (defn second [x]
    "__result = runtime::first(runtime::rest(x));")

  (defn nil? [x] "__result = obj<Boolean>(x.is_nil())")
#+end_src

We can embed C++ code into our functions, which is how most of the
primitive functions are defined such as the /first/ function above,
once primitives are in place rest can be defined in pure Clojure,

#+name: runtime-clojure-println
#+begin_src clojure :tangle no
  (defn println [& more]
    (when more
      (apply print more))
    (newline))
#+end_src

As for macros, normal Clojure rules apply since they are expended using
Clojure, the only exception is that stuff should not expand to fully
qualified Clojure symbols, so the symbol /fn/ should not expand to
/clojure.core/fn/,


#+name: runtime-clojure-defn
#+begin_src clojure :tangle no
  (defmacro defn [name & body]
    `(~'def ~name (~'fn ~@body)))
#+end_src

** Functions

Multi arity functions are handled by the /fn/ macro. There are two
ways to define a function. For single arity functions it accepts the
following form,

#+begin_src clojure :tangle no
  (fn [a] a)
#+end_src

For multi arity functions it expects the following form,

#+begin_src clojure :tangle no
  (fn
    ([a] 1)
    ([a b] 2)
    ([a b & c] 3)
    ([a b [c d] & e] 4))
#+end_src

A multi arity function is a function that counts the number of its
arguments and then dispatches on the number of arguments to each
implementation.

#+name: runtime-clojure-fn-macro
#+begin_src clojure :tangle no
  (defmacro fn [& body]
    (if (vector? (first body))
      (localize-fn-args body)
      (let [fns (map #(localize-fn-args %) body)
            conds (->> (map first body)
                       (map (fn* [args] (filter #(not (= % '&)) args)))
                       (map #(count %)))
            form (if (pos? (.indexOf (last (map first body)) '&))
                   (let [conds (interleave conds fns)
                         arg-dispatch (drop-last 2 conds)
                         last (take-last 2 conds)]
                     (concat arg-dispatch [true (second last)]))
                   (interleave conds fns))]
        `(~'fn* (& (~'ferret-compiler-no-closure fn-arg-symbol#))
                (~'fir-dispatch-lambda fn-arg-symbol# ~@form)))))
#+end_src

A simple macro for calling inline C++,

#+name: runtime-clojure-fn-macro
#+begin_src clojure :tangle no
  (defmacro cxx [str]
    `((~'fn [] ~str)))
#+end_src

** I/O
*** print

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defnative print [& more]
    (on "!defined(FERRET_DISABLE_STD_OUT)"
        "if (more.is_nil())
           return nil();
         var f = more.cast<ISeekable>()->first();
         f.stream_console();
         var r = more.cast<ISeekable>()->rest();
         FERRET_ITERATE(r,it){
          fprintf(FERRET_STD_OUT, \" \");
          runtime::first(it).stream_console();
         }"))
#+end_src

*** newline

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defnative newline [& more]
    (on "!defined(FERRET_DISABLE_STD_OUT)"
        "fprintf(FERRET_STD_OUT, \"\\n\");"))
#+end_src

*** println

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  <<runtime-clojure-println>>
#+end_src

*** get-char

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defnative get-char []
    (on "defined FERRET_STD_LIB"
        "__result = obj<Number>(getchar());"))
#+end_src

*** sh

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defnative sh [cmd]
    (on "defined FERRET_STD_LIB"
        ("memory")
        "::std::shared_ptr<FILE> pipe(popen(cmd.cast<String>()->to_string().c_str(), \"r\"), pclose);
         if (!pipe) 
            __result = nil();
         char buffer[128];
         ::std::string result = \"\";
         while (!feof(pipe.get()))
          if (fgets(buffer, 128, pipe.get()) != NULL)
           result += buffer;
         __result = obj<String>(result);"))
#+end_src

*** system-exit

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defn system-exit [code]
    "::std::exit(code.to<number_t>());")
#+end_src

*** system-abort

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defn system-abort [code]
    "::std::abort();")
#+end_src

*** xor-stream-encoder/decoder

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defn xor-stream-encoder [write]
    (fn [seq]
      (let [length (count seq)
            checksum (reduce bit-xor length seq)]
        (write 0X06)
        (write 0X85)
        (write length)
        (doseq [s seq] 
          (write s))
        (write checksum))))
#+end_src

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defn xor-stream-header-ready [read in-waiting]
    (and (>= (in-waiting) 3) (= (read) 0X06) (= (read) 0X85)))

  (defn xor-stream-payload-ready [payload-size in-waiting]
    (>= (in-waiting) (inc (deref payload-size))))

  (defn xor-stream-decoder-goto [] true)

  (defn xor-stream-decoder [read in-waiting handler]
    (let [payload-size (atom nil)]
      (state-machine 
       (states
        (sync-header)
        (reset-payload    (reset! payload-size (read)))
        (wait-payload)
        (handle-payload   (let [payload (atom (list))]
                            (dotimes [_ (deref payload-size)]
                              (swap! payload conj (read)))
                            (when (= (read) (reduce bit-xor (deref payload-size) (deref payload)))
                              (swap! payload reverse)
                              (handler (deref payload))))))
       (transitions
        (sync-header     #(xor-stream-header-ready read in-waiting)           reset-payload)
        (reset-payload   xor-stream-decoder-goto                              wait-payload)
        (wait-payload    #(xor-stream-payload-ready payload-size in-waiting)  handle-payload)
        (handle-payload  xor-stream-decoder-goto                              sync-header)))))
#+end_src

** Looping
*** doseq

#+name: runtime-clojure-looping
#+begin_src clojure :tangle no
  (defmacro doseq [binding & body]
    `(~'_doseq_ ~(second binding)
                (~'fn [~(first binding)] ~@body)))

  (defn _doseq_ [seq f] "FERRET_ITERATE(seq,it){run(f,runtime::first(it));}")
#+end_src

*** dotimes

#+name: runtime-clojure-looping
#+begin_src clojure :tangle no
  (defmacro dotimes [binding & body]
    `(~'_dotimes_ ~(second binding)
                  (~'fn [~(first binding)] ~@body)))

  (defn _dotimes_ [t f] "for(number_t i = 0; i < t.to<number_t>(); i++) run(f,obj<Number>(i));")
#+end_src

** Conditionals
*** when

#+name: runtime-clojure-conditionals
#+begin_src clojure :tangle no
  (defmacro when [test & body]
    `(~'if ~test (~'do ~@body)))
#+end_src

*** cond

#+name: runtime-clojure-conditionals
#+begin_src clojure :tangle no
  (defmacro cond
    [& clauses]
    (when clauses
      (list 'if (first clauses)
            (if (next clauses)
              (second clauses)
              (throw (IllegalArgumentException.
                      "cond requires an even number of forms")))
            (cons 'cond (next (next clauses))))))
#+end_src

*** while

#+name: runtime-clojure-conditionals
#+begin_src clojure :tangle no
  (defn _while_ [pred fn]
    "while(run(pred))
       run(fn);")

  (defmacro while [test & body]
    `(~'_while_ (~'fn* [] ~test) (~'fn [] ~@body)))
#+end_src

*** forever

#+name: runtime-clojure-conditionals
#+begin_src clojure :tangle no
  (defmacro forever [& body]
    `(~'while true ~@body))
#+end_src

*** if-let

#+name: runtime-clojure-conditionals
#+begin_src clojure :tangle no
  (defmacro if-let
    ([bindings then]
     `(if-let ~bindings ~then nil))
    ([bindings then else & oldform]
     (let [form (bindings 0) tst (bindings 1)]
       `(let [temp# ~tst]
          (if temp#
            (let [~form temp#]
              ~then)
            ~else)))))
#+end_src

** Logical Operators
*** =

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn = [& args]
    "var curr = runtime::first(args);
     FERRET_ITERATE(runtime::rest(args),it){
      var first = runtime::first(it);
      if (curr.equals(first) == false)
        return obj<Boolean>(false);
      curr = first;
     }
     __result = obj<Boolean>(true);")
#+end_src

*** not=

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defmacro not= [& test]
    `(~'not (~'= ~@test)))
#+end_src

*** <

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn <
    ([] true)
    ([x] true)
    ([a b]
     "number_t an = a.cast<Number>()->numerator();
      number_t adn = a.cast<Number>()->denominator();

      number_t bn = b.cast<Number>()->numerator();
      number_t bdn = b.cast<Number>()->denominator();

      __result = obj<Boolean>((an * bdn) < (bn * adn));")
    ([a b & more]
     (if (< a b)
       (apply < (cons b more))
       false)))
#+end_src

*** >

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn >
    ([] true)
    ([x] true)
    ([a b]
     "number_t an = a.cast<Number>()->numerator();
      number_t adn = a.cast<Number>()->denominator();

      number_t bn = b.cast<Number>()->numerator();
      number_t bdn = b.cast<Number>()->denominator();

      __result = obj<Boolean>((an * bdn) > (bn * adn));")
    ([a b & more]
     (if (> a b)
       (apply > (cons b more))
       false)))
#+end_src

*** >=

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn >=
    ([] true)
    ([x] true)
    ([a b]
     "number_t an = a.cast<Number>()->numerator();
      number_t adn = a.cast<Number>()->denominator();

      number_t bn = b.cast<Number>()->numerator();
      number_t bdn = b.cast<Number>()->denominator();

      __result = obj<Boolean>((an * bdn) >= (bn * adn));")
    ([a b & more]
     (if (>= a b)
       (apply >= (cons b more))
       false)))
#+end_src

*** <=

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn <=
    ([] true)
    ([x] true)
    ([a b]
     "number_t an = a.cast<Number>()->numerator();
      number_t adn = a.cast<Number>()->denominator();

      number_t bn = b.cast<Number>()->numerator();
      number_t bdn = b.cast<Number>()->denominator();

      __result = obj<Boolean>((an * bdn) <= (bn * adn));")
    ([a b & more]
     (if (<= a b)
       (apply <= (cons b more))
       false)))
#+end_src

*** and

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defmacro and
    ([] true)
    ([x] x)
    ([x & next]
     `(~'if ~x (~'and ~@next) false)))
#+end_src

*** or

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defmacro or
    ([] nil)
    ([x] x)
    ([x & next]
     `(~'if ~x ~x (~'or ~@next))))
#+end_src

*** not

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn not [x]
    "if (x)
       return obj<Boolean>(false);
     __result = obj<Boolean>(true);")
#+end_src

*** true?

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn true? [x]
    "if (x)
       return obj<Boolean>(true);
     __result = obj<Boolean>(false);")
#+end_src

*** false?

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn false? [x]
    "if (!x)
       return obj<Boolean>(true);
     __result = obj<Boolean>(false);")
#+end_src

** Sequence
*** map

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn map [f col]
    (if (not (empty? col))
      (cons (f (first col))
            (lazy-seq (map f (rest col))))))
#+end_src

*** range

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn range
    ([high]
     (range 0 high))
    ([low high]
     (if (< low high)
       (cons low (lazy-seq
                  (range (inc low) high))))))
#+end_src

*** take

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn take [n coll]
    (if (not (empty? coll))
      (if (> n 0)
        (cons (first coll)
              (lazy-seq (take (- n 1) (rest coll)))))))
#+end_src

*** take-while

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn take-while [pred s]
    (if (and (not (empty? s))
             (pred (first s)))
      (cons (first s) (lazy-seq (take-while pred (rest s))))))
#+end_src

*** drop

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn drop [n coll]
    (if (and (pos? n)
             (not (empty? coll)))
      (drop (dec n) (rest coll))
      coll))
#+end_src

*** concat

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn concat
    ([]
     (list))
    ([x]
     (if (not (empty? x))
       (cons (first x) (lazy-seq (concat (rest x))))))
    ([x y]
     (if (not (empty? x))
       (cons (first x) (lazy-seq (concat (rest x) y)))
       (concat y))))
#+end_src

*** reduce

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn reduce
    ([f [sf & sr]]
     "var acc = run(f, runtime::first(sr), sf);
      FERRET_ITERATE(runtime::rest(sr),it){
        acc = run(f, acc, runtime::first(it));
      }
      __result = acc;")
    ([f acc coll]
     "FERRET_ITERATE(coll,it){
       acc = run(f, acc, runtime::first(it));
      }
      __result = acc;"))
#+end_src

*** list

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn list [& xs] "if (xs.is_nil())
                       __result = runtime::list();
                     else
                       __result = xs;")
#+end_src

*** list?

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn list? [x] "__result = obj<Boolean>(x.is_type(runtime::type::Sequence));")
#+end_src

*** empty?

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn empty? [x]
    (if (nil? x)
      true
      (= (list ) x)))
#+end_src

*** rest

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn rest [x] "var r = runtime::rest(x);
                  if (r.is_nil())
                    return runtime::list();
                  else 
                    __result = r;")
#+end_src

*** nth

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn nth [coll index] "__result = runtime::nth(coll,index);")
#+end_src

*** cons

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn cons [x seq] "__result = runtime::cons(x, seq);")
#+end_src

*** apply

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn apply [f args] "__result = f.cast<Lambda>()->invoke(args);")
#+end_src

*** conj

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn conj [coll & xs]
    (reduce (fn[h v] (cons v h)) (if (nil? coll) (list) coll) xs))
#+end_src

*** reverse

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn reverse [s]
    (reduce (fn[h v] (cons v h)) (list) s))
#+end_src

*** count

#+name: runtime-clojure-sequence-count
#+begin_src clojure :tangle no
  (defn count [s]
    (if (or (nil? s)
            (empty? s))
      0
      (reduce inc 0 s)))
#+end_src

*** filter

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn filter [pred coll]
    (if (not (empty? coll))
      (let [[f & r] coll]
        (if (pred f)
          (cons f (filter pred r))
          (filter pred r)))
      coll))
#+end_src

*** repeatedly

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn repeatedly
    ([f] (cons (f) (lazy-seq (repeatedly f))))
    ([n f] (take n (repeatedly f))))
#+end_src

** Math
*** float?

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn float? [x] "__result = obj<Boolean>(x.is_type(runtime::type::Number) &&
                                           (x.cast<Number>()->denominator() != 1));")
#+end_src

*** integer?

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn integer? [x] "__result = obj<Boolean>(x.is_type(runtime::type::Number) &&
                                             (x.cast<Number>()->denominator() == 1));")
#+end_src

*** zero?

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn zero? [x]
    (= x 0))
#+end_src

*** pos?

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn pos? [x]
    (> x 0))
#+end_src

*** neg?

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn neg? [x]
    (< x 0))
#+end_src

*** +

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn +
    ([] 0)
    ([x] x)
    ([h v]
     "number_t hn = h.cast<Number>()->numerator();
      number_t hdn = h.cast<Number>()->denominator();

      number_t vn = v.cast<Number>()->numerator();
      number_t vdn = v.cast<Number>()->denominator();

      number_t ndn = (hdn * vdn);

      __result = obj<Number>(((hn * vdn) + (vn * hdn)),ndn);")
    ([x y & more]
     (reduce + (+ x y) more)))
#+end_src

*** -

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn -
    ([x]
     (* -1 x))
    ([h v]
     "number_t hn = h.cast<Number>()->numerator();
      number_t hdn = h.cast<Number>()->denominator();

      number_t vn = v.cast<Number>()->numerator();
      number_t vdn = v.cast<Number>()->denominator();

      number_t ndn = (hdn * vdn);

      __result = obj<Number>(((hn * vdn) - (vn * hdn)),ndn);")
    ([x y & more]
     (reduce - (- x y) more)))
#+end_src

*** *

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn *
    ([] 1)
    ([x] x)
    ([h v]
     "number_t hn = h.cast<Number>()->numerator();
      number_t hdn = h.cast<Number>()->denominator();

      number_t vn = v.cast<Number>()->numerator();
      number_t vdn = v.cast<Number>()->denominator();

      __result = obj<Number>((hn * vn), (hdn * vdn));")
    ([x y & more]
     (reduce * (* x y) more)))
#+end_src

*** /

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn /
    ([x]
     (apply / (list 1 x)))
    ([h v]
     "number_t hn = h.cast<Number>()->numerator();
      number_t hdn = h.cast<Number>()->denominator();

      number_t vn = v.cast<Number>()->numerator();
      number_t vdn = v.cast<Number>()->denominator();

      __result = obj<Number>((hn * vdn),(vn * hdn));")
    ([x y & more]
     (reduce / (/ x y) more)))
#+end_src

*** inc

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn inc [x]
    (+ x 1))
#+end_src

*** dec

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn dec [x]
    (- x 1))
#+end_src

*** count

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  <<runtime-clojure-sequence-count>>
#+end_src

*** min / max

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn min
    ([x] x)
    ([x & r]
     (reduce (fn[h v]
               (if (< h v)
                 h v))
             x r)))

  (defn max
    ([x] x)
    ([x & r]
     (reduce (fn[h v]
               (if (> h v)
                 h v))
             x r)))
#+end_src

*** mod

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn mod [num div] "__result = obj<Number>((num.to<number_t>() % div.to<number_t>()));")
#+end_src

*** floor

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn floor [x] "__result = obj<Number>(x.to<number_t>());")
#+end_src

*** scale

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn scale [x in-min in-max out-min out-max]
    (+ (/ (* (- x in-min) (- out-max out-min)) (- in-max in-min)) out-min))
#+end_src

*** clamp

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn clamp [x min max]
    (cond
      (> x max) max
      (< x min) min
      true x))
#+end_src

*** bit-and

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-and [x y] "__result = obj<Number>((x.cast<Number>()->numerator() &
                                               y.cast<Number>()->numerator()));")
#+end_src

*** bit-not

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-not [x] "__result = obj<Number>(~x.cast<Number>()->numerator());")
#+end_src

*** bit-or

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-or [x y] "__result = obj<Number>((x.cast<Number>()->numerator() |
                                              y.cast<Number>()->numerator()));")
#+end_src

*** bit-xor

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-xor [x y] "__result = obj<Number>((x.cast<Number>()->numerator() ^
                                               y.cast<Number>()->numerator()));")
#+end_src

*** bit-shift-left

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-shift-left [x n] "__result = obj<Number>((x.cast<Number>()->numerator() <<
                                                      n.cast<Number>()->numerator()));")
#+end_src

*** bit-shift-left

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-shift-left [x n] "__result = obj<Number>((x.cast<Number>()->numerator() <<
                                                      n.cast<Number>()->numerator()));")
#+end_src

*** bit-shift-right

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-shift-right [x n] "__result = obj<Number>((x.cast<Number>()->numerator() >>
                                                       n.cast<Number>()->numerator()));")
#+end_src

*** number-split

Split a number into bytes.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn number-split [n]
    "number_t val = n.to<number_t>();
     unsigned char *p = (unsigned char*)&val;
     __result = runtime::list();
     for(size_t i = 0; i < sizeof(number_t); i++)
       __result = runtime::cons(obj<Number>((number_t)p[i]),__result);")
#+end_src

*** number-combine

Combine a list of bytes to a number.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn number-combine [s]
    "number_t res = 0;
     for(size_t i = 0; i < sizeof(number_t); i++){
      int idx = (sizeof(number_t) - i - 1);
      var obj = runtime::nth(s,idx);
      number_t val = obj.to<number_t>();
      res |= val << (i * 8);
     }
     __result = obj<Number>(res);")
#+end_src

*** sqrt

Square root.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defnative sqrt [s]
    (on "defined FERRET_STD_LIB"
        ("cmath")
        "__result = obj<Number>((float)::sqrt(s.to<float>()));")
    (on "defined FERRET_HARDWARE_ARDUINO"
        "__result = obj<Number>((float)::sqrt(s.to<float>()));"))
#+end_src

** Concurrency
*** thread

Runs the given lambda in a thread,

#+name: runtime-clojure-bit-operations
#+begin_src clojure :tangle no
  (defnative thread [f]
    (on "defined(FERRET_STD_LIB) && !defined(FERRET_DISABLE_MULTI_THREADING)"
        ("thread")
        "::std::thread ([f](){return run(f);}).detach();"))
#+end_src

** Timing
*** millis

Return current time in milliseconds,

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defnative millis []
    (on "defined FERRET_STD_LIB"
        "auto now = ::std::chrono::system_clock::now();
         auto epoch = now.time_since_epoch();
         auto time = ::std::chrono::duration_cast<::std::chrono::milliseconds>(epoch).count();
         __result = obj<Number>((number_t) time);")
    (on "defined FERRET_HARDWARE_ARDUINO"
        "__result = obj<Number>((number_t)::millis());"))
#+end_src

*** sleep

Sleep current thread for *t* milliseconds,

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defnative sleep [t]
    (on "defined FERRET_STD_LIB"
        ("chrono" "thread")
        "auto duration = ::std::chrono::milliseconds(t.to<number_t>());
         ::std::this_thread::sleep_for(duration);")
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::delay(t.to<number_t>());"))
#+end_src

*** time-fn

Takes a function *f* and returns the number of milliseconds it takes
to run,

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defn time-fn [f]
    (let [start (millis)]
      (f)
      (- (millis) start)))
#+end_src

*** benchmark

Runs the function *f* *n* times and return the average time it takes
function *f* to run in milliseconds,

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defn benchmark [f n]
    (let [values (map (fn [_] (time-fn f)) (range n))]
      (floor (/ (apply + values) n))))
#+end_src

*** fn-throttler

    Returns a new function that limits the throughput of the given
    function. When called faster than ==rate== it can either block or
    return ==nil== immediately.

#+BEGIN_EXAMPLE
  (defn ping []
    (println "Ping!"))

  (def throttled-ping (fn-throttler ping 1 :second :blocking))

  ;; Ping console every second
  (forever
   (throttled-ping))
#+END_EXAMPLE

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defn fn-throttler-aux-blocking [f rate-ms t-last-run]
    (fn [& args]
      (let [elapsed (- (millis) @t-last-run)
            left-to-wait (- rate-ms elapsed)]
        (when (pos? left-to-wait)
          (sleep left-to-wait)))
      (let [ret (apply f args)]
        (reset! t-last-run (millis))
        ret)))

  (defn fn-throttler-aux-non-blocking [f rate-ms t-last-run]
    (fn [& args]
      (let [elapsed (- (millis) @t-last-run)
            left-to-wait (- rate-ms elapsed)]
        (when (not (pos? left-to-wait))
          (let [ret (apply f args)]
            (reset! t-last-run (millis))
            ret)))))

  (defmacro fn-throttler [f rate unit policy]
    (let [unit->ms {:microsecond 0.001 :millisecond 1
                    :second 1000 :minute 60000
                    :hour 3600000 :day 86400000
                    :month 2678400000}
          rate-ms (/ (unit->ms unit) rate)
          state '(atom (millis))]
      (if (= policy :blocking)
        `(~'fn-throttler-aux-blocking ~f ~rate-ms ~state)
        `(~'fn-throttler-aux-non-blocking ~f ~rate-ms ~state))))
#+end_src

** Misc
*** rand

Returns a random floating point number between 0 (inclusive) and n
(default 1) (exclusive).

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defnative rand-aux []
    (on "defined FERRET_STD_LIB"
        ("random")
        "::std::random_device ferret_random_device;
         ::std::mt19937_64 ferret_random_generator(ferret_random_device());
         ::std::uniform_real_distribution<float> ferret_random_distribution(0.0,1.0);"
        "__result = obj<Number>(ferret_random_distribution(ferret_random_generator));"))

  (defn rand
    ([]
     (rand-aux))
    ([x]
     (* x (rand-aux))))
#+end_src

*** rand-int

Returns a random integer between 0 (inclusive) and n (exclusive).

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defn rand-int
    [x]
    (floor (rand x)))
#+end_src

*** identity

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defn identity [x] x)
#+end_src

*** ->>

Threads the expr through the forms. Inserts x as the
last item in the first form, making a list of it if it is not a
list already. If there are more forms, inserts the first form as the
last item in second form, etc.

#+name: runtime-clojure-thread-macro
#+begin_src clojure :tangle no
  (defmacro ->> [x & forms]
    (loop [x x, forms forms]
      (if forms
        (let [form (first forms)
              threaded (if (seq? form)
                         `(~(first form) ~@(next form)  ~x)
                         (list form x))]
          (recur threaded (next forms)))
        x)))
#+end_src

*** doto

Evaluates x then calls all of the methods and functions with the
value of x supplied at the front of the given arguments.  The forms
are evaluated in order.  Returns x.

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defmacro doto
    [x & forms]
    (let [gx (gensym)]
      `(let [~gx ~x]
         ~@(map (fn [f]
                  (if (seq? f)
                    `(~(first f) ~gx ~@(next f))
                    `(~f ~gx)))
                forms)
         ~gx)))
#+end_src

** Control
*** State Machines

This macro allows users to define state machines using the following
DSL,

#+begin_src clojure :tangle no
  (def two-state-machine
    (state-machine 
     (states
      (off (println "Off"))
      (on (println "On")))
     (transitions
      (off
       (fn [] true) on)
      (on
       (fn [] true) off))))

  (dotimes [i 10]
    (two-state-machine))
#+end_src

Each transition takes a list of /fn/ /state/ pairs first function that
returns true, returns the next state.

#+name: runtime-clojure-state-machine
#+begin_src clojure :tangle no
  (defmacro state-machine [[_ & states] [_ & transitions]]
    (let [transitions (reduce
                       (fn [h v]
                         (let [[state & conds] v
                               conds (->> (partition 2 conds)
                                          (reduce (fn [h v]
                                                    (conj h `(~(first v)) (second v)))
                                                  ['cond]))]
                           (conj h (list '= 'state state) (concat conds [true state]))))
                       ['cond] transitions)]
      `(let [~@(reduce (fn [h v] (conj h (first v) `(~'fn [] ~@(rest v)))) [] states)
             machine-state# (~'atom ~(-> states first first))]
         (~'fn []
           ((~'deref machine-state#))
           (~'swap! machine-state# (~'fn [~'state] (~@transitions)))))))
#+end_src

*** PID Control

From Wikipedia: 

#+BEGIN_QUOTE
A PID controller calculates an 'error' value as the difference between
a measured [Input] and a desired setpoint. The controller attempts to
minimize the error by adjusting [an Output].
#+END_QUOTE

From [[http://playground.arduino.cc/Code/PIDLibrary][PIDLibrary]],

#+BEGIN_QUOTE
So, you tell the PID what to measure (the "Input",) Where you want
that measurement to be (the "Setpoint",) and the variable to adjust
that can make that happen (the "Output".) The PID then adjusts the
output trying to make the input equal the setpoint.
#+END_QUOTE

#+begin_src clojure :tangle no
  (def controller (pid-controller :kp 0.5
                                  :ki 0
                                  :kd 0
                                  :set-point 5
                                  ;;in min - in max - out min - out max
                                  :bounds [0 10 0 10]
                                  :continuous false))

  (println "Control" (controller 0))
#+end_src

Ported from,

#+begin_src java
  /*
   ,* *********************************************************
   ,* Copyright (c) 2009 - 2015, DHBW Mannheim - Tigers Mannheim
   ,* Project: TIGERS - Sumatra
   ,* Date: Jun 10, 2015
   ,* Author(s): Nicolai Ommer <nicolai.ommer@gmail.com>
   ,* *********************************************************
   ,*/

  /**
   ,* @author Nicolai Ommer <nicolai.ommer@gmail.com>
   */
#+end_src

#+name: runtime-clojure-pid-controller
#+begin_src clojure :tangle no
  (defobject PIDController
    (template "typename T")
    (data "T p;"
          "T i;"
          "T d;"
          "T maximum_output;"
          "T minimum_output;"
          "T maximum_input;"
          "T minimum_input;"
          "bool continuous;"
          "T prev_error;"
          "T total_error;"
          "T setpoint;"
          "T error;"
          "T result;"
          "T input;")
    (new ("var kp, var ki, var kd, var inMin, var inMax, var outMin, var outMax, var cont"
          "p = kp.to<T>();
           i = ki.to<T>();
           d = kd.to<T>();
           maximum_output = outMax.to<T>();
           minimum_output = outMin.to<T>();
           maximum_input = inMax.to<T>();
           minimum_input = inMin.to<T>();
           continuous = cont.cast<Boolean>()->container();
           prev_error = 0;
           total_error = 0;
           setpoint = 0;
           error = 0;
           result = 0;
           input = 0;"))
    (equals "return obj<Boolean>(this == o.cast<PIDController>());")
    (stream_console "fprintf(FERRET_STD_OUT, \"PIDController\"); return nil();")
    (fns
     ("var update" "var in"
      "input = in.to<T>();

       // Calculate the error signal
       error = setpoint - input;

       // If continuous is set to true allow wrap around
       if (continuous) {
          if (runtime::abs(error) > ((maximum_input - minimum_input) / 2)) {
            if (error > 0) {
                  error = (error - maximum_input) + minimum_input;
            } else {
                  error = (error + maximum_input) - minimum_input;
            }
          }
       }
       
       /*
        ,* Integrate the errors as long as the upcoming integrator does
        ,* not exceed the minimum and maximum output thresholds
        ,*/
       if ((((total_error + error) * i) < maximum_output) &&
            (((total_error + error) * i) > minimum_output)) {
          total_error += error;
       }
       
       // Perform the primary PID calculation
       result = ((p * error) + (i * total_error) + (d * (error - prev_error)));
       
       // Set the current error to the previous error for the next cycle
       prev_error = error;
       
       // Make sure the final result is within bounds
       if (result > maximum_output) {
          result = maximum_output;
       } else if (result < minimum_output) {
          result = minimum_output;
       }

       return obj<Number>(result);")
     
     ("void set_setpoint" "var p"
      "T sp = p.to<T>();
       if (maximum_input > minimum_input) {
          if (sp > maximum_input) {
            setpoint = maximum_input;
          } else if (sp < minimum_input) {
            setpoint = minimum_input;
          } else {
            setpoint = sp;
          }
       } else {
          setpoint = sp;
       }")
     
     ("void reset" ""
      "prev_error = 0;
       total_error = 0;
       result = 0;")))
#+end_src

#+name: runtime-clojure-pid-controller
#+begin_src clojure :tangle no
  (defn pid-controller-create [set-point kp ki kd in-min in-max out-min out-max continuous]
    "var p = obj<PIDController<float>>(kp, ki, kd, in_min, in_max, out_min, out_max, continuous);
     p.cast<PIDController<float>>()->set_setpoint(set_point);
     __result = p;")

  (defn pid-controller-run [controller input]
    "__result = controller.cast<PIDController<float>>()->update(input)")

  (defmacro pid-controller [& options]
    (let [options (apply hash-map options)
          {:keys [container kp ki kd set-point bounds continuous]} options
          [in-min in-max out-min out-max] bounds]
      `(~'let [controller#
               (~'pid-controller-create
                ~set-point ~kp ~ki ~kd ~in-min ~in-max ~out-min ~out-max ~continuous)]
         (~'fn [input#]
           (~'pid-controller-run controller# input#)))))
#+end_src

** GPIO
*** pin-mode

Configures the specified pin to behave either as an input or an
output.

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defnative pin-mode-input [pin]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "pinMode(pin.to<number_t>(), INPUT);"))

  (defnative pin-mode-output [pin]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "pinMode(pin.to<number_t>(), OUTPUT);"))

  (defmacro pin-mode [pin mode]
    (if (= mode :input)
      `(~'pin-mode-input  ~pin)
      `(~'pin-mode-output ~pin)))
#+end_src

*** digital-write

Write a HIGH or a LOW value to a digital pin.

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defnative digital-write-high [pin]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "digitalWrite(pin.to<number_t>(), HIGH);"))

  (defnative digital-write-low [pin]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "digitalWrite(pin.to<number_t>(), LOW);"))

  (defmacro digital-write [pin mode]
    (if (= mode :high)
      `(~'digital-write-high ~pin)
      `(~'digital-write-low  ~pin)))
#+end_src

*** digital-read

Reads the value from a specified digital pin, either HIGH or LOW.

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defnative digital-read [pin]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "if (digitalRead(pin.to<number_t>()) == HIGH)
           __result = obj<Boolean>(true);
         else
           __result = obj<Boolean>(false);"))
#+end_src

*** analog-write

Writes an analog value (PWM wave) to a pin.

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defnative analog-write [pin val]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "analogWrite(pin.to<number_t>(),val.to<number_t>());"))
#+end_src

*** analog-read

Reads the value from the specified analog pin.

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defnative analog-read [pin]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "__result = obj<Number>((number_t)analogRead(pin.to<number_t>()));"))
#+end_src

*** analog-write-resolution

Sets the resolution of the *analog-write*

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defnative analog-write-resolution [bit]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "analogWriteResolution(bit.to<number_t>());"))
#+end_src

*** analog-read-resolution

Sets the size (in bits) of the value returned by *analog-read*.

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defnative analog-read-resolution [bit]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "analogReadResolution(bit.to<number_t>());"))
#+end_src

*** tone/noTone

Generates a square wave of the specified frequency (and 50% duty
cycle) on a pin.

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defnative tone [pin freq]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "tone(pin.to<number_t>(),freq.to<number_t>());"))
#+end_src

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defnative no-tone [pin]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "noTone(pin.to<number_t>());"))
#+end_src

*** definterrupt

Registers an interrupt on the /symbol/ for the given pin and mode. See
[[https://www.arduino.cc/en/Reference/AttachInterrupt][attachInterrupt()]] for more information.

#+BEGIN_EXAMPLE
  (defn control-light []
    (if (digital-read input-pin)
      (digital-write debug-pin :high)
      (digital-write debug-pin :low)))

  (definterrupt control-light input-pin :change)
#+END_EXAMPLE

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defmacro definterrupt [callback pin mode]
    (let [pin (if (number? pin)
                pin
                (str (symbol-conversion pin) ".to<number_t>()"))
          mode (cond (= mode :low) "LOW"
                     (= mode :change) "CHANGE"
                     (= mode :rising) "RISING"
                     (= mode :falling) "FALLING"
                     (= mode :high) "HIGH")
          callback-cpp  (symbol-conversion callback)
          callback-clj (symbol (str callback "-callback-fn"))]
      `(~'do
         (~'def ~callback-clj ~callback)
         (~'native-declare
          ~(str "\n void " callback-cpp "_callack" "(){\n"
                "run(ferret::" (symbol-conversion callback-clj) ");"
                "\n}\n"))
         ((~'fn []
            ~(str "pinMode(" pin " , INPUT_PULLUP);"
                  "attachInterrupt(digitalPinToInterrupt(" pin "), " callback-cpp "_callack , " mode ");"))))))
#+end_src

** Testing
*** assert

Evaluates expr and aborts if it does not evaluate to logical true.

#+name: runtime-clojure-testing
#+begin_src clojure :tangle no
  (defn assert-aux [f msg]
    (when (not (f))
      (println "Assertion Failed =>" msg)
      (system-abort)))

  (defn assert-aux-callback [f callback]
    (when (not (f)) (callback)))

  (defmacro assert
    ([exp]
     `(~'assert-aux (~'fn [] ~exp) ~(-> exp pr-str (clojure.string/escape {\\ "\\\\"}))))
    ([exp callback]
     `(~'assert-aux-callback (~'fn [] ~exp) (~'fn [] ~callback))))
#+end_src

*** deftest

Support for Clojure style unit testing.

#+name: runtime-clojure-testing
#+begin_src clojure :tangle no
  (defmacro is [form]
    `(~'assert ~form (~'println "FAIL =>" ~(-> form pr-str (clojure.string/escape {\\ "\\\\"})))))

  (defmacro deftest [name & exprs]
    (defonce fir-unit-tests (atom []))
    (swap! fir-unit-tests conj name)
    `(def ~name (~'fn [] ~@exprs)))

  (defmacro run-all-tests []
    `(~'do ~@(map #(list %) @fir-unit-tests)))
#+end_src

** Native
*** defnative

Allows a function to be defined for multiple platforms see [[Accessing C,C++ Libraries]] for
examples.

#+name: runtime-clojure-defn
#+begin_src clojure :tangle no
  (defmacro defnative [name args & form]
    (let [includes (->> (filter #(seq? (nth % 2)) form)
                        (map #(cons (nth % 1) (apply list (nth % 2))))
                        (map (fn [form]
                               (let [[guard & headers] form]
                                 (str "\n#if " guard " \n"
                                      (apply str (map #(str "#include \"" % "\"\n") headers))
                                      "#endif\n"))))
                        (map #(list 'native-declare %)))
          body (->> (map #(vector (second %) (last %)) form)
                    (map #(str "\n#if " (first %) " \n"
                               (second %)
                               "\n#endif\n"))
                    (apply str))
          pre-ample (->> (map #(vector (second %) (drop-last (drop 3 %))) form)
                         (map #(str "\n#if " (first %) " \n"
                                    (apply str (map (fn [line] (str line "\n")) (second %)))
                                    "\n#endif\n"))
                         (map #(list 'native-declare %)))]
      `(~'def ~name (~'fn* ~args ~@includes ~@pre-ample  ~body))))
#+end_src

*** pr-object-sizes

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defn pr-object-sizes []
    (println "Object Sizes")
    (println "\tvar:\t\t\t" (cxx "__result = obj<Number>((number_t)sizeof(var));"))
    (println "\tObject:\t\t\t" (cxx "__result = obj<Number>((number_t)sizeof(Object));"))
    (println "\tPointer:\t\t" (cxx "__result = obj<Number>((number_t)sizeof(Pointer));"))
    (println "\tNumber:\t\t\t" (cxx "__result = obj<Number>((number_t)sizeof(Number));"))
    (println "\tKeyword:\t\t" (cxx "__result = obj<Number>((number_t)sizeof(Keyword));"))
    (println "\tSequence:\t\t" (cxx "__result = obj<Number>((number_t)sizeof(Sequence));"))
    (println "\tLazySequence:\t\t" (cxx "__result = obj<Number>((number_t)sizeof(LazySequence));"))
    (println "\tString:\t\t\t" (cxx "__result = obj<Number>((number_t)sizeof(String));"))
    (println "\tBoolean:\t\t" (cxx "__result = obj<Number>((number_t)sizeof(Boolean));"))
    (println "\tLambda:\t\t\t" (cxx "__result = obj<Number>((number_t)sizeof(Lambda));"))
    (println "\tAtom:\t\t\t" (cxx "__result = obj<Number>((number_t)sizeof(Atom));"))
    (println "\tPIDController<float>:\t"
             (cxx "__result = obj<Number>((number_t)sizeof(PIDController<float>));"))
    (println "\tPIDController<int>:\t"
             (cxx "__result = obj<Number>((number_t)sizeof(PIDController<int>));")))
#+end_src

*** memory-pool-free-space

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defnative memory-pool-free-space []
    (on "defined FERRET_MEMORY_POOL_SIZE"
        "int count = 0;
         for(int i = 0; i < FERRET_MEMORY_POOL_SIZE; i++)
           if(program_memory.used[i] == false)
             count++;
         __result = obj<Number>((number_t)(count*sizeof(FERRET_MEMORY_POOL_PAGE_TYPE)));"))
#+end_src

** Compiler
*** configure-runtime!

Configure Ferret Runtime options. See table in [[Configuration]] section.

#+name: runtime-clojure-defn
#+begin_src clojure :tangle no
  (defmacro configure-runtime! [& body]
    `(~'native-define ~(->> (partition 2 body)
                            (map #(str "#define " (first %) " " (second %) "\n"))
                            (list))))
#+end_src

*** configure-ferret!

Embed compilations options.

#+name: runtime-clojure-defn
#+begin_src clojure :tangle no
  (defmacro configure-ferret! [& body]
    `(~'native-define ~(str "// Ferret Build Configuration Begin\n"
                            "//" (str (apply hash-map body)) "\n"
                            "// Ferret Build Configuration End\n")))
#+end_src

* Tests
  :PROPERTIES:
  :noweb-ref: ferret-unit-tests
  :END:

Most tests are done using the built in testing API that mimics
/clojure.test/ API, but certain tests are easier to do using real
/clojure.test/ framework by compiling forms using Ferret then
comparing the their runtime output to their expected output. All
generated code is statically checked using /cppcheck/ and tested
against memory leaks using /vallgrind/.

Tests are run by the CI system for the following compilers,

 - GCC 5
 - Clang 3.4

/cxx/ options,

 - *-std=c++11*
 - *-pedantic*
 - *-Werror*
 - *-Wall*
 - *-Wextra*
 - *-Woverloaded-virtual*
 - *-Wuninitialized*
 - *-Winit-self*

/cppcheck/ options,

 - *--std=c++11*
 - *--template=gcc*
 - *--enable=all*
 - *--error-exitcode=1*

/valgrind/ options,

 - *--leak-check=full*
 - *--error-exitcode=1*

** Core
*** Special Forms
    :PROPERTIES:
    :noweb-ref: special-forms-test
    :END:

#+begin_src clojure :tangle no
  (def make-adder
    (fn [n]
      (fn [x] (+ x n))))

  (def adder
    (make-adder 1))

  (def fibo
    (fn [n]
      (if (< n 2)
        1
        (+ (fibo (- n 1))
           (fibo (- n 2))))))

  (native-declare "ferret::number_t i = 0;")

  (defn inc-int []
    "__result =  obj<Number>(i++);")

  (deftest special-forms-test
    (is (= 1                @(atom 1)))
    (is (= 3                (#(+ 1 2))))
    (is (= 11               ((fn [n] (+ n 1)) 10)))
    (is (= 3               (((fn [n] (fn [n] n)) 3) 3)))
    (let [args (list "./a.out" "42")]
      (is (= args *command-line-args*)))

    (let [a 1
          b 2]
      (is (= 3 (+ a b))))

    (let [a 1
          b 2
          c 3]
      (is (= 6 (+ a b c))))

    (let [a 1
          b 2]
      (let []
        (is (= 3 (+ a b)))))
    
    (is (= 10 (adder 9)))
    (is (= 89 (fibo 10)))
    (is (= 0 (inc-int)))
    (is (= 1 (inc-int))))
#+end_src

*** Destructuring
    :PROPERTIES:
    :noweb-ref: destructuring-test
    :END:

#+begin_src clojure :tangle no
  (defn destructure-test-1 [[a b c]]
    (list a b c))

  (defn destructure-test-2 [[a [b] c]]
    b)

  (defn destructure-test-3 [[a [_ b] c]]
    b)

  (defn destructure-test-4 [& a]
    a)

  (defn destructure-test-5 []
    (let [[a b c] (list 1 2 3)]
      (list a b c)))

  (defn destructure-test-6 []
    (let [[_ _ a] (list 1 2 3)]
      a))

  (deftest destructuring-test
    (is (= 3                   (count (destructure-test-1 (list 1 2 3)))))
    (is (= 2                   (destructure-test-2 (list 1 (list 2) 3))))
    (is (= 3                   (destructure-test-3 (list 1 (list 2 3) 3))))
    (is (= (list (list 1 2 3)) (destructure-test-4 (list 1 2 3))))

    (let [a (list 1 2 3 4)
          [b c & r] a]

      (is (= 1          b))
      (is (= 2          c))
      (is (= (list 3 4) r)))

    (let [a 1 b 2
          [c & r] (list 4 5)]
      
      (is (= 1 a))
      (is (= 2 b))
      (is (= 4 c))
      (is (= (list 5) r)))

    (let [[a & r] (list 1 2 3)
          rr (rest r)]
      (is (= (list 3) rr)))
    
    (is (= (list 1 2 3) (destructure-test-5)))
    (is (= 3            (destructure-test-6)))


    (let [[_ _ a] (list 1 2 3)
          [_ b] (list 4 5 6)]
      (is (= 3 a))
      (is (= 5 b)))

    (let [a (list 1 2 3)
          [b c d e f g] a]
      (is (= 1   b))
      (is (= 2   c))
      (is (= 3   d))
      (is (= nil e))
      (is (= nil f))
      (is (= nil g))))
#+end_src

*** Conditionals
    :PROPERTIES:
    :noweb-ref: conditionals-test
    :END:

#+begin_src clojure
  (deftest conditionals-test
    (is (= 2   (if 1 2)))
    (is (= 1   (if (zero? 0) 1 -1)))
    (is (= -1  (if (zero? 1) 1 -1)))
    (is (= 2   (when true 2)))
    (is (= 2   (when (integer? 2) 2)))
    (is (= 2   (cond (float? 2.1) 2 (integer? 2) 4 true 1)))
    (is (= 1   (cond (float? 2) 2.1 (integer? 2.1) 4 true 1)))
    (is (= 2   (if nil 1 2)))
    (is (= nil (if-let [a nil] a)))
    (is (= 5   (if-let [a 5] a)))

    (is (= 1     (when (< 2 3) 1)))
    (is (= true  (let [a 1] (and (> a 0) (< a 10)))))
    (is (= false (let [a 11] (and (> a 0) (< a 10)))))
    (is (= true  (and true true)))
    (is (= false (and true false)))
    (is (= true  (or true false)))
    (is (= false (or false false))))
#+end_src

*** Logical Operators
    :PROPERTIES:
    :noweb-ref: logical-operators-test
    :END:

#+begin_src clojure
  (deftest logical-operators-test
    (is (= true  (< 2)))
    (is (= true  (< 2 3 4 5)))
    (is (= true  (> 2)))
    (is (= false (> 2 3 4 5)))
    (is (= true  (> 6 5 4 3)))
    (is (= true  (>= 2)))
    (is (= true  (>= 5 4 3 2 2 2)))
    (is (= false (>= 5 1 3 2 2 2)))
    (is (= true  (<= 2)))
    (is (= true  (<= 2 2 3 4 5)))
    (is (= false (<= 2 2 1 3 4)))
    (is (= true  (= 2)))
    (is (= false (= 2 3)))
    (is (= true  (= 2 2 2 2)))
    (is (= true  (= 2 2.0 2)))
    (is (= false (= 2 2 2 2 3 5)))
    (is (= true  (= (list 1 2) (list 1 2))))
    (is (= false (= (list 1 2) (list 1 3))))
    (is (= true  (= true true)))
    (is (= false (not (= true true))))
    (is (= false (not 1)))

    (let [a (fn [x] (+ 1 x))
          b (fn [x] (inc x))]
      (is (= true  (= a a)))
      (is (= false (= a b)))
      (is (= true  (= nil ((fn [] )))))
      (is (= true  (= nil ((fn [x y] ) 1 2)))))


    (is (= true  (true? true)))
    (is (= false (true? false)))
    (is (= false (false? true)))
    (is (= true  (false? false)))
    (is (= false (= nil 1)))
    (is (= false (= 1 nil)))
    (is (= true  (= nil nil)))

    (is (= true  (pos? 1)))
    (is (= true  (pos? 0.2)))
    (is (= false (pos? 0)))
    (is (= false (neg? 1)))
    (is (= true  (neg? -1)))
    (is (= true  (zero? 0)))
    (is (= false (zero? 10)))
    (is (= true  (zero? (- 1 1))))
    (is (= true  (zero? (- 1.2 1.2))))
    (is (= true  (zero? (+ 1.2 -1.2)))))
#+end_src

*** Math
    :PROPERTIES:
    :noweb-ref: math-test
    :END:

#+begin_src clojure :tangle no
  (deftest math-test
    (is (= 0.6 (+ 0.3 0.3)))
    (is (= 0   (+ )))
    (is (= 1   (+ 1)))
    (is (= 10  (+ 1 2 3 4)))
    (is (= 10  (+ 1 2.0 3 4)))
    (is (= -1  (- 1)))
    (is (= 0   (- 4 2 2)))
    (is (= 0   (- 4 2 2.0)))
    (is (= 1   (* )))
    (is (= 8   (* 2 2 2)))
    (is (= 8   (* 2.0 2 2)))
    (is (= 1   (/ 1)))
    (is (= 0.5 (/ 2)))
    (is (= 1   (/ 4 2 2)))
    (is (= 1   (/ 4 2 2.0)))
    
    (is (= 1   (floor 1.1)))
    (is (= 1   (floor 1.5)))
    (is (= 1   (floor 1.9)))
    (is (= 0   (mod 2 2)))
    (is (= 0   (mod 4 2)))
    (is (= 1   (mod 5 2)))
    (is (= 1   (mod 8 7)))
    (is (= 1   (min 1)))
    (is (= 1   (min 2 1)))
    (is (= 1   (min 3 5 7 1)))
    (is (= 1   (max 1)))
    (is (= 2   (max 2 1)))
    (is (= 7   (max 3 5 7 1)))
    
    (is (= 100 (scale 10 0 10 0 100)))
    (is (= 50  (scale 5 0 10 0 100)))
    (is (= 0   (scale 0 0 10 0 100)))
    (is (= 5   (clamp 10 0 5)))
    (is (= 10  (clamp 10 0 20)))
    (is (= 0   (clamp 10 -10 0)))
    (is (= -10 (clamp -100 -10 0)))

    (is (= 0     (number-combine (number-split 0))))
    (is (= 512   (number-combine (number-split 512))))
    (is (= 1024  (number-combine (number-split 1024))))
    (is (= 2048  (number-combine (number-split 2048))))
    (is (= 32000 (number-combine (number-split 32000))))

    (is (= true (not (nil? (rand)))))
    (is (= true (not (nil? (rand 15)))))
    (is (= true (float? (rand))))
    (is (= true (float? (rand 10))))
    (is (= true (integer? (rand-int 10))))

    (is (= -5 (bit-not  4)))
    (is (= -1 (bit-not  0)))
    (is (= 7  (bit-or   4 3)))
    (is (= 1  (bit-or   0 1)))
    (is (= 0  (bit-and  4 3)))
    (is (= 0  (bit-and  0 1)))
    (is (= 0  (bit-xor  4 4)))
    (is (= 1  (bit-xor  1 0)))
    (is (= 8  (bit-shift-left 4 1)))
    (is (= 16 (bit-shift-left 4 2)))
    (is (= 2  (bit-shift-right 4 1)))
    (is (= 1  (bit-shift-right 4 2)))

    (is (= 32 (sqrt 1024)))
    (is (= 2 (sqrt 4)))

    (let [a 1
          b 2]
      (+ 1 a)
      (+ b a)
      (is (= 1 a))
      (is (= 2 b))
      (* 2 a)
      (* b a)
      (is (= 1 a))
      (is (= 2 b))
      (/ 2 a)
      (/ b a)
      (is (= 1 a))
      (is (= 2 b))
      (- 2 a)
      (- b a)
      (is (= 1 a))
      (is (= 2 b))))
#+end_src

*** Control
    :PROPERTIES:
    :noweb-ref: control-test
    :END:

#+begin_src clojure :tangle no
  (deftest pid-controller-test
    (let [controller (pid-controller :kp 1
                                     :ki 0
                                     :kd 0
                                     :set-point 5
                                     :bounds [0 10 0 10]
                                     :continuous false)]

      (is (= 5 (controller 0)))
      (is (= 5 (controller 0))))

    (let [controller (pid-controller :kp 1
                                     :ki 1
                                     :kd 0
                                     :set-point 5
                                     :bounds [0 10 0 20]
                                     :continuous false)]

      (is (= 10 (controller 0)))
      (is (= 15 (controller 0)))
      (is (= 20 (controller 0)))
      (is (= 20 (controller 0))))

    (let [controller (pid-controller :kp 1
                                     :ki 0
                                     :kd 1
                                     :set-point 5
                                     :bounds [0 10 0 20]
                                     :continuous false)]

      (is (= 10 (controller 0)))
      (is (= 5 (controller 0)))))

  (deftest state-machine-test
    (let [state (atom 0)
          machine (state-machine
                   (states
                    (off (swap! state inc))
                    (on  (swap! state inc)))
                   (transitions
                    (off
                     (fn [] true) on)
                    (on
                     (fn [] true) off)))]
      (dotimes [_ 10]
        (machine))
      (is (= 10 (deref state))))

    (let [state (atom 0)
          machine (state-machine
                   (states
                    (a (swap! state inc))
                    (b (swap! state inc))
                    (c (swap! state inc))
                    (no-op (swap! state inc)))
                   (transitions
                    (a
                     (fn [] false) no-op
                     (fn [] true) b)
                    (b
                     (fn [] true) c)
                    (c
                     (fn [] false) no-op
                     (fn [] false) no-op
                     (fn [] true) a
                     (fn [] false) no-op)))]
      (dotimes [_ 10]
        (machine))
      (is (= 10 (deref state))))

    (let [state (atom nil)
          machine (state-machine
                   (states
                    (a (swap! state conj 1))
                    (b (swap! state conj 2))
                    (c (swap! state conj 3))
                    (no-op ))
                   (transitions
                    (a
                     (fn [] true) b
                     (fn [] true) c
                     (fn [] true) no-op)
                    (b (fn [] true) no-op)
                    (c (fn [] true) no-op)
                    (no-op (fn [] true) no-op)))]
      (dotimes [_ 50]
        (machine))
      (is (= (list 2 1) (deref state))))

    (let [value (atom 0)
          machine (state-machine 
                   (states
                    (increment (swap! value inc))
                    (no-op ))
                   (transitions
                    (increment
                     (fn [] true) increment
                     (fn [] true) no-op)
                    (no-op
                     (fn [] true) no-op)))]
      (machine)
      (machine)
      (is (= 2 (deref value)))))
#+end_src

*** Threading
    :PROPERTIES:
    :noweb-ref: threading-test
    :END:

#+begin_src clojure :tangle no
  (deftest threading-test
    (let [state (atom nil)
          add-wait (fn [time item]
                     (fn []
                       (sleep time)
                       (swap! state conj item)))]
      (thread (add-wait 10 1))
      (thread (add-wait 20 2))
      (sleep 30)
      (is (= (list 2 1) (deref state)))))

  (deftest timing-test
    (let [now (millis)]
      (sleep 100)
      (is (>= (- (millis) now) 100)))
    (is (>= (time-fn (fn [] (sleep 100) (+ 1 1))) 100))
    (is (>= (benchmark (fn [] (sleep 10) (+ 1 1)) 10) 10)))

  (defn ping [] true)

  (deftest fn-throttler-test
    (let [throttled-ping (fn-throttler ping 1 :second :blocking)
          begin (millis)]
      (throttled-ping)
      (throttled-ping)
      (throttled-ping)
      (is (> (- (millis) begin) 2000))
      (is (throttled-ping)))


    (let [throttled-ping (fn-throttler ping 1 :second :non-blocking)
          begin (millis)]
      (throttled-ping)
      (throttled-ping)
      (throttled-ping)
      (is (nil? (throttled-ping)))
      (is (< (- (millis) begin) 1000))))
#+end_src

*** XOR Stream
    :PROPERTIES:
    :noweb-ref: xor-stream-test
    :END:

#+begin_src clojure :tangle no
  (def xor-stream-state (atom nil))

  (defn xor-sample-read-stream [buf]
    (let [buffer (atom buf)]
      (list
       (fn []
         (let [f (first (deref buffer))]
           (swap! buffer rest)
           f))
       (fn []
         (count (deref buffer)))
       (fn [vals]
         (reset! xor-stream-state vals)))))

  (defn xor-sample-write-stream []
    (let [buffer (atom (list))]
      (list
       (fn [v]
         (swap! buffer conj v))
       (fn []
         (reverse (deref buffer))))))

  (deftest xor-stream-test
    (let [[writer get-buffer] (xor-sample-write-stream)
          encoder (xor-stream-encoder writer)
          data (list (list 1 2 3 4)
                     (list 5 6 7 8))]
      (doseq [d data] 
        (encoder d))

      (let [[read in-waiting handler] (xor-sample-read-stream (get-buffer))
            decoder (xor-stream-decoder read in-waiting handler)]
        (dotimes [i 4]
          (decoder))
        (is (= (list 1 2 3 4) @xor-stream-state))
        (dotimes [i 4]
          (decoder))
        (is (= (list 5 6 7 8) @xor-stream-state)))))
 #+end_src
 
*** Misc
    :PROPERTIES:
    :noweb-ref: misc-test
    :END:

 #+begin_src clojure :tangle no
   (deftest doto-test
     (let [st (atom )
           add (fn [s v]
                 (swap! s conj v))]
       (doto st
         (add 1)
         (add 2)
         (add 3))
       (is (= (list 3 2 1) @st))))
 #+end_src

*** Module System

Run import tests. 

#+begin_src clojure :tangle no
  (deftest import-module-test
    (is (= "Module AModule C 10 11 1 42"
           (exec-form '((require '[test.modules.module-a :as mod-a])
                        (require '[test.modules.module-b :as mod-b])
                        (mod-a/helper-a)
                        (mod-b/helper-b)
                        (print " ")
                        (print ((mod-a/ten-fn))
                               ((mod-b/eleven-fn))
                               (mod-a/helper-c)
                               (mod-b/macro-call))))))
    (is (= "Module AModule C 10 11 1 42"
           (exec-form '((require '[test.modules.module-a :as mod-a]
                                 '[test.modules.module-b :as mod-b])
                        (mod-a/helper-a)
                        (mod-b/helper-b)
                        (print " ")
                        (print ((mod-a/ten-fn))
                               ((mod-b/eleven-fn))
                               (mod-a/helper-c)
                               (mod-b/macro-call))))))
    (is (= "Module AModule C 10 11 1 42"
           (exec-form '((require 'test.modules.module-a
                                 'test.modules.module-b)
                        (test.modules.module-a/helper-a)
                        (test.modules.module-b/helper-b)
                        (print " ")
                        (print ((test.modules.module-a/ten-fn))
                               ((test.modules.module-b/eleven-fn))
                               (test.modules.module-a/helper-c)
                               (test.modules.module-b/macro-call))))))
    (is (= "Module AModule C 10 11 1 42"
           (exec-form '((require '[test.modules.module-a :as mod-a]
                                 'test.modules.module-b)
                        (mod-a/helper-a)
                        (test.modules.module-b/helper-b)
                        (print " ")
                        (print ((mod-a/ten-fn))
                               ((test.modules.module-b/eleven-fn))
                               (mod-a/helper-c)
                               (test.modules.module-b/macro-call))))))
    (is (= "" (exec-form '((require '[test.modules.module-a :as mod-a])))))
    (is (= "" (exec-form '((require '[test.modules.module-a :as mod-a])
                           (require '[test.modules.module-b :as mod-b])))))
    (is (= "Call" (exec-form '((require '[test.modules.module-c :as mod-c])
                               (cxx "__result = obj<Number>((number_t)std::sqrt(100)); 
                                            std::cout << \"Call\"")))))
    (is (= "25" (exec-form '((require '[test.modules.module-c :as mod-c])
                             (cxx "std::cout << dummy_native_fn();"))))))
#+end_src

**** Dummy Modules
     :PROPERTIES:
     :noweb-ref: ferret-tests-modules-no-export
     :END:  

Create some dummy libs under /test/modules/,

#+begin_src clojure :mkdirp yes :tangle src/test/modules/module-a.clj
  (defn helper-a []
    (print "Module A"))

  (defmacro ten-fn []
    `(~'fn [] 10))

  (defmacro helper-b []
    (reduce (fn [a b] (+ a b)) (list 1 2 3))
    1)

  (defn helper-c []
    (helper-b))
#+end_src 

#+begin_src clojure :mkdirp yes :tangle src/test/modules/module-b.clj
  (require '[test.modules.module-c :as mod-c])

  (defn helper-b []
    (mod-c/helper-c))

  (defn eleven-fn []
    (mod-c/eleven-fn))

  (defnative macro-aux []
    (on "defined FERRET_STD_LIB"
        "__result = obj<Number>((number_t)42);"))

  (defmacro macro-call []
    `(~'do (~'macro-aux)))
#+end_src 

#+begin_src clojure :mkdirp yes :tangle src/test/modules/module-c.clj
  (native-header "cmath")

  (native-declare "int dummy_native_fn(){ return 25; }")

  (defn helper-c []
    (print "Module C"))

  (defmacro eleven-fn []
    `(~'fn [] 11))
#+end_src 

*** Testing

#+begin_src clojure :tangle no
  (deftest testing-unit-test
    (is (= "" (exec-form '((assert (= 2 1) (print "fail"))) {:release true})))
    (compare-output
     (str "FAIL => (= 2 3)\n"
          "FAIL => false\n"
          "FAIL => (= 5 (apply + (list 1 2 3)))\n"
          "FAIL => (= 3 (some-fn))\n")
     (deftest some-test
       (is (= 2 3))
       (is (= 2 2))
       (is false)
       (is true))

     (defn some-fn [] 2)
     
     (deftest some-other-test
       (is (= 5 (apply + (list 1 2 3))))
       (is (= 6 (apply + (list 1 2 3))))
       (is (= 3 (some-fn)))
       (is (= 2 (some-fn))))

     (run-all-tests)))
#+end_src

** Data Structures
*** Sequence
    :PROPERTIES:
    :noweb-ref: sequence-test
    :END:

#+begin_src clojure :tangle no
  (deftest sequence-test
    (is (= true  (= (list ) (list ))))
    (is (= 0     (count (list ))))
    (is (nil?    (first (rest (rest (list))))))
    (is (= false (= (list )       (list 1 2 3))))
    (is (= false (= (list )       (list nil))))
    (is (= false (= (list 1 2 3)  (list 1 2))))
    (is (= false (= (list 1 2)    (list 1 2 3))))
    (is (= true  (= (list 1 2 3)  (list 1 2 3))))
    (is (= false (= (list 1 2 3)  (list 1 2 4))))
    (is (= false (= (list 1 1 3)  (list 1 2 3))))

    (is (= (list )            (rest (list ))))
    (is (= (list 1)           (cons 1 nil)))
    (is (= (list nil)         (cons nil nil)))
    (is (= 1                  (first (list 1 2 3 4))))
    (is (= 2                  (second (list 1 2 3 4))))
    (is (= (list 2 3 4)       (rest (list 1 2 3 4))))
    (is (= (list 3 4)         (rest (rest (list 1 2 3 4)))))
    (is (= (list 3 3 4)       (cons 3 (rest (rest (list 1 2 3 4))))))
    (is (= 3                  (first (cons 3 (rest (rest (list 1 2 3 4)))))))
    (is (= 4                  (count (list 1 2 3 4))))
    (is (= (list 4 3 2 1 1 2) (conj (list 1 2) 1 2 3 4)))
    (is (= (list 4 3 2 1)     (conj nil 1 2 3 4)))
    (is (= 21                 (reduce + (list 1 2 3 4 5 6))))
    (is (= 21                 (apply + (list 1 2 3 4 5 6))))

    (is (= 1   (nth (list 1 2 3) 0)))
    (is (= 2   (nth (list 1 2 3) 1)))
    (is (= 3   (nth (list 1 2 3) 2)))
    (is (= nil (nth (list 1 2 3) 10)))
    (is (= nil (nth (list 1 2 3) -10)))
    
    (is (= (list 1 2 3 4) (drop 0 (list 1 2 3 4))))
    (is (= (list 2 3 4)   (drop 1 (list 1 2 3 4))))
    (is (= (list 3 4)     (drop 2 (list 1 2 3 4))))
    (is (= (list )        (drop 4 (list 1 2 3 4))))
    (is (= (list )        (drop 5 (list 1 2 3 4))))

    (is (= (list 6 5 4 3 2 1) (reverse (list 1 2 3 4 5 6))))
    (is (= (list 6 5 4 3 2)   (reduce (fn [h v] (conj h (inc v))) (list) (list 1 2 3 4 5))))
    (is (= (list 4 3 2 1 0)   (reduce (fn [h v] (conj h (dec v))) (list) (list 1 2 3 4 5))))

    
    (is (= 1 (first (repeatedly 3 (fn [] 1)))))
    (is (= 3 (count (repeatedly 3 (fn [] 1)))))
    (is (= 2 (->> (repeatedly 3 (fn [] 1)) (map inc) first)))
    (is (= 2 (->> (repeatedly (fn [] 1)) (take 3) (map inc) reverse first)))
    
    (is (= 2 (count (filter true? (list true false true false)))))
    (is (= 2 (count (filter false? (list true false true false)))))
    (is (= 3 (count (filter false? (list true false true false false)))))
    (is (= 2 (count (filter (fn [x] (not (false? x))) (list true false true false false)))))

    (let [state (atom nil)
          add (fn [i]
                (swap! state conj i))
          collect (fn [t] "for(auto c : runtime::range(t)) run(add,t);")]
      (collect (list 1 2))
      (is (= (list (list 1 2) (list 1 2)) @state))))
#+end_src

*** Lazy Sequence
    :PROPERTIES:
    :noweb-ref: lazy-seq-test
    :END:

#+begin_src clojure
  (defn lazy-countdown [n]
    (if (>= n 0)
      (cons n (lazy-seq (lazy-countdown (- n 1))))))

  (defn ints-from [n]
    (cons n (lazy-seq (ints-from (inc n)))))

  (deftest lazy-seq-test
    (is (= false (= (range 10) (range 15))))
    (is (= false (= (range 15) (range 10))))
    (is (= true  (= (range 10) (range 10))))
    (is (= 10    (first (ints-from 10))))
    (is (= 11    (first (rest (ints-from 10)))))
    (is (= 12    (first (rest (rest (ints-from 10))))))
    (is (= 10    (first (lazy-countdown 10))))
    (is (= 9     (first (rest (lazy-countdown 10)))))
    (is (= 8     (first (rest (rest (lazy-countdown 10))))))
    (is (= 11    (count (lazy-countdown 10))))

    (is (= 2   (first (map inc (list 1 2 3)))))
    (is (= 0   (first (map dec (list 1 2 3)))))
    (is (= 4   (first (map (fn [x] (+ 3 x)) (list 1 2 3)))))
    (is (= 3   (count (map inc (list 1 2 3)))))
    (is (= 10  (apply + (range 5))))
    (is (= 5   (count (range 5))))
    (is (= 2   (first (take 2 (map inc (list 1 2 3))))))
    (is (= 3   (first (rest (take 2 (map inc (list 1 2 3)))))))
    (is (= 3   (count (take 20 (map inc (list 1 2 3))))))
    (is (= 1   (first (concat (list 1 2 3) (list 4 5 6)))))
    (is (= 4   (first (drop 3 (concat (list 1 2 3) (list 4 5 6))))))
    (is (= 21  (reduce + (concat (list 1 2 3) (list 4 5 6)))))

    (is (= (list -2 -1)          (take-while neg? (list -2 -1 0 1 2 3))))
    (is (= (list -2 -1 0 1 2)    (take-while #(< % 3) (list -2 -1 0 1 2 3))))
    (is (= (list -2 -1 0 1 2 3)  (take-while #(<= % 3) (list -2 -1 0 1 2 3))))
    (is (= (list -2 -1 0 1 2 3)  (take-while #(<= % 4) (list -2 -1 0 1 2 3))))
    
    (is (empty? (concat))))
#+end_src

*** Lambda
    :PROPERTIES:
    :noweb-ref: lambda-test
    :END:

#+begin_src clojure
  (deftest lambda-test
    (let [f1 (fn [])
          f2 (fn [])
          m-func (fn
                   ([a] 1)
                   ([a b] 2)
                   ([a b & c] 3)
                   ([a b [c d] & e] 4))]
      (is (= true  (= f1 f1)))
      (is (= false (= f1 f2)))
      (is (= true  (= f1 (do f1))))
      (is (= false (= f2 (do f1))))
      (is (= 1 (m-func 1)))
      (is (= 2 (m-func 1 2)))
      (is (= 3 (m-func 1 2 3)))
      (is (= 4 (m-func 1 2 (list 3 3) 4)))))
#+end_src

*** Pointer
    :PROPERTIES:
    :noweb-ref: pointer-test
    :END:

#+begin_src clojure
  (deftest pointer-test
    (let [state (atom false)]
      (let [a-gc-fn (fn [] (reset! state true))
            a-ptr (cxx "__result = obj<Pointer>(nullptr);")
            a-heavy-ptr (cxx "__result = obj<HeavyPointer>(a_ptr,a_gc_fn);")
            b-ptr (cxx "__result = obj<Pointer>(new int);")
            b-gc-fn (fn [] "delete b_ptr.cast<Pointer>()->pointer<int>();")
            b-heavy-ptr (cxx "__result = obj<HeavyPointer>(b_ptr,b_gc_fn);")]
        (is (= true  (= a-ptr a-ptr)))
        (is (= false (= a-ptr b-ptr)))
        (is (= true  (= a-heavy-ptr a-heavy-ptr)))
        (is (= false (= a-heavy-ptr b-heavy-ptr)))
        (is (= false (= b-heavy-ptr a-heavy-ptr)))
        (is (= true  (= b-heavy-ptr b-heavy-ptr))))
      (is (= true (deref state)))))


  (deftest value-test
    (let [obj-42 (cxx "__result = obj<Value<number_t>>((number_t)42)")
          obj-24 (cxx "__result = obj<Value<number_t>>((number_t)24)")]
      (is (=    obj-42 obj-42))
      (is (not= obj-42 obj-24))))
#+end_src

*** Atom
    :PROPERTIES:
    :noweb-ref: atom-test
    :END:

#+begin_src clojure
  (deftest atom-test
    (let [a (atom nil)
          b (atom nil)]
      (is (= nil          (deref a)))
      (is (= 1            (do (reset! a 1) (deref a))))
      (is (= 2            (do (swap! a inc) (deref a))))
      (is (= (list 1 2 3) (do (reset! a (list 1 2 3)) (deref a))))
      (is (= 6            (do (swap! a (fn [l] (reduce + l))) (deref a))))
      (is (= true         (= a a)))
      (is (= false        (= a b)))
      (is (= false        (= a 3.14)))))
#+end_src

*** Keyword
    :PROPERTIES:
    :noweb-ref: keyword-test
    :END:

#+begin_src clojure
  (deftest keyword-test
    (is (= true  (= :test :test)))
    (is (= false (= :test :other_test)))
    (let [ke (fn [k] "__result = obj<Boolean>(k.equals(obj<Keyword>(\":space\")))")]
      (is (= true (ke :space)))))
#+end_src

*** String
    :PROPERTIES:
    :noweb-ref: string-test
    :END:

#+begin_src clojure
  (deftest string-test
    (let [s1 "Some String"
          s2 "Other String"
          s1-ret (fn [] "__result = obj<String>(\"Some String\");")
          s1-eq (fn [s] "__result = obj<Boolean>((s.cast<String>()->to_string() == \"Some String\"))")]
      (is (= false (= s1 s2)))
      (is (= true  (= s1 s1)))
      (is (= false (= s1 3.14)))
      (is (= true  (= s1 (s1-ret))))
      (is (= true  (s1-eq s1)))
      (is (= 99 \c))
      (is (= \S (first s1)))))
#+end_src

*** Memory Pool

#+begin_src clojure
  (deftest native-core-memory-pool
    (compare-output
     ""
     (native-define "#define FERRET_MEMORY_POOL_SIZE 4194304") ;; 4 MB
     (native-declare "void* ptr;")

     (native-declare "ferret::MemoryPool<size_t,14> tiny_pool;")
     (let [next-page (fn [idx]
                       "size_t i = (size_t)idx.cast<Number>()->as<number_t>();
                        __result = obj<Number>((number_t)tiny_pool.next_page(i))")
           malloc (fn [size]
                    "size_t s = (size_t)size.cast<Number>()->as<number_t>();
                     ptr = tiny_pool.allocate(sizeof(size_t) * s);
                     __result = obj<Boolean>((ptr != nullptr));")
           free (fn [] "tiny_pool.free(ptr);")]
       
       (assert (= 0 (next-page 0)))
       (assert (malloc 2))
       (assert (= 3 (next-page 0)))
       (assert (malloc 4))
       (assert (= 8 (next-page 2)))
       (free)
       (assert (= 3 (next-page 2)))
       (assert (false? (malloc 40)))
       (assert (malloc 6))
       (assert (malloc 1))
       (assert (malloc 1))
       (assert (false? (malloc 10))))

     (native-declare "ferret::MemoryPool<size_t,256> even_pool;")
     (let [next-page (fn [idx]
                       "size_t i = (size_t)idx.cast<Number>()->as<number_t>();
                        __result = obj<Number>((number_t)even_pool.next_page(i))")
           malloc (fn [size]
                    "size_t s = (size_t)size.cast<Number>()->as<number_t>();
                     ptr = even_pool.allocate(sizeof(size_t) * s);
                     __result = obj<Boolean>((ptr != nullptr));")
           free (fn [] "even_pool.free(ptr);")]
       
       (assert (= 0 (next-page 0)))
       (assert (malloc 255))
       (assert (= 256 (next-page 0)))
       (free)
       (assert (= 0 (next-page 0)))
       (assert (false? (malloc 256)))
       (assert (= 0 (next-page 0))))

     (native-declare "ferret::MemoryPool<size_t,255> odd_pool;")
     (let [next-page (fn [idx]
                       "size_t i = (size_t)idx.cast<Number>()->as<number_t>();
                       __result = obj<Number>((number_t)odd_pool.next_page(i))")
           malloc (fn [size]
                    "size_t s = (size_t)size.cast<Number>()->as<number_t>();
                     ptr = odd_pool.allocate(sizeof(size_t) * s);
                     __result = obj<Boolean>((ptr != nullptr));")
           free (fn [] "odd_pool.free(ptr);")]
       
       (assert (= 0 (next-page 0)))
       (assert (malloc 254))
       (assert (= 255 (next-page 0)))
       (free)
       (assert (= 0 (next-page 0)))
       (assert (false? (malloc 255)))
       (assert (= 0 (next-page 0))))))
#+end_src

* Roadmap
** Compiler

  - *Shared Library* - Ability to be run as a shared lib.
    - Export functions to JNA (C API)
  - *Escape Analysis* - Escape known language structures. Certain
    forms generate =fn=s that never escape. These can be generated on
    the stack.
  - *Escape Analysis* for other types. Currently escape analysis is
    only used for functions.    
    - [[https://news.ycombinator.com/item?id=12158191][Static Analysis]]
  - *Readbility* - Add context to auto generated symbols in compiled
    code.
  * Check out Typed Racket
  - Since Ferret does whole-program compilation. Implement
    optimizations from Stalin Scheme compiler.
    - https://github.com/barak/stalin
    - https://news.ycombinator.com/item?id=8214343
    - https://justindomke.wordpress.com/2009/02/23/the-stalin-compiler/

** Data Structures

  - *Association Lists* as an alternative to maps. More suited to
    embedded systems. Quoted from Wikipedia, for quite small values of
    n it is more efficient in terms of time and space than more
    sophisticated strategies such as hash tables.
    - D-Lists - https://news.ycombinator.com/item?id=11575540
    - https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/PersistentHashMap.java
    - https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/APersistentMap.java
  - *Pluggable Numbers* - Ability to change the default number type at
    compile time.
  - *Implement Que*
  - *Unbounded Precision Integers*
    - [[https://web.archive.org/web/20101208222557/http://www.mactech.com/articles/mactech/Vol.08/08.03/BigNums/index.html][Arbitrarily Large Bignums]]
    - From p.11: PICOBIT: A Compact Scheme System for Microcontrollers
     - Larger values are needed in some embedded applications.
       - 48 bit integers to store MAC addresses.
       - SHA family of cryptographic hashing functions, which need
         values up to 512 bits wide.
       - If an application keeps track of time at the microsecond level
         using a 32-bit value, a wraparound will occur every hour or
         so.
     - Unbounded precision integers are encoded in PICOBIT as linked
       lists of 16 bit values. At the end of each list is either the
       integer 0 or -1, to represent the sign. 0, -1 and other small
       integers have dedicated encodings and do not need to be
       represented as linked lists. The use of this “little-endian”
       representation simplifies the bignum algorithms in particular
       for numbers of different lengths.
     - On versions of PICOBIT which do not support unbounded precision
       integers (including PICOBIT Light), integers are limited to 24
       bits, and encoded directly in the object.
    - Ranged Numbers - This type is an int but can only be 1-12.

** Core

  - *Pre/Post conditions* for functions.
    - By default print error and abort. 
    - Let user define a callback function.
  - *Cleaner FFI* - Current FFI system is modeled after [[http://gambitscheme.org/wiki/index.php/Using_Gambit_with_External_Libraries][Gambit
    Scheme]]. 
    - With a set a macros can provide a DSL like [[https://github.com/tomhrr/dale][Dale]].
    - Cleans up /defobject/ macro.
  - *Multimethods*
  - *Co-Operative Multitasking* - For Embedded Systems.
    - https://forum.pjrc.com/threads/25628-Lightweight-Teensy3-x-Fibers-Library-%28C-%29-Available
    - https://github.com/ve3wwg/teensy3_fibers/blob/1ba0c1e79a423f097e12e6c4176b40cf9d4f44e4/fibers.cpp
  - *MemoryPool* - Option for enabling allocation profiling.
  - *MemoryPool* - Ability to run functions on different Memory Pools.
    - Improved data locality and safety.
    - Optionally disable reference counting to improve performance since
      whole pool can be garbage collected when done.
    - Stalin also does very good lifetime analysis to reduce the
      amount of garbage needing collection. i.e. it will compute good
      places in the stack to create a heap, then objects that are
      determined to be born and die within that sub-stack are
      allocated from that heap. When the stack unwinds past that
      point, the entire local heap can be released in one fell swoop.

** Issues

  - *Variadic Templates* - GCC evaluates arguments in reverse order.
    - [[http://stackoverflow.com/questions/14060264/order-of-evaluation-of-elements-in-list-initialization][Order of evaluation of elements in list-initialization]]
    - [[https://blogs.msdn.microsoft.com/vcblog/2016/02/11/compiler-improvements-in-vs-2015-update-2/][Compiler improvements in VS 2015 Update 2]]

** Hardware

  - RPi GPIO
    - http://elinux.org/RPi_Low-level_peripherals
    - http://elinux.org/RPi_GPIO_Code_Samples

** The Rearview
*** Core

  - *Memory* - Option to disable [[Reference Counting]]. Combined with
    =FERRET_ALLOCATE= any third party GC can be supported.
    - http://www.ravenbrook.com/project/mps
    - http://www.hboehm.info/gc/
    Implemented =FERRET_DISABLE_RC= option.
  - *Pointer* - A pointer type to handle shared pointers.
    Implemented Value Object.
  - *Unit Testing*
    - https://www.cs.northwestern.edu/academics/courses/325/readings/lisp-unit.html
    - https://github.com/fukamachi/prove
    - http://tgutu.github.io/clunit/#clunit_2
    - [[https://github.com/aw/picolisp-unit][Unit Testing framework for PicoLisp]]
    - http://aperiodic.net/phil/archives/Geekery/notes-on-lisp-testing-frameworks.html
    - [[http://www.jera.com/techinfo/jtns/jtn002.html][JTN002 - MinUnit -- a minimal unit testing framework for C]]
  - *throttled-fn* - Blocking and non blocking versions.
  - *require* - Import native declarations and headers.
  - *Native Headers* - Make =native-headers= a special form.
  - *Memory Pool* - Allow Multiple Implementations.
    Allow user definable =FERRET_ALLOCATE= - =FERRET_FREE=
  - *String* - String constructor from std::string.
  - *require* - require module without alias.
  - *require* - Only having *require* forms and nothing else causes
    null pointer exception.
  - *require* - Should support requiring multiple libraries. Currently
    each library import requires a require form.
  - *assert* - Strip during release build.
    - *--release* - CLI option added.
  - *Pointer* - Ability to call cleanup function before *GC*
  - *Debugging* - Add some debugging macros, native side.
  - *PIDController* - Implement Unit Tests.
  - *Continuous Integration* - Setup Travis CI, automate testing and
    deployment.
  - Implement *Range-based for loop* for seekable containers.
  - *Benchmarking* - Add a benchmarking function.
  - *Memory Pool* - Functions report in bytes.
  - *Sequence* - Remove size from object.
  - *MemoryPool* - Enable Locking, make it thread safe.
    - Removed - Wasted to much memory.
  - *Lazy Sequence* - Should cache the result of *rest* and return it
    on subsequent calls.
  - *assert* - https://clojuredocs.org/clojure.core/assert

*** Libraries

  - JSON Encode/Decode
    - https://git.nakkaya.com/nakkaya/ferret-boost
  - HTTP & WebSocket Client
    - https://git.nakkaya.com/nakkaya/ferret-websocket

* Files                                                            :noexport:
** project.clj
#+begin_src clojure :mkdirp yes :tangle src/project.clj
  (defproject ferret "1.0.0-SNAPSHOT"
    :dependencies [[org.clojure/clojure "1.7.0"]
                   [org.clojure/tools.cli "0.3.3"]
                   [org.bituf/clj-stringtemplate "0.2"]
                   [org.clojars.amit/commons-io "1.4.0"]
                   [watchtower "0.1.1"]
                   [org.clojure/tools.logging "0.2.3"]
                   [clojure-term-colors "0.1.0-SNAPSHOT"]]
    :repl-options {:host "0.0.0.0"
                   :port 7888
                   :init-ns ferret.core}
    :main ferret.core
    :aot [ferret.core]
    :jar-name "interim.jar"
    :uberjar-name "ferret.jar")
#+end_src 
** src/ferret/core.clj
#+begin_src clojure :noweb yes :mkdirp yes :tangle src/src/ferret/core.clj
  (ns ferret.core
    (:refer-clojure :exclude [compile])
    (:gen-class)
    (:use [clojure.java.io])
    (:require [clojure.set :as set]
              [clojure.zip :as zip]
              [clojure.walk :as walk]
              [clojure.pprint :as pprint]
              [clojure.tools.cli :refer [parse-opts]]
              [watchtower.core :as watcher]
              [clojure.term.colors :as color])
    (:use [ferret.string-template]
          [ferret.template]
          [clojure.java.shell]
          [clojure.tools [logging :only [log warn info trace]]])
    (:import (org.apache.commons.io FileUtils)))

  <<core-logging>>
  <<core-code-generation-misc>>
  <<core-compilation-form-fns>>
  <<core-compilation-reader-macros>>
  <<core-compilation-expand-macros>>
  <<core-compilation-shake-concat>>
  <<core-compilation-escape-analysis>>
  <<core-compilation-escape-analysis-post>>
  <<core-compilation-embed-ferret-core>>
  <<core-compilation-closure-conversion>>
  <<core-compilation-symbol-conversion>>
  <<core-compilation-remove-assertions>>
  <<core-compilation-do-fn>>
  <<core-compilation-let-fn>>
  <<core-compilation-process>>
  <<core-code-generation-emit>>
  <<core-code-generation-emit-source-methods>>
  <<core-code-generation-emit-source>>
  <<core-code-compile-code>>
#+end_src 
** src/ferret/template.clj
#+begin_src clojure :mkdirp yes :noweb yes :tangle src/src/ferret/template.clj
  (ns ferret.template
    (:use [ferret.string-template])
    (:import (java.io BufferedReader InputStreamReader)))

  (defn read-from-url [f]
    (with-open [in (.getResourceAsStream (ClassLoader/getSystemClassLoader) f)
                rdr (BufferedReader. (InputStreamReader. in))]
      (apply str (interpose \newline (line-seq rdr)))))

  (defn indexed
    "Returns a lazy sequence of [index, item] pairs, where items come
    from 's' and indexes count up from zero.

    (indexed '(a b c d))  =>  ([0 a] [1 b] [2 c] [3 d])"
    [s]
    (map vector (iterate inc 0) s))

  <<code-templates>>
#+end_src 
** src/ferret/string_template.clj
#+begin_src clojure :noweb yes :mkdirp yes :tangle src/src/ferret/string_template.clj
  (ns ferret.string-template
    (:import org.antlr.stringtemplate.StringTemplateGroup)
    (:import org.antlr.stringtemplate.StringTemplate)
    (:use ferret.string-template-internal))


  (defn create-view "Return new view template - useful as mentioned here:
    http://hardlikesoftware.com/weblog/2006/12/12/using-json-with-stringtemplate/"
    ([]
      (StringTemplate.))
    ([^String template]
      (StringTemplate. template)))


  (defn get-view-from-classpath "Return the view template from classpath"
    [^String view-name]
    (let [st-group (StringTemplateGroup. "default")]
      (.getInstanceOf st-group view-name)))


  (defn get-view-from-dir "Return the view template from specified directory"
    [^String view-name ^String root-dir]
    (let [st-group (StringTemplateGroup. "default" root-dir)]
      (.getInstanceOf st-group view-name)))


  (defn reset-view! "Reset view template with supplied content"
    [^StringTemplate view ^String template]
    (.setTemplate view template))


  (defn fill-view! "Fill view template with key/value pairs"
    ;;;
    ;; Fill template with key and value
    ([^StringTemplate template k v]
      (.setAttribute template (stringify k) (each-kv-to-sv v))
      template)
    ;;;
    ;; Fill template with key/value from map
    ([^StringTemplate template kv-map]
      (.setAttributes template (kv-to-sv kv-map))
      template))


  (defn render-view "Return rendered view for the template"
    [^StringTemplate template]
    (.toString template))
#+end_src

#+begin_src clojure :noweb yes :mkdirp yes :tangle src/src/ferret/string_template_internal.clj
  (ns ferret.string-template-internal)


  (defn stringify [any]
    (if (keyword? any)
      (name any)
      (str any)))


  (declare kv-to-sv)
  (declare scan-kv-to-sv)


  (defn each-kv-to-sv "If element is a collection type, do deep transformation"
    [each]
    (if (map? each)
      (kv-to-sv each)
      (if (or (vector? each) (list? each) (seq? each) (set? each))
        (scan-kv-to-sv each)
        each)))


  (defn scan-kv-to-sv
    "Scans a collection and turns any contained map within from kv to sv"
    [coll]
    (map each-kv-to-sv coll))


  (defn kv-to-sv
    "Transforms keyword-value map {:a 10 :b 20 :c 30}
     to string-value map {\"a\" 10 \"b\" 20 \"c\" 30}"
    [mp]
    (let [m (into {} mp)
          k (keys m)
          v (vals m)]
      (zipmap
        (map stringify k)
        (scan-kv-to-sv v))))

#+end_src

** test/ferret/test/core.clj

#+begin_src clojure :noweb yes :mkdirp yes :tangle src/test/ferret/test/core.clj
  (ns ferret.test.core
    (:refer-clojure :exclude [compile])
    (:use [ferret.core] :reload)
    (:use [clojure.test]
          [clojure.java.shell]
          [clojure.tools [logging :only [log warn info]]]))

  (set-log-level! :warn)

  (defn exec-check [& cmd]
    (let [ret (with-sh-dir "./" (apply sh cmd))]
      (if (not= 0 (:exit ret))
        (do (warn (str "exec-check failure" cmd))
            (warn (:err ret))
            (System/exit 1))
        (:out ret))))

  (defn static-check [f]
    (exec-check
     "cppcheck" "-q" "--std=c++11" "--template=gcc" "--enable=all" "--error-exitcode=1" f))

  (defn leak-check [f]
    (exec-check "valgrind" "--quiet" "--leak-check=full" "--error-exitcode=1" f "42"))

  (def cxx-options ["-std=c++11" "-pedantic"
                    "-Werror" "-Wall" "-Wextra"
                    "-Woverloaded-virtual" "-Wuninitialized" "-Winit-self"
                    "-pthread"])

  (defn exec-form [form & [opts]]
    (let [options (compile-options {:compiler-options cxx-options})
          options (merge options opts)]
      (compile->cpp form options)
      (compile->binary options)
      (static-check "solution.cpp")
      (leak-check "./a.out")))

  (defn report-test-failure [event]
    (let [actual (with-out-str
                   (clojure.pprint/pprint (:actual event)))
          expected (with-out-str
                     (clojure.pprint/pprint (:expected event)))]
      (let [type (-> event :type)]
        (inc-report-counter type)
        (when (= type :fail)
          (warn (str "test failure" \newline \newline actual \newline expected))))))

  (defmacro compare-output [res & body]
    `(binding [clojure.test/report report-test-failure]
       (is (= ~res (exec-form (quote ~body))))))

  (deftest test-core
    (let [prog-out (exec-form (read-clojure-file "resources/core-test.clj"))]
      (binding [clojure.test/report
                (fn [ev]
                  (inc-report-counter (-> ev :type))
                  (when (= (-> ev :type) :fail)
                    (warn (str "core test failure" \newline \newline))
                    (println prog-out)))]
        (is (= "" prog-out)))))

  <<ferret-unit-tests>>
#+end_src 

** resources/ferret.h

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/resources/ferret.h
  // Detect Hardware
  namespace ferret{
    <<runtime-native-detect-hardware>>
  }

  <<runtime-native-program-includes>>

  // Initialize Hardware
  namespace ferret{
    <<runtime-native-hardware-initialize>>
    <<runtime-native-program-header>>
  }

  // Number Configuration
  <<runtime-native-number-config-macros>>

  // Locking Macros
  namespace ferret{
    <<runtime-native-locking-macros>>
  }

  // Object System Base
  namespace ferret{
    class var;
    <<runtime-native-memory-system-allocator>>
    <<runtime-native-memory-pool-allocator-implementation>>
    <<runtime-native-memory-pool-allocator>>
    <<runtime-native-reference-counting>>
    <<runtime-native-object>>
    <<runtime-native-var>>
    <<runtime-native-object-allocation>>
    <<runtime-native-debugging-macros>>
  }
#+end_src 

** resources/core.clj

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/resources/core.clj
  <<runtime-clojure-thread-macro>>
  <<runtime-clojure-fn-macro>>
  <<runtime-clojure-boolean-object>>
  <<runtime-clojure-pointer-object>>
  <<runtime-clojure-number-object>>
  <<runtime-clojure-seekable-interface>>
  <<runtime-clojure-lambda-interface>>
  <<runtime-clojure-keyword-object>>
  <<runtime-clojure-sequence-object>>
  <<runtime-clojure-heavy-pointer-object>>
  <<runtime-clojure-string-object>>
  <<runtime-clojure-atom-object>>
  <<runtime-clojure-defn>>
  <<runtime-clojure-looping>>
  <<runtime-clojure-first>>
  <<runtime-clojure-sequence>>
  <<runtime-clojure-logical-operators>>
  <<runtime-clojure-conditionals>>
  <<runtime-clojure-math>>
  <<runtime-clojure-sequence-lazy>>
  <<runtime-clojure-bit-operations>>
  <<runtime-clojure-console-io>>
  <<runtime-clojure-misc>>
  <<runtime-clojure-state-machine>>
  <<runtime-clojure-pid-controller>>
  <<runtime-clojure-gpio>>
  <<runtime-clojure-testing>>
#+end_src

** resources/core-test.clj

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/resources/core-test.clj
  (configure-runtime! FERRET_PROGRAM_MAIN run_tests)

  <<special-forms-test>>
  <<sequence-test>>
  <<destructuring-test>>
  <<lazy-seq-test>>
  <<lambda-test>>
  <<pointer-test>>
  <<atom-test>>
  <<keyword-test>>
  <<string-test>>
  <<conditionals-test>>
  <<logical-operators-test>>
  <<math-test>>
  <<control-test>>
  <<threading-test>>
  <<xor-stream-test>>
  <<misc-test>>

  (defn ferret-unit-test []
    (run-all-tests))

  (def run-tests ferret-unit-test)
#+end_src

** resources/bash_executable_stub.sh

#+begin_src sh :mkdirp yes :tangle src/resources/bash_executable_stub.sh :padline no
  #!/usr/bin/env sh
  MYSELF=`which "$0" 2>/dev/null`
  [ $? -gt 0 -a -f "$0" ] && MYSELF="./$0"
  java=java
  if test -n "$JAVA_HOME"; then
      java="$JAVA_HOME/bin/java"
  fi
  exec "$java" $java_args -jar $MYSELF "$@"
  exit 1 
#+end_src
