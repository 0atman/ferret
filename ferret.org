#+title: Ferret User's Guide
#+tags: clojure c++ arduino avr-gcc gcc
#+STARTUP: hidestars
#+TAGS: noexport(e)
#+EXPORT_EXCLUDE_TAGS: noexport
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/bigblow/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/bigblow/css/bigblow.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/bigblow/css/hideshow.css"/>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/jquery-1.11.0.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/jquery-ui-1.10.2.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/jquery.localscroll-min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/jquery.scrollTo-1.4.3.1-min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/jquery.zclip.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/bigblow.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/hideshow.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <style>#content {max-width:1024px;} </style>
#+HTML_HEAD: <style>#postamble {max-width:1024px;} </style>
#+HTML_HEAD: <style>#left-panel-wrapper {display: none;} </style>
#+OPTIONS: H:10

* About
** What Is Ferret

Ferret is a Clojure to C++ compiler, projects aim is to create a
functional minimum viable lisp that runs on embedded systems with
deterministic behaviour by compiling a subset of Clojure to C++.

Generated code is self contained *ISO C++11* with no
dependencies. Which allows it to run on embedded systems with as
little as 2KB of RAM. (Arduino Uno / Atmega328 with 32kb Flash)

Ferret is not trying to be a 1 to 1 Clojure to C++ compiler. Projects
eventual aim is to create Clojure flavored lisp with ideas from Ada
that makes it suitable for embedded programming.

** Features

 - Very small foot print.
 - Functional
 - Macros
 - Destructuring
 - Easy FFI (Inline C,C++)
 - Memory Pooling
 - Module System

** License

Copyright 2015 Nurullah Akkaya

This file is part of Ferret.

Ferret is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. 

Ferret is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details. 

You should have received a copy of the GNU General Public License
along with Foobar. If not, see http://www.gnu.org/licenses/.

* Getting Started
** Download

   - [[http://dropbox.nakkaya.com/builds/ferret][Executable]] (Requires Bash and JVM)
   - [[http://dropbox.nakkaya.com/builds/ferret.jar][Standalone Jar]] (Requires JVM)

** A glimpse of Ferret

On any system, we can just compile a program directly into an
executable. Here's a program that sums the first 5 positive numbers.

#+begin_src clojure
  ;;; lazy-sum.clj
  (defn positive-numbers
    ([]
     (positive-numbers 1))
    ([n]
     (cons n (lazy-seq (positive-numbers (inc n))))))

  (println (->> (positive-numbers)
                (take 5)
                (apply +)))
#+end_src

We can compile this program using *ferret*, creating an executable named
*a.out*.

#+BEGIN_EXAMPLE
  $ ./ferret -i lazy-sum.clj -c
  $ ./a.out
  15
#+END_EXAMPLE

Output will be placed in a a file called *lazy-sum.cpp*, passing the
*-c* flag will cause this file to be automatically compiled using GNU
C++. (Other compilers are supprted see [[Overview]]).

Following shows a blink example for Arduino.

#+begin_src clojure
  ;;; blink.clj
  (pin-mode 13 :output)

  (forever
   (digital-write 13 :high)
   (sleep 500)
   (digital-write 13 :low)
   (sleep 500))
#+end_src

#+BEGIN_EXAMPLE
  $ ./ferret -i blink.clj
  $ mkdir blink
  $ mv blink.cpp blink/blink.ino
#+END_EXAMPLE

Then upload as usual.

** Memory Management

Memory management is done using reference counting. On memory
constraint systems such as microcontrollers Ferret can use a memory
pool to avoid heap fragmentation and calling malloc/free.

#+BEGIN_EXAMPLE
  (configure-runtime! FERRET_MEMORY_POOL_SIZE 256)
#+END_EXAMPLE

This will create a pool object as a global variable that holds an
array of *256 / sizeof(long)*. 

By default page size is =sizeof(long)=. This can be changed using,

#+BEGIN_EXAMPLE
  (configure-runtime! FERRET_MEMORY_POOL_PAGE_TYPE char)
#+END_EXAMPLE

Memory pooling is intended for embedded systems where calling
malloc/free is not desired. It is *not thread safe* It should not be
used in systems where better alternatives exists or you have enough
memory.

Steps for using *tcmalloc* on Mac OS X, install dependencies, 

#+BEGIN_EXAMPLE
  brew install google-perftools
#+END_EXAMPLE

Then from your program you can link to it using,

#+begin_src clojure
  (configure-ferret! :library-path ["/usr/local/Cellar/gperftools/2.4/lib/"]
                     :link ["tcmalloc"])
#+end_src

** Accessing C,C++ Libraries

You can declare global level things using,

#+begin_src clojure
  (native-declare "int i = 0;")
#+end_src

this will define an *int* called *i* as a global variable. If a
function only contains a string such as,

#+begin_src clojure
  (defn inc-int [] "__result =  obj<Number>(i++);")
#+end_src

It is assumed to be a native function string it is taken as C++
code. You can then use it like any other ferret function.

#+begin_src clojure
  (while (< (inc-int) 10)
    (print 1))
#+end_src

In addition to *defn* form there is also a *defnative* form which
allows you to define different function bodies for different *#define*
directives,

#+begin_src clojure
  (defnative get-char []
    (on "defined GNU_GCC"
        "__result = obj<Number>(getchar());"))
#+end_src

This function when compiled on a system that defines =GNU_GCC= will
return the result of *getchar* as a *Number* , on ANY other system it
will return *nil*. You can have multiple *on* blocks per *defnative*,

#+begin_src clojure
  (defnative sleep [timeout]
    (on "defined GNU_GCC"
        ("unistd.h")
        "::sleep(timeout.cast<Number>()->as<int>());")
    (on "defined AVR_GCC"
        "::delay(timeout.cast<Number>()->as<int>());"))
#+end_src

This way a single function can be defined for multiple systems.

** Wrapping Third Party C,C++ Libraries

   - [[https://git.nakkaya.com/nakkaya/ferret-serial][ferret-serial]] - Boost Asio Serial Port Wrapper For Ferret.
   - [[https://git.nakkaya.com/nakkaya/ferret-firmata][ferret-firmata]] - Firmata protocol implementation that uses *ferret-serial* and *stl*.
   - [[https://git.nakkaya.com/nakkaya/ferret-qt][ferret-qt]] - QT Embedded Webkit Wrapper For Ferret.

** Miscellaneous

For profiling you can use Valgrind with the following options

#+BEGIN_EXAMPLE
  valgrind --tool=callgrind ./(Your binary)
#+END_EXAMPLE

View results using,

#+BEGIN_EXAMPLE
  qcachegrind callgrind.out.XXX
#+END_EXAMPLE

* Overview
** Getting Ferret

Ferret is available as prebuilt and source code distributions. See
[[Download]] for download links to prebuilt packages.

This is a literate program, inspired by Donald Knuth (Knuth, Donald
“Literate Programming (1984)” Literate Programming CSLI, p99). It is
intended to be read like a novel from cover to cover. The ideas are
expressed clearly but they are grounded in the actual source code.

The code in this document is the executable source. Use the *build*
script in the source distribution to extract source code.

The latest sources are available at the Ferret [[https://git.nakkaya.com/nakkaya/ferret][git repo]].

** Implementation Notes

Ferret is a functional, lazy language. All functions should mimic
their Clojure counter parts. If they don't it is considered a bug. (or
not possible to implement with the current implementation.)

The compiler and the C++ runtime needed is split into three sections.

 - [[Compiler]]
 - [[Native Core]]
 - [[Clojure Core]]

*[[Compiler]]* section contains the actual compiler written in Clojure. It
takes the Clojure code and converts it to a Intermediate
representation by taking the Clojure form and running it [[Compilation][through some
transformations]]. This IR is then run through [[Code Generation]] module to
create C++ code. *[[Native Core]]* contains the C++ runtime needed to
support Ferret such as [[Object System]], [[Memory Pool][ Memory Pooling]], [[Reference Counting][Garbage
Collection]]. It is written in a mixture of C++ and Ferret DSL. *[[Clojure
Core]]* corresponds to *clojure.core*, contains all functions.

All Ferret objects derive from a [[Base]] class.

 - [[Pointer]] - For Holding references to native objects.
 - [[Number]] - All numbers are kept as ratios (two ints).
 - [[Keyword]] 
 - [[Sequence]]
 - [[Lazy Sequence]]
 - [[String]] - As [[Sequence]] of [[Number]]s
 - [[Boolean]]
 - [[Atom]] - Mimics Clojure atoms.

Interfaces,

 - [[Lambda]] - Provides *invoke* for callable objects.
 - [[Seekable]] - Provides *first*, *rest*, *cons*, *count* for [[Seekable]] containers.

* Compiler

Compilation happens by taking the /form/ and running it through several
transformations. Each transformation turns the form into more and more
C++ written with s-expressions. This intermediate language is then run
through code generation to produce the C++ file.

** Compilation

Forms go through nine transformations before they are passed to the
code generation phase.

#+name: core-compilation-process
#+begin_src clojure :tangle no
  (defn compile [form options]
    (->> (import-modules-all form)
         (process-reader-macros)
         (add-built-in)
         (expand-macros-all)
         (let->fn)
         (do->fn)
         (closure-conversion)
         (replace-fn-call-sites options)
         (escape-analysis)
         (symbol-conversion)))
#+end_src

*** Import Modules

Import other ferret files using,

#+BEGIN_SRC clojure :tangle no
  (require '[package.io :as io])
#+END_SRC

Compiler will look for a file under current working directory called,
/package/io.clj/ all expression in the that file will be added to the
front of the current form with symbols renamed to /some-fn/ =>
/io/some-function/.

#+name: core-compilation-add-built-in
#+begin_src clojure :tangle no
  (defn import-modules-select-require [form]
    (->> (select-form form (is-form? 'require))
         (map #(->> % rest first rest first))
         (map (fn [[mod _ as]] [mod as]))
         (reduce (fn[h [mod as]]
                   (if (h mod)
                     (assoc h mod (conj (h mod) as))
                     (assoc h mod [as]))) {})))
#+end_src

Extract the list of packages and aliases from the form. Returns a map
of mod -> aliases pairs.

#+name: core-compilation-add-built-in
#+begin_src clojure :tangle no
  (defn import-modules-load-modules [package-list]
    (reduce (fn[h [m aliases]]
              (let [mod (read-clojure-file
                         (str (.replace (str m) "." "/") ".clj"))
                    macro-symbols (->> (select-form mod (is-form? 'defmacro))
                                       (map second)
                                       (into #{}))
                    def-symbols (->> (select-form (expand-macros-all mod) (is-form? 'def))
                                     (map second)
                                     (into #{}))
                    replace? (set/union macro-symbols def-symbols)
                    mod (morph-form mod symbol?
                                    (fn [f]
                                      (if (replace? f)
                                        (symbol (str (.replace (str m) "." "_") "_" f))
                                        f)))]
                (reduce (fn [h v] (conj h v)) h mod)))
            (list ) package-list))
#+end_src

Loads all modules listed in the package list. When a module is loaded
all its symbols are replaced with its module name except /core/
functions. Module names acts as namespaces. Returns a form that the is
concatenation of all modules listed in form.

#+name: core-compilation-add-built-in
#+begin_src clojure :tangle no
  (defn import-modules-convert-alias-to-module [package-list form]
    (let [alias-to-mod (reduce (fn[h [mod aliases]]
                                 (reduce (fn[h v] (assoc h v mod)) h aliases))
                               {} package-list)
          form (morph-form form symbol?
                           (fn [f]
                             (if-let [[_ alias fn] (re-find #"(.*?)/(.*)" (str f))]
                               (if-let [mod-sym (alias-to-mod (symbol alias))]
                                 (symbol (str (.replace (str mod-sym) "." "_") "_" fn))
                                 f)
                               f)))]
      form))
#+end_src

Convert all aliased symbols in the form to their fully qualified
modules names. So =helper-a= defined in module =util.db= becomes
=util_db_helper-a=.

#+name: core-compilation-add-built-in
#+begin_src clojure :tangle no
  (defn import-modules [form]
    (let [package-list (import-modules-select-require form)
          form (remove-form form (is-form? 'require))
          modules (import-modules-load-modules package-list)
          form (import-modules-convert-alias-to-module package-list form)]
      (shake-concat modules form)))

  (defn import-modules-all [form]
    (loop [f form]
      (let [expanded (import-modules f)]
        (if (= f expanded)
          expanded
          (recur expanded)))))
#+end_src

Import all modules in the given form.

*** Process Reader Macros

Process some supported reader macros, /@/ and /#(some-fn)/ forms.

#+name: core-compilation-reader-macros
#+begin_src clojure :tangle no
  (defn process-reader-macros [form]
    (morph-form form
                (is-form? 'clojure.core/deref)
                (fn [f] (cons 'deref (rest f)))))
#+end_src

*** Add Runtime

/resources/runtime.clj/ contains the ferret core runtime when
tangled.

#+name: core-compilation-add-built-in
#+begin_src clojure :tangle no
  (defn add-built-in
    ([form]
     (let [runtime (-> (read-string (str \( (read-from-url "runtime.clj") \)))
                       (remove-form (is-form? 'defmacro)))]
       (shake-concat runtime form))))
#+end_src

*** Expand Macros

First we read all the macros present in /resources/runtime.clj/ then
add to that  user defined macros, they are evaluated in a temporary
namespace, using /morph-form/ we iterate all the macros used in the
code that we are compiling and expand them in the temporary namespace
then the node is replaced with its expanded form.

#+name: core-compilation-expand-macros
#+begin_src clojure :tangle no
  (declare expand-macros-all)

  (defn expand-macros [form]
    (let [build-in-macros (->> (read-string (str \( (read-from-url "runtime.clj") \)))
                               (filter (is-form? 'defmacro)))
          build-in-macro-symbols (into #{} (map second build-in-macros))
          form-macros (->> (filter (is-form? 'defmacro) form)
                           (filter (fn [[_ name]]
                                     (not (build-in-macro-symbols name)))))
          form-macro-symbols (map second form-macros)
          form (remove-form form (is-form? 'defmacro))
          temp-ns (gensym)]
      (create-ns temp-ns)
      (binding [*ns* (the-ns temp-ns)]
        (refer 'clojure.core :exclude (concat build-in-macro-symbols form-macro-symbols ['fn 'def]))
        (use '[ferret.core :only [symbol-conversion]])
        
        (doseq [m build-in-macros]
          (eval m))
        
        (doseq [m form-macros]
          (eval m)))
      
      (let [form (morph-form form
                             (is-form? 'let)
                             (fn [[_ bindings & body]]
                               (let [bindings (map #(if (list? %)
                                                      (expand-macros-all %) %) bindings)
                                     form (cons 'let* (cons bindings (expand-macros-all body)))]
                                 (expand-macros-all form))))
            form (morph-form form
                             (apply is-form? (concat build-in-macro-symbols form-macro-symbols))
                             (fn [f]
                               (binding [*ns* (the-ns temp-ns)]
                                 (walk/macroexpand-all f))))]
        (remove-ns temp-ns)
        form)))

  (defn expand-macros-all [form]
    (loop [f form]
      (let [expanded (expand-macros f)]
        (if (= f expanded)
          expanded
          (recur expanded)))))
#+end_src

*** let->fn

/let/ forms are transformed into nested functions which are then
called immediately, bindings are setup in the outer function,
expressions are placed in the inner function which takes the bindings
as arguments.

So following form,

#+begin_src clojure :tangle no
  (let->fn '(let [a 1
                  b 2]
              (+ a b)))
#+end_src

after transformation becomes,

#+begin_src clojure :tangle no
  (define_lambda G__2708 (b a) () (_plus_ a b))
  (define_lambda G__2709 (a) (b) ((lambda_object G__2708 b a)))
  (define_lambda G__2710 () (a) ((lambda_object G__2709 a) 2))
  ((lambda_object G__2710) 1)
#+end_src

#+name: core-compilation-let-fn
#+begin_src clojure :tangle no
  (defn let->fn [form]
    (morph-form form
                (is-form? 'let*)
                (fn [[_ bindings & body]]
                  (let [bindings (->> (partition 2 bindings)
                                      (map-indexed (fn [idx [args val]]
                                                     [idx args val])))
                        vars (map first bindings)]
                    (if (empty? vars)
                      (list (concat (list 'fn* []) body))
                      (let [closure-fn (fn close [[idx arg vals] & more]
                                         (let [body (if (empty? more)
                                                      (list (concat ['fn* []] body))
                                                      (apply close more))]
                                           (list (list 'fn* (list arg) body)
                                                 (last (nth bindings idx)))))]
                        (apply closure-fn bindings)))))))
#+end_src

*** do->fn

A similar method is used for the do form, expressions are wrapped in a fn
that takes no parameters and executed in place.

#+begin_src clojure :tangle no
  (do->fn '(do (+ 1 1)))
#+end_src

#+begin_src clojure :tangle no
  ((fn [] (+ 1 1)))
#+end_src

#+name: core-compilation-do-fn
#+begin_src clojure :tangle no
  (defn do->fn [form]
    (morph-form form
                (is-form? 'do)
                #(list (concat ['fn* []] (rest %)))))
#+end_src

*** Closure Conversion

/closure-conversion/ handles the problem of free variables, 

#+begin_src clojure :tangle no
  (defn make-adder [x]
    (fn [n] (+ x n)))
#+end_src

in the above snippet x is a free variable, when the function /make-adder/
returns, it need to have a way of referencing that variable when it is
used. The way we do this is that, every function will pass its arguments to
inner functions (if any) it contains.

#+begin_src clojure :tangle no
  (closure-conversion '(fn [x]
                          (fn [n] (+ x n))))
#+end_src

Above form will be converted to,

#+begin_src clojure :tangle no
  (define_lambda G__3154 (x) (n) (_plus_ x n))
  (define_lambda G__3155 () (x) (lambda_object G__3154 x))
  (lambda_object G__3155)
#+end_src

What this means is, define a functor named =G__3154= that holds a
reference to /x/, and another functor =G__3155= that has no state. When
we create an instance of =G__3154= we pass /x/ to its
constructor. Since every thing is already converted to fns this
mechanism allows variables to be referenced down the line and solves
the free variable problem.

#+name: core-compilation-closure-conversion 
#+begin_src clojure :tangle no
  (defn lambda-defined? [fns env args body]
    (let [f (concat [env args] body)
          name (reduce (fn[h v]
                         (let [[_ n & r] v]
                           (if (= r f) n))) nil @fns)]
      (when name
        (apply list 'fir-lambda-object name env))))

  (defn define-lambda [fns env args body]
    (let [n (gensym)]
      (dosync (alter fns conj (concat ['fir-define-lambda n env args] body)))
      (apply list 'fir-lambda-object n env)))

  (defn closure-conversion
    ([form]
     (let [fns (ref [])
           form (closure-conversion form fns)]
       (concat form @fns)))
    ([form fns & env]
     (morph-form form
                 (is-form? 'fn*)
                 (fn [[_ args & body]]
                   (let [env (if (nil? env) '() (first env))
                         fn-env (->> args
                                     (remove #(and (seq? %)
                                                   (= 'ferret-compiler-no-closure (first %)))))
                         fn-args (->> args
                                      (map #(if (and (seq? %)
                                                     (= 'ferret-compiler-no-closure (first %)))
                                              (second %)
                                              %)))
                         body (closure-conversion body fns (concat fn-env env))]
                     (if-let [n (lambda-defined? fns env args body)]
                       n
                       (define-lambda fns env fn-args body)))))))
#+end_src

*** Symbol Conversion

Some symbols valid in Clojure are not valid C++ identifiers. This
transformation converts all symbols that are not legal C++ identifiers
into legal ones.

#+name: core-compilation-symbol-conversion
#+begin_src clojure :tangle no
  (defn symbol-conversion [form]
    (let [c (comp #(symbol (clojure.string/escape
                            (str %)
                            {\- \_ \* "_star_" \+ "_plus_" \/ "_slash_"
                             \< "_lt_" \> "_gt_" \= "_eq_" \? "_QMARK_"
                             \! "_BANG_"}))
                  #(cond (= 'not %) '_not_
                         :default %))]
      (morph-form form symbol? c)))

#+end_src

*** Optimizations
**** Replace Fn Call Sites

Final step replaces all functions calls with new function
objects =define_lambda= are renamed to /fn/. This removes all globals
variables unless the /fn/ defined is a closure. In which case it is
left as a global variable and the class implementation is prepended
with the global name for readability.

#+BEGIN_EXAMPLE
  (compile '((let [a 1]
               (defn adder [x]
                 (+ a x)))
             (defn my-inc [x] (+ 1 x))))

  (replace-fn-call-sites
   '((define_lambda G__3885 (a) (x) (_plus_ a x))
     (define_lambda G__3886 () (a) (def adder (lambda_object G__3885 a)))
     (define_lambda G__3887 () () (define_var a 1) ((lambda_object G__3886) a))
     (define_lambda G__3888 () (x) (_plus_ 1 x))
     ((lambda_object G__3887))
     (def my_inc (lambda_object G__3888))))

  ((define_lambda adder_G__3885 (a) (x) (_plus_ a x))
   (define_lambda G__3886 () (a) (def adder (lambda_object adder_G__3885 a)))
   (define_lambda G__3887 () () (define_var a 1) ((lambda_object G__3886) a))
   (define_lambda my_inc () (x) (_plus_ 1 x))
   ((lambda_object G__3887)))
#+END_EXAMPLE

#+name: core-compilation-symbol-conversion
#+begin_src clojure :tangle no
  (defn select-def-fn [form]
    (->> (select-form form (is-form? 'def))
         (filter (fn [[_ name val]]
                   (and (seq? val)
                        (= 'fir-lambda-object (first val)))))))

  (defn replace-fn-call-sites-pure [form fn-defs fn-table]
    (let [no-global-fn (reduce (fn[h v]
                                 (remove-form h (fn [f]
                                                  (and (seq? f)
                                                       (= 'def (first f))
                                                       (every? true? (map = f v))))))
                               form fn-defs)        
          embeded-fn-calls (reduce (fn[h [name gensym]]
                                     (morph-form h symbol?
                                                 (fn [f]
                                                   (if (= f name)
                                                     (list 'fir-lambda-object gensym)
                                                     f))))
                                   no-global-fn fn-table)
          embed-fn-names (reduce (fn[h [name gensym]]
                                   (morph-form h symbol?
                                               (fn [f]
                                                 (if (= f gensym)
                                                   name
                                                   f))))
                                 embeded-fn-calls fn-table)]
      embed-fn-names))

  (defn replace-fn-call-sites [options form]
    (if (:global-functions options)
      form
      (let [pure-fn-defs (->> (select-def-fn form)
                              (filter #(= 2 (-> % last count))))
            pure-fn-table (map (fn [[_ name [_ gensym]]] [name gensym]) pure-fn-defs)
            form (replace-fn-call-sites-pure form pure-fn-defs pure-fn-table)
            closure-fn-defs (->> (select-def-fn form)
                                 (filter #(not= 2 (-> % last count))))
            closure-fn-table (map (fn [[_ name [_ gensym]]] [name gensym]) closure-fn-defs)]
        (reduce (fn[h [name gensym]]
                  (morph-form h symbol?
                              (fn [f]
                                (if (= f gensym)
                                  (symbol (str name "_" gensym))
                                  f))))
                form closure-fn-table))))
#+end_src

**** Tree Shaking

Concats two forms. Shakes the first form by removing any symbols not
present in second form.

In order to keep the generated C++ code compact only the functions used
will be present in the generated source file. Which means if you don't
use /println/ anywhere in the code it won't be defined in the final
C++ file, but if you use it, it and everything it uses will be
defined, in the case of /println/ it will pull /apply/, /print/ and
/newline/ with it.

#+name: core-compilation-shake-concat
#+begin_src clojure
  (defn shake-concat
    ([header form]
     (let [header-no-macro (expand-macros-all header)
           header-symbols (->> (select-form header-no-macro (is-form? 'def))
                               (map second))
           header-fns (reduce (fn[h v] (assoc h (second v) v)) {} header-no-macro)
           objects (select-form header (is-form? 'defobject))
           macros (select-form header (is-form? 'defmacro))
           requires (select-form header (is-form? 'require))
           fns (atom {})
           _ (shake-concat (expand-macros-all (concat macros form)) header-fns fns)
           include-fns (->> @fns
                            (sort-by #(.indexOf header-symbols (key %)))
                            (map #(second %)))]
       (concat requires objects include-fns macros form)))
    ([form built-in fns]
     (morph-form form symbol?
                 #(do (if-let [f (built-in %)]
                        (when (not (@fns %))
                          (swap! fns assoc % f)
                          (shake-concat f built-in fns))) %))))
#+end_src

**** Escape Analysis

Determines that a certain allocation never escapes the local
function. This means that allocation can be done on the stack.

#+name: core-compilation-shake-concat
#+begin_src clojure
  (defn escape-analysis [form]
    (let [stack-lambda-pred (fn [f]
                              (and (seq? f)
                                   (is-special-form? 'fir-lambda-object (first f))))
          ;;espace lambda classes
          escapeable-lambdas (->> (collect-form
                                   form
                                   (fn [f]
                                     (and (stack-lambda-pred f)
                                          (let [fn-symbol (-> f first second)
                                                non-stack-allocations (-> (morph-form form stack-lambda-pred #(rest %))
                                                                          (select-form symbol?))]
                                            (->> non-stack-allocations
                                                 (filter #(= % fn-symbol))
                                                 rest ;; skip class definition
                                                 count ;; when pos it is used somewhere else as a symbol
                                                 zero?))))
                                   #(-> % first second))
                                  (into #{}))
          form (morph-form form
                           (fn [f]
                             (and (seq? f)
                                  (= (first f) 'fir-define-lambda)
                                  (escapeable-lambdas (second f))))
                           #(cons 'fir-define-lambda-stack (rest %)))
          ;;espace lambda objects
          form (morph-form form stack-lambda-pred (fn [f] (cons 'fir-invoke-lambda-stack f)))]
      form))
#+end_src

*** Helpers

During each pass we iterate over the nodes in the form using
/morph-form/ and /remove-form/, they both take a s-expression and a
predicate if the predicate returns true, morph-form will call /f/
passing the current node as an argument and replace that node with
/f/'s return value, remove-form on the other hand does what its name
suggests and removes the node when predicate returns true.

#+name: core-compilation-form-fns
#+begin_src clojure :tangle no
  (defn morph-form [tree pred f]
    (walk/prewalk (fn [x]
                    (if (pred x)
                      (f x)
                      x)) tree))

  (defn collect-form [tree pred f]
    (let [acc (atom [])]
      (doall (morph-form tree pred (fn [x] (swap! acc conj (f x)))))
      @acc))

  (defn remove-form [tree pred]
    (if (and (= (count tree) 1)
             (pred (first tree)))
      (list )
      (loop [loc (zip/seq-zip tree)]
        (if (zip/end? loc)
          (zip/root loc)
          (recur
           (zip/next
            (if (pred (zip/node loc))
              (zip/remove loc)
              loc)))))))

  (defn select-form [tree pred]
    (loop [loc (zip/seq-zip tree)
           nodes []]
      (if (zip/end? loc)
        nodes
        (recur
         (zip/next loc)
         (if (pred (zip/node loc))
           (conj nodes (zip/node loc))
           nodes)))))

  (defn is-form? [& s]
    (fn [f]
      (and (seq? f)
           (some true? (map #(= % (first f)) s)))))
#+end_src

#+name: core-code-generation-misc
#+begin_src clojure :tangle no
  (defn read-clojure-file [f]
    (try
      (read-string (str \( (FileUtils/readFileToString (file f)) \)))
      (catch Exception e
        (println "Error Reading," f)
        (System/exit 1))))

  (defn is-special-form? [s f]
    (and (seq? f)
         (= (first f) s)))
#+end_src

** Code Generation

 Once compilation is complete the form is in a state that is very
 close to C++. running /emit/ on the form converts it into C++.

#+name: core-code-generation-emit
#+begin_src clojure :tangle no  
  (defmulti emit (fn [form _]
                   (cond (is-special-form? 'fir_define_lambda form) 'fir_define_lambda
                         (is-special-form? 'fir_define_lambda_stack form) 'fir_define_lambda_stack
                         (is-special-form? 'fir_dispatch_lambda form) 'fir_dispatch_lambda
                         (is-special-form? 'fir_lambda_object form) 'fir_lambda_object
                         (is-special-form? 'fir_invoke_lambda_stack form) 'fir_invoke_lambda_stack
                         (is-special-form? 'fir_define_var form) 'fir_define_var
                         (is-special-form? 'defobject form) 'defobject
                         (is-special-form? 'native_declare form) 'native_declare
                         (is-special-form? 'native_define form) 'native_define
                         (is-special-form? 'if form) 'if
                         (is-special-form? 'def form) 'def
                         (symbol? form) :to-str
                         (keyword? form) :keyword
                         (number? form) :number
                         (nil? form) :nil
                         (char? form) :number
                         (string? form) :string
                         (or (true? form) (false? form)) :boolean
                         (seq? form) :sequence)))
#+end_src

Without preprocessing following forms,

#+begin_src clojure :tangle no
  (emit '(list 1 2 3) (ref {}))
  
  (emit '(+ 1 2) (ref {}))
  
  (emit '(if (< a b)
           b a)
        (ref {}))
#+end_src

would evaluate to,

#+begin_example
  "run(list,obj<Number>(1),obj<Number>(2),obj<Number>(3))"
  "run(+,obj<Number>(1),obj<Number>(2))"
  "((<,b,a) ? a : b)"
#+end_example

So the actual compilation will just map emit to all forms passed and
/string-template/ will handle the job of putting them into an empty
C++ skeleton.

#+name: core-code-generation-misc
#+begin_src clojure :tangle no
    (defn append-to! [r ks v]
      (dosync 
       (let [cv (reduce (fn[h v] (v h)) @r ks)]
         (alter r assoc-in ks (conj cv v)))))
#+end_src

#+name: core-code-generation-emit-source
#+begin_src clojure :tangle no
  (defn emit-source [form options]
    (let [state (ref {:lambdas [] :symbol-table #{} :native-declarations [] :native-defines []})
          ast (compile form options)
          body (doall (map #(emit % state) ast))]
      (when (:ast options)
        (pprint/pprint ast))
      (assoc @state :body body)))
#+end_src

*** Code Emitting
**** Object Types

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit :to-str [form state] (str form))

  (defmethod emit :char [form state] (str "obj<Number>('" form "')"))

  (defmethod emit :string [form state] (str "obj<String>(\"" form "\")"))

  (defmethod emit :boolean [form state] (str "obj<Boolean>(" form ")"))

  (defmethod emit :nil [form state] "nil()")

  (defmethod emit :keyword [form state]
    (str "obj<Keyword>(" (reduce (fn[h v] (+ h (int v))) 0 (str form)) ")"))

  (defmethod emit :number [form state]
    (let [number (rationalize form)]
      (if (ratio? number)
        (let [num (numerator number)
              denom (denominator number)]
          (str "obj<Number>(" num "," denom ")"))
        (str "obj<Number>(" number ")"))))

  (defmethod emit :sequence [[fn & args] state]
    (invoke-lambda (emit fn state) (doall (map #(emit % state) args))))

  (defmethod emit 'fir_invoke_lambda_stack [[_ lambda & args] state]
    (invoke-lambda (new-lambda-stack lambda)
                   (doall (map #(emit % state) args))))

  (defmethod emit 'fir_define_var [[_ name form] state]
    (str "var " name " = " (emit form state)))

  (defmethod emit 'native_declare [[_ declaration] state]
    (append-to! state [:native-declarations] declaration) "")

  (defmethod emit 'native_define [[_ define] state]
    (append-to! state [:native-defines] define) "")
#+end_src

**** Lambdas

List Destructuring. Clojure style list structuring is supported on
lambda forms.

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defn destructure-set-var [val arg accesor]
    (str "var " val " = "
         (reduce (fn[h v] (str v "(" h ")")) arg accesor)))

  (defn destructure-arguments [args name]
    (let [[args va-args] (if (some #{'&} args)
                           (split-at (.indexOf args '&) args)
                           [args []])
          args (->> args
                    (map-indexed (fn [pos val]
                                   (vector pos val)))
                    (filter #(not= (second %) '_))
                    (reduce (fn[h [pos val]]
                              (let [accesor (flatten [(repeat pos "runtime::rest") "runtime::first"])]
                                (if (coll? val)
                                  (conj h (destructure-arguments
                                           val (reduce (fn[h v] (str v "(" h ")")) name accesor)))
                                  (conj h (destructure-set-var val name accesor))))) []))]
      [args (if (empty? va-args)
              []
              (destructure-set-var
               (last va-args) name (repeat (count args) "runtime::rest")))]))

  (defn destructure-lambda [args]
    (flatten (destructure-arguments args "_args_")))
#+end_src

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit 'fir_lambda_object [l state]
    (new-lambda l))

  (defn emit-define-lambda-aux [name env args body state]
    (let [native-declarations (filter #(and (seq? %)
                                            (= (first %) 'native_declare)) body)
          body (filter #(not (and (seq? %)
                                  (= (first %) 'native_declare))) body)
          body (cond  (empty? body)
                      ["nil();"]
                      (and (= 1 (count body))
                           (seq? (first body))
                           (= 'fir_dispatch_lambda (first (first body))))
                      [(emit (first body) state) "nil();"]
                      (and (= 1 (count body))
                           (string? (first body)))
                      (let [inline (first body) 
                            body (if (= (last inline) \;)
                                   inline
                                   (str inline \;))]
                        (if (neg? (.indexOf body "__result"))
                          [body "nil();"]
                          ["var __result;" body "__result;"]))
                      :default (doall (map #(str (emit % state) \;) body)))
          env (->> env
                   (flatten)
                   (filter #(and (not (= '& %))
                                 (not (= '_ %)))))]
      (doseq [dec native-declarations] 
        (emit dec state))
      [name env (destructure-lambda args) body]))

  (defmethod emit 'fir_define_lambda [[_ name env args & body] state]
    (let [[name env args body] (emit-define-lambda-aux name env args body state)]
      (append-to! state [:lambdas]
                  {:name name :env env :args args :body body}) ""))

  (defmethod emit 'fir_define_lambda_stack [[_ name env args & body] state]
    (let [[name env args body] (emit-define-lambda-aux name env args body state)]
      (append-to! state [:lambdas]
                  {:name name :env env :args args :body body :stack true}) ""))
#+end_src

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit 'fir_dispatch_lambda [[_ args-symbol & fns] state]
    (let [fns (->> fns
                   (partition 2))
          nil-dispatch (filter #(= (first %) 0) fns)]
      (str
       (if (not (empty? nil-dispatch))
         (str "if (" args-symbol ".isNil())
                return " (new-lambda-stack
                          (->> nil-dispatch first second)) ".invoke(nil());")
         "")
       "switch(" args-symbol ".cast<ISeekable>()->count()) {"
       (->> fns
            (map (fn [[count fn]]
                   (if (= count 'true)
                     (str "default: "
                          " return " (new-lambda-stack fn) ".invoke(" args-symbol ");")
                     (str "case " count " : "
                          " return " (new-lambda-stack fn) ".invoke(" args-symbol ");"))))
            (apply str)) "}")))
#+end_src

**** Misc

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit 'defobject [[_ name & spec] state]
    (append-to! state [:native-declarations] (declare-object name spec))
    "")

  (defmethod emit 'if [[_ cond t f] state]
    (let [cond (emit cond state)
          t (emit t state)
          f (if (nil? f) "nil()" (emit f state))]
      (if-statement cond t f)))

  (defmethod emit 'def [[_ name & form] state]
    (append-to! state [:symbol-table] name)
    (str "(" name " = " (apply str (doall (map #(emit % state) form))) ")"))
#+end_src

*** Code Templates

**** Objects

#+name: code-templates
#+begin_src clojure :tangle no
  (defn declare-object [name body]
    (let [specs (into {} (map #(vector (first %) (rest %)) body))
          interface (if (nil? (specs 'interface))
                      "Object"
                      (apply str (rest (str (first (specs 'interface))))))
          interface-only (cond (specs 'interface) false
                               (empty? (specs 'new)) true
                               :defaul false)
          view (create-view "
      namespace ferret{

       $if(object_type)$
         namespace runtime {
          namespace type {
           const size_t $type$ = $type_val$;}}
       $endif$

       $if(template)$
         template<$template:{$it$} ;separator=\",\"$>
       $endif$
       class $name$ : public $interface$ {
       public:

         $data:{$it$} ;separator=\"\n\"$

         $interfaces:{virtual $it$ = 0;} ;separator=\"\n\"$

         $new:{it | $name$($first(it)$){
           $first(rest(it))$
         }} ;separator=\"\n\"$

         $if(object_type)$
          size_t getType(){ return runtime::type::$type$;}
         $endif$

         $if(equals)$
          var equals(var o){
           $equals$
          }
         $endif$

         $if(toOutputStream)$
  #if !defined(FERRET_DISABLE_OUTPUT_STREAM)
          var toOutputStream(){
           $toOutputStream$
          }
  #endif
         $endif$

         $fns:{it | $first(it)$($first(rest(it))$){
           $first(rest(rest(it)))$
         }} ;separator=\"\n\"$

         $ifdef_fns:{it | #$first(it)$
           $first(rest(it))$($first(rest(rest(it)))$){
           $first(rest(rest(rest(it))))$
         }
       #endif} ;separator=\"\n\"$
       };
       $post_code$
      }")]
      (fill-view! view "name" name)
      (fill-view! view "template" (specs 'template))
      (fill-view! view "interface" interface)
      (fill-view! view "interface_only" interface-only)
      (fill-view! view "object_type" (cond (specs 'force_type) true
                                           interface-only false
                                           :default true))
      (fill-view! view "type" (str name))
      (fill-view! view "type_val" (gensym ""))
      (fill-view! view "data" (specs 'data))
      (fill-view! view "new" (specs 'new))
      (fill-view! view "equals" (first (specs 'equals)))
      (fill-view! view "toOutputStream" (first (specs 'toOutputStream)))
      (fill-view! view "interfaces" (specs 'interfaces))
      (fill-view! view "fns" (filter #(= 3 (count %)) (specs 'fns)))
      (fill-view! view "ifdef_fns" (filter #(= 4 (count %)) (specs 'fns)))
      (fill-view! view "post_code" (first (specs 'post_code)))
      (render-view view)))
#+end_src    

**** Lambdas

#+name: code-templates
#+begin_src clojure :tangle no
  (defn if-statement [cond t f]
    (apply str "(" cond " ? " t " : " f ")"))

  (let [env (fn [[_ _ & env]]
              (->> env
                   (flatten)
                   (filter #(and (not (= '& %))
                                 (not (= '_ %))))))]
    (defn new-lambda [l]
      (let [n (second l)
            e (env l)]
        (if (empty? e)
          (str "obj<" n ">()")
          (str "obj<" n ">(" (apply str (interpose \, e)) ")"))))

    (defn new-lambda-stack [l]
      (let [n (second l)
            e (env l)]
        (if (empty? e)
          (str n "()")
          (str n "(" (apply str (interpose \, e)) ")")))))

  (defn invoke-lambda [n args]
    (if (empty? args)
      (str "run(" n ")")
      (str "run(" n "," 
           (reduce (fn[h v]
                     (str h v))
                   (->> args
                        (interpose \,)))")")))

  (defn declare-lambda-classes [lambdas]
    (let [view (create-view
                "$lambdas: {lambda|
        $if(!lambda.stack)$
         class $lambda.name$  : public Lambda{
        $else$
         class $lambda.name$  \\{
        $endif$

        $lambda.env:{var $it$;} ;separator=\"\n\"$

        public:

        $if(lambda.env)$
          $lambda.name$ ($lambda.env:{var $it$} ;separator=\",\"$){ 
             $lambda.env:{this->$it$ = $it$;} ;separator=\"\n\"$
          }
        $endif$

        $if(lambda.args)$
            var invoke (var _args_);
        $else$
            var invoke (var);
        $endif$
        };};separator=\"\n\n\"$")]
      (fill-view! view "lambdas" lambdas)
      (render-view view)))

  (defn declare-lambda-bodies [lambdas]
    (let [view (create-view
                "$lambdas: {lambda|
        $if(lambda.args)$
            var $lambda.name$::invoke (var _args_)
        $else$
            var $lambda.name$::invoke (var)
        $endif$
            {
              $lambda.args:{args | $args$; } ;separator=\"\n\"$

              $trunc(lambda.body):{$it$} ;separator=\"\n\"$
              return $last(lambda.body):{$it$} ;separator=\"\n\"$
            }
        };separator=\"\n\n\"$")]
      (fill-view! view "lambdas" lambdas)
      (render-view view)))
#+end_src    

**** Program

#+name: code-templates
#+begin_src clojure :tangle no :noweb yes
  (defn solution-template [source]
    (let [{:keys [body lambdas symbol-table native-declarations native-defines]} source
          view (create-view "
        $native_defines:{$it$} ;separator=\"\n\"$

        $object_interface$

        <<runtime-native-program-misc>>
        <<runtime-native-iseekable-headers>>
        <<function-invocation-api-headers>>

        #if defined(FERRET_STD_LIB) && !defined(DISABLE_COMMAND_LINE_ARGUMENTS) && !defined(FERRET_DISABLE_MAIN_FUNCTION)
          ferret::var _star_command_line_args_star_;
        #endif

        namespace ferret{
         $symbols:{var $it$;} ;separator=\"\n\"$
        }

        $native_declarations:{$it$} ;separator=\"\n\"$      

        <<function-invocation-api>>
  
        namespace ferret{
          $lambda_classes:{$it$} ;separator=\"\n\"$
          $lambda_bodies:{$it$} ;separator=\"\n\"$
        }

        <<runtime-native-iseekable-functions>>

        namespace ferret{
          void ProgramRun(){
           $body:{$it$;} ;separator=\"\n\"$ 
          }
        }

      #if !defined(FERRET_DISABLE_MAIN_FUNCTION)
        int main(int argc, char* argv[]){
          using namespace ferret;

        #if defined(FERRET_STD_LIB) && !defined(DISABLE_COMMAND_LINE_ARGUMENTS)
          _star_command_line_args_star_ = obj<Sequence>();
          for (int i = argc - 1; i > -1 ; i--)
            runtime::cons(obj<String>(argv[i]),_star_command_line_args_star_);
        #endif

          ProgramRun();

          #if defined(FERRET_PROGRAM_MAIN)
            run(FERRET_PROGRAM_MAIN);
          #endif

          return 0;
        }
      #endif

      #if defined(FERRET_HARDWARE_ARDUINO)
        void setup(){
          FERRET_INIT_OUTPUT_STREAM

          using namespace ferret;
          #if defined(FERRET_PROGRAM_MAIN)
            ProgramRun();
          #endif
        }
        void loop(){
          using namespace ferret;
          #if !defined(FERRET_PROGRAM_MAIN)
            ProgramRun();
          #endif          

          #if defined(FERRET_PROGRAM_MAIN)
            run(FERRET_PROGRAM_MAIN);
          #endif
        }
      #endif\n")]
      (fill-view! view "object_interface" (read-from-url "Object.cpp"))
      (fill-view! view "body" (filter #(not (empty? %)) body))
      (fill-view! view "lambda_classes" (declare-lambda-classes lambdas))
      (fill-view! view "lambda_bodies" (declare-lambda-bodies lambdas))
      (fill-view! view "symbols" symbol-table)
      (fill-view! view "native_declarations" native-declarations)
      (fill-view! view "native_defines" native-defines)
      (render-view view)))
#+end_src

** Main
*** Options

   Default compile options, 

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn compile-options [& [options]]
      (merge {:compiler "g++"
              :include-path []
              :library-path []
              :link []
              :compiler-options ["-std=c++11"]
              :source-extension "cpp"
              :base-name "solution"}
             options))

    (defn cpp-file-name [options]
      (str (:output-path options) (:base-name options) "." (:source-extension options)))
  #+end_src

   Read the /cpp/ file parse build options embedded in it.

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn compile-options-parse-source [file]
      (try
        (let [program (slurp file)
              options (->> program
                           (re-seq #"(?s)Ferret Build Configuration Begin.*?//(.*?)// Ferret Build Configuration")
                           (map second)
                           (map #(.replaceAll % "//" ""))
                           (map #(.replaceAll % "\n" " "))
                           (map read-string))
              keys (->> options
                        (map #(keys %))
                        flatten
                        (into #{})
                        (into []))
              combine (fn [key]
                        (->> options
                             (reduce (fn[h v]
                                       (if (nil? (key v))
                                         h
                                         (apply merge (flatten [h (key v)])))) #{})
                             (into [])))]
          (compile-options
           (reduce (fn[h v]
                     (assoc h v (combine v))) {} keys)))
        (catch Exception e
          (compile-options {}))))
  #+end_src

*** Compile to C++

   Compile the form to C++,

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn compile->cpp [form options]
      (let [file-name (cpp-file-name options)
            source (emit-source form options)]
        (println "[+] Compiling")
        (FileUtils/writeStringToFile (file file-name) (solution-template source))
        (let [formatted-source (try (with-sh-dir "./"
                                      (sh "clang-format" "-style" "{Standard: Cpp11}" file-name))
                                    (catch Exception e nil))]
          (when (:fomat-code options)
            (if formatted-source
              (do (println "[+] Formatting Code") 
                  (spit file-name (:out formatted-source)))
              (println "[+] Install clang-format for Formatted Output (Optional)"))))))
  #+end_src

*** Compile to Binary

   Compile C++ code to binary,

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn compile->binary [options extra-source-files]
      (let [command (flatten [(:compiler options)
                              (map #(str %) (:compiler-options options))
                              (map #(str "-I" %) (:include-path options))
                              (map #(str "-L" %) (:library-path options))
                              (map #(str "-l" %) (:link options))
                              (map #(let [extension (org.apache.commons.io.FilenameUtils/getExtension %)]
                                      [(cond (= extension "c") ["-x" "c"]
                                             (= extension "c++") ["-x" "c++"]
                                             :default "")
                                       %])
                                   extra-source-files)
                              ["-x" "c++"]
                              (str (:base-name options) "." (:source-extension options))])]

        (println "[+] Building Binary")
        (if (:build-command options)
          (do (println "[+] Build Command" (:build-command options))
              (let [ret (with-sh-dir (:output-path options)
                          (apply sh (flatten ["bash" "-c" (:build-command options)])))]
                (if (not= 0 (:exit ret))
                  (do (println "[+] Build Error")
                      (println (:err ret))
                      (System/exit 1))
                  (println (:out ret)))))
          (do (println "[+] Compiler:" (:compiler options))
              (println "[+] Options:")
              (doseq [option (:compiler-options options)]
                (println "           " option))
              (println "[+] Include Path:")
              (doseq [path (:include-path options)]
                (println "           " path))
              (println "[+] Library Path:")
              (doseq [path (:library-path options)]
                (println "           " path))
              (println "[+] Link:")
              (doseq [link (:link options)]
                (println "           " link))
              (let [ret (with-sh-dir (:output-path options)
                          (apply sh command))]
                (if (not= 0 (:exit ret))
                  (do (println "[+] Build Error")
                      (println (:err ret))
                      (System/exit 1))
                  (do (when (:name options)
                        (with-sh-dir (:output-path options)
                          (sh "mv" "a.out" (str "./" (:name options)))))
                      (println "[+] Done")
                      true)))))))
  #+end_src

*** Compiler Main

   Compiler /main/,

  #+name: core-code-compile-code
  #+begin_src clojure
    (def program-options [["-i" "--input FILE" "Input File" :default "./core.clj"]
                          ["-c" "--compile" "Compile Solution"]
                          ["-f" "--source-files FILE" "Extra Source Files to Pass to GCC"]
                          ["-w" "--watch-input" "Automatically recompile input file on change."]
                          [nil "--disable-formatting" "Disables solution formatting using clang-format."]
                          [nil "--global-functions" "Disables replace-fn-call-sites optimization."]
                          [nil "--ast" "Print Intermediate AST."]
                          ["-h" "--help" "Print Help"]])

    (defn -main [& args]
      (let [args (parse-opts args program-options)]
        (when (->> args :options :help)
          (println "Ferret Compiler")
          (println (:summary args))
          (System/exit 0))

        (let [input (if (and (->> args :options :input)
                             (.exists (file (->> args :options :input))))
                      (->> args :options :input)
                      (do (println "No Input File.")
                          (System/exit 1)))
              input-base-name (org.apache.commons.io.FilenameUtils/getBaseName input)
              input-path (str (org.apache.commons.io.FilenameUtils/getPrefix input)
                              (org.apache.commons.io.FilenameUtils/getPath input))
              options (-> (file (str input-base-name ".cpp"))
                          compile-options-parse-source
                          (assoc :base-name input-base-name)
                          (assoc :output-path input-path)
                          (assoc :ast (->> args :options :ast))
                          (assoc :fomat-code (not (->> args :options :disable-formatting)))
                          (assoc :global-functions (->> args :options :global-functions)))
              extra-source-files (cond (not (empty? (:arguments args))) (:arguments args)
                                       (not (empty? (:extra-source-files options))) (:extra-source-files options)
                                       :default [])
              build-fn (fn []
                         (let [input (read-clojure-file input)]
                           (compile->cpp input options)
                           (when (->> args :options :compile)
                             (let [options (-> (file (cpp-file-name options))
                                               compile-options-parse-source
                                               (assoc :output-path input-path)
                                               (assoc :base-name input-base-name))
                                   options (assoc options :base-name input-base-name)]
                               (compile->binary options extra-source-files)))))]
          (if (nil? (->> args :options :watch-input))
            (build-fn)
            (do (watcher/watcher [input]
                                 (watcher/rate 1000)
                                 (watcher/on-change (fn [_] (build-fn))))
                @(promise)))
          (shutdown-agents))))
  #+end_src

* Native Core

Runtime needed on the C++ side to support [[Clojure Core]]. [[Object System][Object system]],
[[Reference Counting][garbage collection]],[[Memory Pool][memory pooling]] and host specific initialization
code. (ie. printing on different embedded systems.)

** Memory Pool

    When,

#+BEGIN_EXAMPLE
  FERRET_MEMORY_POOL_SIZE
#+END_EXAMPLE

    is defined ferret program will use a memory pool instead of
    /mallac/,/free/, depending on the pool size ferret will allocate 
    /N/ bytes of memory on stack and all object creation
    happens in this memory pool useful when working with very limited
    amount of memory, such as micro controllers where you want
    complete control over the memory and you need deterministic timing
    requirements. Memory pooling also prevents heap fragmentation.

    (This should not be used in a multi threaded program.)

    For every page of memory allocated there is overhead of one
    /byte/ and one memory page is used for book keeping.

    When /allocate/ is called the pool will scan the memory pool using
    the /used/ array to find a block of memory big enough to
    satisfy the request. If found, it will the mark the region as used and
    return a pointer from /pool/ array to the user which points to
    the memory block. First page of the memory block is used for book
    keeping information, it holds the amount of memory allocated.

    When a free request is received, we resolve the pointer in to the
    memory pool read the book keeping information on how much memory
    is allocated to this pointer and set these pages to unused.

    Memory pool has several advantages, it will avoid fragmentation,
    function related to each other will always keep their data close
    to each other in the array which improves data locality.

#+name: runtime-native-memory-pool
#+begin_src c++ :tangle no
  #ifdef FERRET_MEMORY_POOL_SIZE
  template<typename PageSize, size_t poolSize, typename UsedArrayType>
  class MemoryPool{
  public:
    UsedArrayType used[poolSize];
    PageSize pool[poolSize];
    size_t lastAllocationIndex;
    
    inline size_t calculateNeededPages(size_t size){
      size_t d = (size / sizeof(PageSize));
      size_t f = (size % sizeof(PageSize));

      if (f == 0)
        return d;
      else
        return (d + 1);
    }
      
    MemoryPool(){
      lastAllocationIndex = 0;
      for(size_t i = 0; i < poolSize; i++){
        pool[i] = 0;
        used[i] = 0;
      }
    }
    
    inline bool isPageRangeUsable(size_t begin,size_t end){
      for(size_t i=begin; i < end; i++)
        if (used[i] != 0)
          return false;
      return true;
    }
    
    inline size_t nextAvaliblePage(size_t offset){
      for(size_t i=offset; i < poolSize; i++)
        if (used[i] == 0)
          return i;
      return poolSize;
    }
      
    inline int findPage(size_t pagesNeeded, size_t os = 0){
      size_t offset = os;
    
      for(;;){
        int page = nextAvaliblePage(offset);
    
        if ((page + pagesNeeded) > poolSize)
          break;
          
        if (isPageRangeUsable(page,(page + pagesNeeded)) == true)
          return page;

        offset = (page + pagesNeeded);
      }
        
      return -1;
    }
      
    void *allocate(size_t reqSize){
      size_t length = calculateNeededPages(reqSize);
      int page = findPage(length,lastAllocationIndex);
      
      if ( page == -1){
        page = findPage(length,0);
        if (page == -1 )
          return nullptr;
      }
      
      used[page] = reqSize;
      for(size_t i = page + 1; i < (page+length); i++)
        used[i] = 1;
        
      lastAllocationIndex = page + length;
      return &pool[page];
    }
    
    void free(void *p){
      PageSize* ptr = static_cast<PageSize*>(p);
      ptrdiff_t index = (ptr - pool);
      size_t length = calculateNeededPages(used[index]);
        
      for(size_t i = index ; i < (index+length); i++)
        used[i] = 0;
    }
  };

   #if !defined(FERRET_MEMORY_POOL_PAGE_TYPE)
    MemoryPool<long,(FERRET_MEMORY_POOL_SIZE/sizeof(long)),unsigned char> ProgramMemory;
   #else
    MemoryPool<FERRET_MEMORY_POOL_PAGE_TYPE,FERRET_MEMORY_POOL_SIZE,MEMORY_POOL_USED_ARRAY_TYPE> ProgramMemory;
   #endif
  #endif
#+end_src

Dispatch correct memory allocation/deallocation implementation,

#+name: runtime-native-memory-management-macros
#+begin_src c++ :tangle no
  #ifdef FERRET_MEMORY_POOL_SIZE
    #define FERRET_ALLOCATE(size) ProgramMemory.allocate(size)
    #define FERRET_FREE(pre) ProgramMemory.free(ptr)
  #else
    #define FERRET_ALLOCATE(size) malloc(size)
    #define FERRET_FREE(ptr) free(ptr)
  #endif
#+end_src

** Object System
*** Base

All our types are derived from the base Object type,

#+name: runtime-native-object
#+begin_src c++ :tangle no
  class Object{
  public:
    Object(){
      FERRET_INIT_REF();
    }

    Object(const Object& other){
      FERRET_COPY_REF(other);
    }
    
    virtual ~Object() {
    };
    
    virtual size_t getType() = 0;
    
  #if !defined(FERRET_DISABLE_OUTPUT_STREAM)
    virtual var toOutputStream() = 0;
  #endif
    
    virtual var equals(var o) = 0;
    
    void addRef() {
      FERRET_INC_REF(this);
    }
    
    bool subRef() {
      return FERRET_DEC_REF(this);
    }
    
    void* operator new(size_t size){
      return FERRET_ALLOCATE(size);
    }
    
    void  operator delete(void * ptr){
      FERRET_FREE(ptr);
    }
    
  private:
    FERRET_NEW_REF()
  };
#+end_src

*** Objects
**** Pointer

An object to hold a reference to a C++ pointer,

#+name: runtime-clojure-pointer-object
#+begin_src clojure :tangle no
  (defobject Pointer
    (data "void* ptr;")
    (new ("void* p" "ptr = p;"))
    (equals
     "return obj<Boolean>(ptr == o.cast<Pointer>()->pointer<void>());")
    (toOutputStream
     "fprintf(FERRET_OUTPUT_STREAM, \"Pointer<%p>\",ptr); return nil();")
    (fns
     ("template<typename T> T* pointer" ""
      "return ((T *)ptr);")
     ("template<typename T> T& reference" ""
      "return (*(pointer<T>()));")))
#+end_src

**** Number

There is only one number type in ferret. All numbers are kept as
ratios. Default number size is /int/. A ratio is kept in memory as two
/math::container/ size members named /numerator/ and /denominator/.

Math configuration,

#+name: runtime-native-math-config-macros
#+begin_src c++ :tangle no
  namespace ferret{
    namespace math{
      const int precision = 1000; //used when reading floats.
      typedef int container;
  #if !defined(FERRET_DISABLE_OUTPUT_STREAM)
      const char* format = "%d";
  #endif
    }
  }
#+end_src

Helper functions,

#+name: runtime-native-program-misc
#+begin_src c++ :tangle no
  namespace ferret{
    namespace runtime{
      #undef min
      #undef abs
      template<typename T>
        T min(T a, T b){
        return ((a)<(b)?(a):(b));
      }

      template<typename T>
        T abs(T a){
        return ((a)<0 ? -(a) : (a));
      }
    }
  }
#+end_src

Number Object,

#+name: runtime-clojure-number-object
#+begin_src clojure :tangle no
  (defobject Number
    (data "math::container numerator;"
          "math::container denominator;")
    (new ("math::container x"
          "numerator = x; denominator = 1;")
         ("math::container n, math::container dn"
          "numerator = n; denominator = dn; simplificate();")
         ("float x"
          "float decimal = (x - (math::container)x) * (float)math::precision;
           math::container integer = (math::container)x;
           numerator = decimal + (integer * math::precision);
           denominator = math::precision;
           simplificate();"))
    (equals "if (getNumerator() == 0 && o.cast<Number>()->getNumerator() == 0)
               return obj<Boolean>(true);
             else
               return obj<Boolean>((getNumerator() == o.cast<Number>()->getNumerator()) &&
                                   (getDenominator() == o.cast<Number>()->getDenominator()));")
    (toOutputStream
     "if (denominator == 1)
        fprintf(FERRET_OUTPUT_STREAM, math::format, numerator);
      else if (numerator == 0)
        fprintf(FERRET_OUTPUT_STREAM, \"0\");
      else{
        fprintf(FERRET_OUTPUT_STREAM, math::format,numerator);
        fprintf(FERRET_OUTPUT_STREAM, \"/\");
        fprintf(FERRET_OUTPUT_STREAM, math::format,denominator);
      }
      return nil();")
    
    (fns
     ("math::container getNumerator" "" "return numerator;")
     ("math::container getDenominator" "" "return denominator;")
     ("template<typename T> T as" "" "T::unimplemented_function;")
     ("void simplificate" ""
      "int commondivisor = 1;
        for(math::container i=2;i<=runtime::min(runtime::abs(numerator), runtime::abs(denominator));i++)
          if( numerator%i == 0 && denominator%i == 0 )
            commondivisor = i;
        numerator /= commondivisor;
        denominator /= commondivisor;")
     ("~Number" "" ""))
    (post-code "template<> float Number::as(){
                   return (float)numerator/(float)denominator;
                }
                template<> int Number::as(){
                   if (denominator == 1)
                     return (int)numerator;
                   else
                     return (int)as<float>();
                }
                template<> char Number::as(){
                   return as<int>();
                }"))
#+end_src

**** Keyword

Each keyword in the program is converted to an /Keyword/ object. A
/Keyword/ holds a simple hash of the keyword as an integer.

#+name: runtime-clojure-keyword-object
#+begin_src clojure :tangle no
  (defobject Keyword
    (data "int id;")
    (new ("int b" "id=b;")
         ("const char * str"
          "id = 0;
           for (int i = 0; str[i] != '\\0'; i++){
             id = id + (int)str[i];
           }"))
    (equals "return obj<Boolean>(hash() == o.cast<Keyword>()->hash());")
    (toOutputStream
     "fprintf(FERRET_OUTPUT_STREAM, \"%d\", id); return nil();")
    (fns
     ("int hash" ""
      "return id;")))
#+end_src

**** Sequence

Linked list container implementing the seekable interface.

#+name: runtime-clojure-sequence-object
#+begin_src clojure :tangle no
  (defobject Sequence
    (interface :ISeekable)
    (data "var next;"
          "var data;"
          "size_t size;")
    (new ("var d = nullptr, var n = nullptr, size_t s = 0"
          "next = n; data = d; size = s;"))

    (equals
     "if (size != o.cast<ISeekable>()->count())
        return obj<Boolean>(false);

      var itOther = o;
      FERRET_ITERATE(this,it){
        if (itOther.isNil() || runtime::first(it).equals(runtime::first(itOther))  == false)
          return obj<Boolean>(false);
        itOther = runtime::rest(itOther);
      }
      return obj<Boolean>(true);")
    
    (toOutputStream
     "fprintf(FERRET_OUTPUT_STREAM, \"(\");
      if (size != 0){ 
        data.toOutputStream();
        FERRET_ITERATE(next,it){
          fprintf(FERRET_OUTPUT_STREAM, \" \");
          runtime::first(it).toOutputStream();
        }
      }
      fprintf(FERRET_OUTPUT_STREAM, \")\");
      return nil();")
    (fns
     ("var cons" "var x"
      "return var(new Sequence(x, this, (size + 1)));")
     ("var first" ""
      "return data;")
     ("var rest" ""
      "return next;")
     ("size_t count" ""
      "return size;")))
#+end_src

**** Lazy Sequence

A lazy list container implementing the seekable interface.

#+name: runtime-clojure-sequence-object
#+begin_src clojure :tangle no
  (defobject LazySequence
    (interface :ISeekable)
    (data "var seq;")
    (new ("var t"
          "seq = obj<Sequence>(nullptr,t,0);")
         ("var d, var t"
          "seq = obj<Sequence>(d,t,0);"))
    (equals
     "var itOther = o;
      FERRET_ITERATE(this,it){
        if (itOther.isNil() || runtime::first(it).equals(runtime::first(itOther))  == false)
          return obj<Boolean>(false);
        itOther = runtime::rest(itOther);
      }
      return obj<Boolean>(true);")
    (toOutputStream
     "fprintf(FERRET_OUTPUT_STREAM, \"(\");
        if (!seq.isNil()){ 
          runtime::first(seq).toOutputStream();
          FERRET_ITERATE(runtime::rest(var(this)),it){
            fprintf(FERRET_OUTPUT_STREAM, \" \");
            runtime::first(it).toOutputStream();
          }
        }
        fprintf(FERRET_OUTPUT_STREAM, \")\");
        return nil();")
    
    (fns
     ("var cons" "var x"
      "return obj<LazySequence>(x,runtime::rest(seq));")
     
     ("var first" ""
      "return runtime::first(seq);")
     ("var iterate" ""
      "var s = run(runtime::rest(seq));
       if (s.isNil())
         return nil();
       return s;")
     ("var rest" ""
      "return iterate();")
     ("size_t count" ""
      "size_t acc = 1;
       var s = iterate();
       while(!s.isNil()){ 
        s = runtime::rest(s);
        acc++;
       }
       return acc;")))
#+end_src

#+name: runtime-clojure-sequence-object
#+begin_src clojure :tangle no
  (defn new-lazy-seq [f]
    "__result = obj<LazySequence>(f);")

  (defmacro lazy-seq [& body]
    (list 'new-lazy-seq (cons 'fn `( [] ~@body))))
#+end_src

**** String

Strings are represented as a linked list of characters.

#+name: runtime-clojure-string-object
#+begin_src clojure :tangle no
  (defobject String
    (interface :ISeekable)
    (data "var data;")
    (new (""
          "data = nullptr;")
         ("var s"
          "data = s;")
         ("const char * str"
          "int length = 0;
           for (length = 0; str[length] != '\\0'; length++);
           length--;
           var s = runtime::cons(obj<Number>(str[length]),obj<Sequence>());
           for (int i = --length; i >= 0; i--)
             s = runtime::cons(obj<Number>(str[i]),s);
           data = s;"))
    (equals "return obj<Boolean>(container().equals(o.cast<String>()->container()));")
    (toOutputStream
     "FERRET_ITERATE(data,it){ 
       char ch = runtime::first(it).cast<Number>()->as<char>();
       fprintf(FERRET_OUTPUT_STREAM, \"%c\",ch);
      }
      return nil();")
    (fns
     ("var container" ""
      "return data;")
     ("var cons" "var x"
      "return data.cast<ISeekable>()->cons(x);")
     ("var first" ""
      "return runtime::first(data);")
     ("var rest" ""
      "return runtime::rest(data);")
     ("size_t count" ""
      "return data.cast<ISeekable>()->count();")
     ("ifdef FERRET_STD_LIB"
      "std::string toString" ""
      "std::stringstream ss;
       FERRET_ITERATE(data,it){ss << runtime::first(it).cast<Number>()->as<char>();}
       return ss.str();")
     ("ifdef FERRET_STD_LIB"
      "const char* toCString" ""
      "return toString().c_str();")))
#+end_src

**** Boolean

A boolean object,

#+name: runtime-clojure-boolean-object
#+begin_src clojure :tangle no
  (defobject Boolean
    (data "bool value;")
    (new ("bool b" "value = b;"))
    (equals "return obj<Boolean>(value == (bool)o);")
    (toOutputStream
     "if (value)
        fprintf(FERRET_OUTPUT_STREAM, \"true\"); 
      else
      fprintf(FERRET_OUTPUT_STREAM, \"false\"); 
      return nil();")
    (fns
     ("bool container" ""
      "return value;"))
    (post-code "var::operator bool() const {
                  if (m_ptr == nullptr)
                    return false;
                  else if (m_ptr->getType() == runtime::type::Boolean)
                    return static_cast<Boolean*>(m_ptr)->container();
                  else
                    return true;
                 }
                 var var::equals (var rhs){
                   if (get() == rhs.get())
                     return obj<Boolean>(true);
                   else if (m_ptr->getType() != rhs.cast<Object>()->getType())
                     return obj<Boolean>(false);
                   else
                     return get()->equals(rhs);
                  }"))
#+end_src

**** Atom

Mimics Clojure's /atom/. It is thread safe when used on system where
=FERRET_STD_LIB= is defined.

#+name: runtime-clojure-atom-object
#+begin_src clojure :tangle no
  (defobject Atom
    (data "var data;"
          "FERRET_NEW_LOCK(lock)")
    (new ("var d"
          "data = d;"))
    (equals "return obj<Boolean>(this == o.cast<Atom>());")
    (toOutputStream
     "fprintf(FERRET_OUTPUT_STREAM, \"atom <\");
      data.toOutputStream();
      fprintf(FERRET_OUTPUT_STREAM, \">\");
      return nil();")
    (fns
     ("var swap" "var f,var args"
      "FERRET_WITH_LOCK(lock,{
         args = runtime::cons(data, args);
         data = f.cast<Lambda>()->invoke(args);
       });
      return data;")
     ("var deref" "" "return data;")))
#+end_src

Operations on /Atoms/

#+name: runtime-clojure-atom-object
#+begin_src clojure :tangle no
  (defn atom [x]
    "__result = obj<Atom>(x)")

  (defn swap! [a f & args]
    "__result = a.cast<Atom>()->swap(f,args);")

  (defn reset! [a newval]
    (swap! a (fn [old curr] curr) newval))

  (defn deref [a]
    "__result = a.cast<Atom>()->deref();")
#+end_src

*** Interfaces
**** Seekable

All sequence functions use this interface to iterate seekable
containers.

#+name: runtime-clojure-seekable-interface
#+begin_src clojure :tangle no
  (defobject ISeekable
    (interfaces "var cons(var x)"
                "var first()"
                "var rest()"
                "size_t count()")
    (fns ("virtual ~ISeekable" "" "")))
#+end_src

#+name: runtime-native-iseekable-headers
#+begin_src c++ :tangle no
  namespace ferret{
    namespace runtime {
      var first(var coll);
      var rest(var coll);
      var cons(var x, var seq);
      var nth(var seq, var index);
    }
  }
#+end_src

#+name: runtime-native-iseekable-functions
#+begin_src c++ :tangle no
  namespace ferret{
    namespace runtime{
      var first(var coll){
        if (coll.isNil())
          return nil();
        else
          return coll.cast<ISeekable>()->first();
      }

      var rest(var coll){
        if (coll.isNil())
          return obj<Sequence>();
        else
          return coll.cast<ISeekable>()->rest();
      }

      var cons(var x, var seq){
        if (seq.isNil())
          return obj<Sequence>(x, nil(), 1);
        if (seq.cast<Object>()->getType() == runtime::type::Sequence
            && seq.cast<ISeekable>()->count() == 0)
          return obj<Sequence>(x, nil(), 1);
        return seq.cast<ISeekable>()->cons(x);
      }
    
      var nth(var seq, var idx){
        int index = idx.cast<Number>()->as<int>();

        if ( index < 0 || seq.cast<ISeekable>()->count() < idx)
          return nil();
      
        var head = seq;
        for(int i=0; i < index; i++)
          head = runtime::rest(head);
        return runtime::first(head);
      }
    }
  }
#+end_src

#+name: runtime-native-macros
#+begin_src c++ :tangle no
  #define FERRET_ITERATE(c,i) for(var i = c; !i.isNil(); i = runtime::rest(i))
#+end_src

**** Lambda

Every lambda object implements the /Lambda/ interface. All lambdas are
executed via /invoke/ method that takes a sequence of vars as argument
or /nil()/ if there are non, this allows us to execute them in a
uniform fashion.

#+name: runtime-clojure-lambda-interface
#+begin_src clojure :tangle no
  (defobject Lambda
    (interfaces "var invoke(var args)")
    (equals "return obj<Boolean>(this == o.cast<Lambda>());")
    (toOutputStream
     "fprintf(FERRET_OUTPUT_STREAM, \"lambda\"); return nil();")
    (force-type true))
#+end_src

Function invocation,

#+name: function-invocation-api-headers
#+begin_src c++ :tangle no
  namespace ferret{
    template<typename T, typename... Args>
    var run(T fn, Args... args);
        
    template<typename T>
    var run(T fn);

    template<>
    var run(var);
  }
#+end_src

#+name: function-invocation-api
#+begin_src c++ :tangle no
  namespace ferret{
    var runArgs() { 
      return nil(); 
    }
    
    var runArgs(var v) { 
      return obj<Sequence>(v,nil(),1);
    }
    
    template <typename... Args>
    var runArgs(var first, Args... args) { 
      return obj<Sequence>(first, runArgs(args...), ((sizeof...(args)) + 1)); 
    }
    
    template<typename T, typename... Args>
    var run(T fn, Args... args) {
      return fn.invoke(runArgs(args...));
    }

    template<typename T>
    var run(T fn) {
      return fn.invoke(nil());
    }

    template<>
    var run(var fn) {
      return fn.cast<Lambda>()->invoke(nil());
    }

    template<typename... Args>
    var run(var fn, Args... args) {
      return fn.cast<Lambda>()->invoke(runArgs(args...));
    }
  }
#+end_src

** Reference Counting

Garbage collection is handled by reference counting, a /var/ holds a
pointer to an Object, everything is passed around as /vars/ it is
responsible for incrementing/decrementing the reference count, when it
reaches zero it will automatically free the Object. 

#+name: runtime-native-var
#+begin_src c++ :tangle no
  class var{
  public:
    var(Object* ptr = nullptr) : m_ptr(ptr) { addRef(); }

    var(const var& p) : m_ptr(p.m_ptr) { addRef(); }

    var(var&& p) : m_ptr(p.m_ptr) { p.m_ptr = nullptr; }
      
    ~var() { subRef(); }

    var& operator=(var&& p){
      if (this != &p){
        m_ptr = p.m_ptr;
        p.m_ptr = nullptr;
      }
      return *this;
    }
    
    var& operator= (const var& p){
      return *this = p.m_ptr;
    }
    
    var& operator= (Object* ptr){
      if (m_ptr != ptr){
        subRef();
        m_ptr=ptr;
        addRef();
      }
      return *this;
    }

    var equals (var rhs);
    
    operator bool() const;

  #if !defined(FERRET_DISABLE_OUTPUT_STREAM)
    var toOutputStream() {
      if (m_ptr != nullptr )
        m_ptr->toOutputStream();
      else
        fprintf(FERRET_OUTPUT_STREAM, "nil");
      return var();
    }
  #endif
        
    Object* get() { return m_ptr; }
    template<typename T>
    T* cast() { return static_cast<T*>(m_ptr); }

    bool isType(size_t type) { 
      return (static_cast<Object*>(m_ptr)->getType() == type);
    }

    bool isNil() { 
      return (m_ptr == nullptr);
    }

  private:
    void addRef(){
      // Only change if non-null
      if (m_ptr) m_ptr->addRef();
    }
      
    void subRef(){
      // Only change if non-null
      if (m_ptr){
        // Subtract and test if this was the last pointer.
        if (m_ptr->subRef()){
          delete m_ptr;
          m_ptr = nullptr;
        }
      }
    }
      
    Object* m_ptr;
  };

  template<typename FT, typename... Args>
  var obj(Args... args) {
    return var(new FT(args...));
  }

  var nil(){
    return var();
  }
#+end_src

** Configuration

Some options can be configured using /#define/ directives, these can
be defined using /native-define/ or /configure-runtime!/ from program
code.

To disable output stream (usefull on micro controllers to reduce code
size.) use,

#+BEGIN_EXAMPLE
  (configure-runtime! FERRET_DISABLE_OUTPUT_STREAM true)
#+END_EXAMPLE

To disable main use,

#+BEGIN_EXAMPLE
  (configure-runtime! FERRET_DISABLE_MAIN_FUNCTION true)
#+END_EXAMPLE

main won't be defined you need to call /ferret::ProgramRun()/ manually
to start the program.

When

#+BEGIN_EXAMPLE
  (configure-runtime! FERRET_PROGRAM_MAIN some_func)
#+END_EXAMPLE

is defined defined lambda will be invoked after
/ferret::ProgramRun()/, acts as the programs main\//-main/ function.

When 

#+BEGIN_EXAMPLE
  (configure-runtime! FERRET_SINGLE_THREADED true)
#+END_EXAMPLE

is used it will disable locking for built in data structures. By
default when compiling for non embedded platform, Ferret will use /POSIX/
/mutexes/ for locking /Objects/.

When running on systems with UART (ie. embedded systems) following can
be used to set baud rate.

#+BEGIN_EXAMPLE
  (configure-runtime! FERRET_UART_RATE 57600)
#+END_EXAMPLE

By default baud rate is *9600 bps*.

** Initialization
*** Detect Hardware

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
  #if defined(__SAM3X8E__)
    # define FERRET_HARDWARE_ARDUINO TRUE
    # define FERRET_HARDWARE_ARDUINO_DUE TRUE
  #elif defined(__AVR__)
    # define FERRET_HARDWARE_ARDUINO TRUE
    # define FERRET_HARDWARE_ARDUINO_UNO TRUE
  #else
    # define FERRET_STD_LIB TRUE
  #endif

  #if defined(FERRET_HARDWARE_ARDUINO)
    # define FERRET_DISABLE_MAIN_FUNCTION true
    # define FERRET_SINGLE_THREADED true
  #endif
#+end_src

*** Import libraries

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
  #ifdef FERRET_STD_LIB
   #include <iostream>
   #include <sstream>
   #include <cstdio>
   #include <cstdlib>
   #include <atomic>
  #endif

  #ifdef FERRET_HARDWARE_ARDUINO
   #include <Arduino.h>
   #include <stdio.h>
   #include <stdlib.h>
  #endif
#+end_src

*** Configure Hardware

Hardware specific initialization code, 

Setup UART rate,

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
#if !defined(FERRET_UART_RATE)
 # define FERRET_UART_RATE 9600
#endif
#+end_src

**** Arduino

If running on the Arduino platform fix pure virtual functions,

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
#ifdef FERRET_HARDWARE_ARDUINO
  extern "C" void __cxa_pure_virtual(void);
#endif
#+end_src

Setup [[https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter][UART]],

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
#if defined(FERRET_HARDWARE_ARDUINO_UNO) && !defined(FERRET_DISABLE_OUTPUT_STREAM)
  static FILE uartout = {0};

  static int uart_putchar (char c, FILE *stream){
    Serial.write(c);
    return 0 ;
  }

  #define FERRET_OUTPUT_STREAM &uartout
#endif
#+end_src

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
  #ifdef FERRET_HARDWARE_ARDUINO_UNO
   #if !defined(FERRET_DISABLE_OUTPUT_STREAM)
   #define FERRET_INIT_OUTPUT_STREAM                                          \
      Serial.begin(FERRET_UART_RATE);                                                     \
      fdev_setup_stream (&uartout, uart_putchar, NULL, _FDEV_SETUP_WRITE);
   #else
    #define FERRET_INIT_OUTPUT_STREAM ;
   #endif
  #endif
#+end_src

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
#if defined(FERRET_HARDWARE_ARDUINO_DUE) && !defined(FERRET_DISABLE_OUTPUT_STREAM)
 #define FERRET_OUTPUT_STREAM stdout
#endif
#+end_src

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
#ifdef FERRET_HARDWARE_ARDUINO_DUE
 #if !defined(FERRET_DISABLE_OUTPUT_STREAM)
  #define FERRET_INIT_OUTPUT_STREAM Serial.begin(FERRET_UART_RATE);
 #else
  #define FERRET_INIT_OUTPUT_STREAM ;
 #endif
#endif
#+end_src

**** General purpose computing

When C++ Standard Library is present use *stdout* for printing.

#+name: runtime-native-program-header
#+begin_src c++ :tangle no
#ifdef FERRET_STD_LIB
 #define FERRET_OUTPUT_STREAM stdout
#endif
#+end_src

*** Configure Locking

Locking macros. They are disabled when running single threaded or on
an embedded platform. (=FERRET_STD_LIB= not defined.)

#+name: runtime-native-macros
#+begin_src c++ :tangle no
  #if defined(FERRET_STD_LIB) && !defined(FERRET_SINGLE_THREADED)
   #define FERRET_NEW_LOCK(symbol) std::mutex symbol;
   #define FERRET_WITH_LOCK(lock,code)                         \
     {                                                         \
     std::lock_guard<std::mutex> ferretScopeGuard(lock);       \
     code;                                                     \
     }
  #else
   #define FERRET_NEW_LOCK(symbol)
   #define FERRET_WITH_LOCK(lock,code) code;
  #endif
#+end_src

*** Configure Reference Counting

#+name: runtime-native-memory-management-macros
#+begin_src c++ :tangle no
  #if defined(FERRET_SINGLE_THREADED)
    #define FERRET_NEW_REF() size_t refCount;
    #define FERRET_COPY_REF(other) refCount = other.refCount;
  #else
    #define FERRET_NEW_REF() std::atomic<size_t> refCount;
    #define FERRET_COPY_REF(other) refCount.exchange(other.refCount);
  #endif

  #define FERRET_INIT_REF() refCount = 0;
  #define FERRET_INC_REF(this) refCount++;
  #define FERRET_DEC_REF(this) (--refCount <= 0);
#+end_src

* Clojure Core

Once our object system is in place we can define rest of the runtime
(functions/macros) using our Clojure subset,

#+name: runtime-clojure-first
#+begin_src clojure :tangle no
  (defn first [x]
    "__result = runtime::first(x);")

  (defn nil? [x] "__result = obj<Boolean>(x.isNil())")
#+end_src

We can embed C++ code into our functions, which is how most of the
primitive functions are defined such as the /first/ function above,
once primitives are in place rest can be defined in pure Clojure,

#+name: runtime-clojure-println
#+begin_src clojure :tangle no
  (defn println [& more]
    (when more
      (apply print more))
    (newline))
#+end_src

As for macros, normal Clojure rules apply since they are expended using
Clojure, the only exception is that stuff should not expand to fully
qualified Clojure symbols, so the symbol /fn/ should not expand to
/clojure.core/fn/,


#+name: runtime-clojure-defn
#+begin_src clojure :tangle no
  (defmacro defn [name & body]
    (list 'def name (cons 'fn `~body)))
#+end_src

** Native Declarations

Include native headers, (*.h* files)

#+name: runtime-clojure-defn
#+begin_src clojure :tangle no
  (defmacro native-header [& body]
    (cons 'native-declare
          (->> (map #(if (symbol? %)
                       (str "#include \"" (str %) ".h\"\n")
                       (str "#include \"" (str %) "\"\n"))
                    body)
               (apply str)
               (list))))
#+end_src

Configure Ferret Runtime options, (memory pooling, math containers etc.)

#+name: runtime-clojure-defn
#+begin_src clojure :tangle no
  (defmacro configure-runtime! [& body]
    (cons 'native-define
          (->> (partition 2 body)
               (map #(str "#define " (first %) " " (second %) "\n"))
               (list))))
#+end_src

Embed compilations options, (build command, extra source files etc.)

#+name: runtime-clojure-defn
#+begin_src clojure :tangle no
  (defmacro configure-ferret! [& body]
    (list 'native-define (str "// Ferret Build Configuration Begin\n"
                              "//" (str (apply hash-map body)) "\n"
                              "// Ferret Build Configuration End\n")))
#+end_src

** Native Functions

Allows a function to be defined for multiple platforms see [[FFI]] for
examples.

#+name: runtime-clojure-defn
#+begin_src clojure :tangle no
  (defmacro defnative [name args & form]
    (let [includes (->> (filter #(seq? (nth % 2)) form)
                        (map #(cons (nth % 1) (apply list (nth % 2))))
                        (map (fn [form]
                               (let [[guard & headers] form]
                                 (str "\n#if " guard " \n"
                                      (apply str (map #(str "#include \"" % "\"\n") headers))
                                      "#endif\n"))))
                        (map #(list 'native-declare %)))
          body (->> (map #(vector (second %) (last %)) form)
                    (map #(str "\n#if " (first %) " \n"
                               (second %)
                               "\n#endif\n"))
                    (apply str))
          pre-ample (->> (map #(vector (second %) (drop-last (drop 3 %))) form)
                         (map #(str "\n#if " (first %) " \n"
                                    (apply str (map (fn [line] (str line "\n")) (second %)))
                                    "\n#endif\n"))
                         (map #(list 'native-declare %)))]
      (list 'def name (cons 'fn* `( ~args ~@includes ~@pre-ample  ~body)))))
#+end_src

** Misc

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defn identity [x] x)

  (defnative sleep [millis]
    (on "defined FERRET_STD_LIB"
        ("unistd.h")
        "::usleep(millis.cast<Number>()->as<int>() * 1000L);")
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::delay(millis.cast<Number>()->as<int>());"))

  (defnative get-char []
    (on "defined FERRET_STD_LIB"
        "__result = obj<Number>(getchar());"))

  (defmacro defcallback [callback out in & pass-vars]
    (list 'do
          (list 'native-declare
                `~(str "\n" out " " (symbol-conversion callback) "_callack" "(" in "){\n"
                       "run(" (str (symbol-conversion callback) "_callback_fn")
                       (str \, (apply str (interpose " , " (reverse pass-vars)))) ");"
                       "\n}\n"))
          (list 'def `~(symbol (str callback "-callback-fn")) `~callback)))

  (defnative sh [cmd]
    (on "defined FERRET_STD_LIB"
        ("memory")
        "std::shared_ptr<FILE> pipe(popen(cmd.cast<String>()->toCString(), \"r\"), pclose);
         if (!pipe) 
            __result = nil();
         char buffer[128];
         std::string result = \"\";
         while (!feof(pipe.get()))
          if (fgets(buffer, 128, pipe.get()) != NULL)
           result += buffer;
         __result = obj<String>(result.c_str());"))

  (defn system-exit [code]
    "std::exit(code.cast<Number>()->as<int>());")

  (defnative memory-pool-free-pages []
    (on "defined FERRET_MEMORY_POOL_SIZE"
        "int count = 0;
         for(int i = 0; i < FERRET_MEMORY_POOL_SIZE; i++)
           if(ProgramMemory.used[i] == false)
             count++;
         __result = obj<Number>(count);"))

  (defnative memory-pool-print-snapshot []
    (on "defined FERRET_MEMORY_POOL_SIZE"
        "for(int i = 0; i < FERRET_MEMORY_POOL_SIZE; i++)
           fprintf(FERRET_OUTPUT_STREAM, \"%d\",ProgramMemory.used.get(i));
        fprintf(FERRET_OUTPUT_STREAM, \"\\n\");
         __result = nil();"))

  (defn memory-sizeof-ferret-objects []
    (println "var:" ((fn [] "__result = obj<Number>((math::container)sizeof(var));")))
    (println "Object:" ((fn [] "__result = obj<Number>((math::container)sizeof(Object));")))
    (println "Pointer:" ((fn [] "__result = obj<Number>((math::container)sizeof(Pointer));")))
    (println "Number:" ((fn [] "__result = obj<Number>((math::container)sizeof(Number));")))
    (println "Keyword:" ((fn [] "__result = obj<Number>((math::container)sizeof(Keyword));")))
    (println "Sequence:" ((fn [] "__result = obj<Number>((math::container)sizeof(Sequence));")))
    (println "String:" ((fn [] "__result = obj<Number>((math::container)sizeof(String));")))
    (println "Boolean:" ((fn [] "__result = obj<Number>((math::container)sizeof(Boolean));")))
    (println "Lambda:" ((fn [] "__result = obj<Number>((math::container)sizeof(Lambda));")))
    (println "Atom:" ((fn [] "__result = obj<Number>((math::container)sizeof(Atom));"))))
#+end_src

Takes a function and returns the number of millis took.

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defnative time [f]
    (on "defined FERRET_STD_LIB"
        ("sys/time.h")
        "struct timeval  te;
         gettimeofday(&te, NULL);
         unsigned long begin = (int)(te.tv_sec*1000LL + te.tv_usec/1000); 
         run(f);
         gettimeofday(&te, NULL);
         unsigned long end = (int)(te.tv_sec*1000LL + te.tv_usec/1000); 
         __result = obj<Number>((math::container)(end - begin));")
    (on "defined FERRET_HARDWARE_ARDUINO"
        "unsigned long begin = millis();
         run(f);
         unsigned long end = millis();
         __result = obj<Number>((math::container)(end - begin));"))
#+end_src

Threads the expr through the forms. Inserts x as the
last item in the first form, making a list of it if it is not a
list already. If there are more forms, inserts the first form as the
last item in second form, etc.

#+name: runtime-clojure-misc-thread-macro
#+begin_src clojure :tangle no
  (defmacro ->> [x & forms]
    (loop [x x, forms forms]
      (if forms
        (let [form (first forms)
              threaded (if (seq? form)
                         `(~(first form) ~@(next form)  ~x)
                         (list form x))]
          (recur threaded (next forms)))
        x)))
#+end_src

Multi arity functions are handled by the /fn/ macro. There are two
ways to define a function. For single arity functions it accepts the
following form,

#+begin_src clojure :tangle no
  (fn [a] a)
#+end_src

For multi arity functions it expects the following form,

#+begin_src clojure :tangle no
  (fn
    ([a] 1)
    ([a b] 2)
    ([a b & c] 3)
    ([a b [c d] & e] 4))
#+end_src

A multi arity function is a function that counts the number of its
arguments and then dispatches on the number of arguments to each
implementation.

#+name: runtime-clojure-misc-thread-macro
#+begin_src clojure :tangle no
  (defmacro fn [& body]
    (if (vector? (first body))
      (let [[args & body] body]
        (cons 'fn* `(~args ~@body)))
      (let [count-symbol (gensym)
            fn-arg-symbol (gensym)
            fns (map #(cons 'fn* %) body)
            conds (->> (map first body)
                       (map (fn* [args] (filter #(not (= % '&)) args)))
                       (map #(count %)))
            form (if (pos? (.indexOf (last (map first body)) '&))
                   (let [conds (interleave conds fns)
                         arg-dispatch (drop-last 2 conds)
                         last (take-last 2 conds)]
                     (concat arg-dispatch [true (second last)]))
                   (interleave conds fns))]
        
        `(fn* (& ~(list 'ferret-compiler-no-closure fn-arg-symbol))
              ~(->> form
                    (cons fn-arg-symbol)
                    (cons 'fir-dispatch-lambda))))))
#+end_src

** Console I/O

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defnative print [& more]
    (on "!defined(FERRET_DISABLE_OUTPUT_STREAM)"
        "if (more.isNil())
           return nil();
         var f = more.cast<ISeekable>()->first();
         f.toOutputStream();
         var r = more.cast<ISeekable>()->rest();
         FERRET_ITERATE(r,it){
          fprintf(FERRET_OUTPUT_STREAM, \" \");
          runtime::first(it).toOutputStream();
         }"))

  (defnative newline [& more]
    (on "!defined(FERRET_DISABLE_OUTPUT_STREAM)"
        "fprintf(FERRET_OUTPUT_STREAM, \"\\n\");"))

  <<runtime-clojure-println>>
#+end_src

** Looping

#+name: runtime-clojure-looping
#+begin_src clojure :tangle no
  (defmacro doseq [binding & body]
    (list '_doseq_ (second binding) (cons 'fn* `( [~(first binding)] ~@body))))

  (defn _doseq_ [seq f] "FERRET_ITERATE(seq,it){run(f,runtime::first(it));}")

  (defmacro dotimes [binding & body]
    (list '_dotimes_ (second binding) (cons 'fn* `( [~(first binding)] ~@body))))

  (defn _dotimes_ [t f] "for(int i = 0; i < t.cast<Number>()->as<int>(); i++) run(f,obj<Number>(i));")
#+end_src

** Conditionals

#+name: runtime-clojure-conditionals
#+begin_src clojure :tangle no
  (defmacro when [test & body]
    (list 'if test (cons 'do body)))

  (defmacro cond
    [& clauses]
    (when clauses
      (list 'if (first clauses)
            (if (next clauses)
              (second clauses)
              (throw (IllegalArgumentException.
                      "cond requires an even number of forms")))
            (cons 'cond (next (next clauses))))))

  (defmacro while [test & body]
    (list '_while_ (list 'fn* [] test) (cons 'fn* `( [] ~@body))))

  (defn _while_ [pred fn]
    "while(run(pred))
       run(fn);")

  (defmacro forever [& body]
    (cons 'while `(true  ~@body)))

  (defmacro if-let
    ([bindings then]
     `(if-let ~bindings ~then nil))
    ([bindings then else & oldform]
     (let [form (bindings 0) tst (bindings 1)]
       `(let [temp# ~tst]
          (if temp#
            (let [~form temp#]
              ~then)
            ~else)))))
#+end_src

** Sequence

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn map [f col]
    (if (not (empty? col))
      (cons (f (first col))
            (lazy-seq (map f (rest col))))))
#+end_src

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn range
    ([high]
     (range 0 high))
    ([low high]
     (if (< low high)
       (cons low (lazy-seq
                  (range (inc low) high))))))
#+end_src

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn take [n coll]
    (if (not (empty? coll))
      (if (> n 0)
        (cons (first coll)
              (lazy-seq (take (- n 1) (rest coll)))))))
#+end_src

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn concat
    ([x]
     (if (not (empty? x))
       (cons (first x) (lazy-seq (concat (rest x))))))
    ([x y]
     (if (not (empty? x))
       (cons (first x) (lazy-seq (concat (rest x) y)))
       (concat y))))
#+end_src

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn reduce
    ([f [sf & sr]]
     "var acc = run(f, runtime::first(sr), sf);
      FERRET_ITERATE(runtime::rest(sr),it){
        acc = run(f, acc, runtime::first(it));
      }
      return acc;")
    ([f acc coll]
     "FERRET_ITERATE(coll,it){
       acc = run(f, acc, runtime::first(it));
      }
      return acc;"))
#+end_src

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn list [& xs] "if (xs.isNil())
                       __result = obj<Sequence>();
                     else
                       __result = xs;")

  (defn list? [x] "__result = obj<Boolean>(x.isType(runtime::type::Sequence));")

  (defn empty? [x]
    (= (list ) x))

  (defn rest [x] "var r = runtime::rest(x);
                  if (r.isNil())
                    return obj<Sequence>();
                  else 
                    __result = r;")

  (defn nth [coll index] "__result = runtime::nth(coll,index);")

  (defn cons [x seq] "__result = runtime::cons(x, seq);")

  (defn apply [f args] "__result = f.cast<Lambda>()->invoke(args);")

  (defn conj [coll & xs]
    (reduce (fn[h v] (cons v h)) (if (nil? coll) (list) coll) xs))

  (defn reverse [s]
    (reduce conj (list) s))
#+end_src

#+name: runtime-clojure-sequence-count
#+begin_src clojure :tangle no
  (defn count [s]
    "if (s.isNil())
       return obj<Number>(0);
     __result = obj<Number>((math::container)s.cast<ISeekable>()->count());")
#+end_src

** Logical Operators

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn = [& args]
    "var curr = runtime::first(args);
     FERRET_ITERATE(runtime::rest(args),it){
      var first = runtime::first(it);
      if (curr.equals(first) == false)
        return obj<Boolean>(false);
      curr = first;
     }
     return obj<Boolean>(true);")

  (defmacro not= [& test]
    (list 'not (cons '= `( ~@test))))

  (defn <
    ([] true)
    ([x] true)
    ([a b]
     "math::container an = a.cast<Number>()->getNumerator();
      math::container adn = a.cast<Number>()->getDenominator();

      math::container bn = b.cast<Number>()->getNumerator();
      math::container bdn = b.cast<Number>()->getDenominator();

      __result = obj<Boolean>((an * bdn) < (bn * adn));")
    ([a b & more]
     (if (< a b)
       (apply < (cons b more))
       false)))

  (defn >
    ([] true)
    ([x] true)
    ([a b]
     "math::container an = a.cast<Number>()->getNumerator();
      math::container adn = a.cast<Number>()->getDenominator();

      math::container bn = b.cast<Number>()->getNumerator();
      math::container bdn = b.cast<Number>()->getDenominator();

      __result = obj<Boolean>((an * bdn) > (bn * adn));")
    ([a b & more]
     (if (> a b)
       (apply > (cons b more))
       false)))

  (defn >=
    ([] true)
    ([x] true)
    ([a b]
     "math::container an = a.cast<Number>()->getNumerator();
      math::container adn = a.cast<Number>()->getDenominator();

      math::container bn = b.cast<Number>()->getNumerator();
      math::container bdn = b.cast<Number>()->getDenominator();

      __result = obj<Boolean>((an * bdn) >= (bn * adn));")
    ([a b & more]
     (if (>= a b)
       (apply >= (cons b more))
       false)))

  (defn <=
    ([] true)
    ([x] true)
    ([a b]
     "math::container an = a.cast<Number>()->getNumerator();
      math::container adn = a.cast<Number>()->getDenominator();

      math::container bn = b.cast<Number>()->getNumerator();
      math::container bdn = b.cast<Number>()->getDenominator();

      __result = obj<Boolean>((an * bdn) <= (bn * adn));")
    ([a b & more]
     (if (<= a b)
       (apply <= (cons b more))
       false)))

  (defmacro and
    ([] true)
    ([x] x)
    ([x & next]
     (list 'if x `(and ~@next) false)))

  (defmacro or
    ([] nil)
    ([x] x)
    ([x & next]
     (list 'if x x `(or ~@next))))

  (defn not [x]
    "if (x)
       return obj<Boolean>(false);
     return obj<Boolean>(true);")
#+end_src

** Math

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn integer? [x] "__result = obj<Boolean>(x.isType(runtime::type::Number) &&
                                             (x.cast<Number>()->getDenominator() == 1));")

  (defn float? [x] "__result = obj<Boolean>(x.isType(runtime::type::Number) &&
                                           (x.cast<Number>()->getDenominator() != 1));")

  (defn +
    ([] 0)
    ([x] x)
    ([h v]
     "math::container hn = h.cast<Number>()->getNumerator();
      math::container hdn = h.cast<Number>()->getDenominator();

      math::container vn = v.cast<Number>()->getNumerator();
      math::container vdn = v.cast<Number>()->getDenominator();

      math::container ndn = (hdn * vdn);

      __result = obj<Number>(((hn * vdn) + (vn * hdn)),ndn);")
    ([x y & more]
     (reduce + (+ x y) more)))

  (defn inc [x]
    (+ x 1))

  <<runtime-clojure-sequence-count>>

  (defn *
    ([] 1)
    ([x] x)
    ([h v]
     "math::container hn = h.cast<Number>()->getNumerator();
      math::container hdn = h.cast<Number>()->getDenominator();

      math::container vn = v.cast<Number>()->getNumerator();
      math::container vdn = v.cast<Number>()->getDenominator();

      math::container ndn = (hdn * vdn);

      __result = obj<Number>(((hn * vdn) * (vn * hdn)),ndn);")
    ([x y & more]
     (reduce * (* x y) more)))

  (defn -
    ([x]
     (* -1 x))
    ([h v]
     "math::container hn = h.cast<Number>()->getNumerator();
      math::container hdn = h.cast<Number>()->getDenominator();

      math::container vn = v.cast<Number>()->getNumerator();
      math::container vdn = v.cast<Number>()->getDenominator();

      math::container ndn = (hdn * vdn);

      __result = obj<Number>(((hn * vdn) - (vn * hdn)),ndn);")
    ([x y & more]
     (reduce - (- x y) more)))

  (defn /
    ([x]
     (apply / (list 1 x)))
    ([h v]
     "math::container hn = h.cast<Number>()->getNumerator();
      math::container hdn = h.cast<Number>()->getDenominator();

      math::container vn = v.cast<Number>()->getNumerator();
      math::container vdn = v.cast<Number>()->getDenominator();

      __result = obj<Number>((hn * vdn),(vn * hdn));")
    ([x y & more]
     (reduce / (/ x y) more)))

  (defn dec [x]
    (- x 1))

  (defn pos? [x]
    (> x 0))

  (defn neg? [x]
    (< x 0))

  (defn zero? [x]
    (= x 0))

  (defn floor [x] "__result = obj<Number>(x.cast<Number>()->as<int>());")

  (defn mod [num div] "__result = obj<Number>((num.cast<Number>()->as<int>() % div.cast<Number>()->as<int>()));")
#+end_src

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn scale [x in-min in-max out-min out-max]
    (+ (/ (* (- x in-min) (- out-max out-min)) (- in-max in-min)) out-min))

  (defn clamp [x min max]
    (cond
      (> x max) max
      (< x min) min
      true x))
#+end_src

** Bit Operations

#+name: runtime-clojure-bit-operations
#+begin_src clojure :tangle no
  (defn bit-not [x] "__result = obj<Number>(~x.cast<Number>()->getNumerator());")

  (defn bit-and [x y] "__result = obj<Number>((x.cast<Number>()->getNumerator() &
                                               y.cast<Number>()->getNumerator()));")

  (defn bit-or [x y] "__result = obj<Number>((x.cast<Number>()->getNumerator() |
                                              y.cast<Number>()->getNumerator()));")

  (defn bit-xor [x y] "__result = obj<Number>((x.cast<Number>()->getNumerator() ^
                                               y.cast<Number>()->getNumerator()));")

  (defn bit-shift-left [x n] "__result = obj<Number>((x.cast<Number>()->getNumerator() <<
                                                      n.cast<Number>()->getNumerator()));")

  (defn bit-shift-right [x n] "__result = obj<Number>((x.cast<Number>()->getNumerator() >>
                                                       n.cast<Number>()->getNumerator()));")
#+end_src

** Concurrency

Runs the given lambda in a thread,

#+name: runtime-clojure-bit-operations
#+begin_src clojure :tangle no
  (defnative thread [f]
    (on "defined FERRET_STD_LIB"
        ("thread")
        "std::thread t([f](){return run(f);});
         t.detach();
         __result = nil();"))
#+end_src

** State Machines

This macro allows users to define state machines using the following
DSL,

#+begin_src clojure :tangle no
  (defmachine two-state-machine
    (states
     (off (println "Off"))
     (on (println "On")))
    (transitions
     (off
      (fn [] true) on)
     (on
      (fn [] true) off)))


  (dotimes [i 10]
    (two-state-machine))
#+end_src

Each transition takes a list of /fn/ /state/ pairs first function that
returns true returns the next state.

#+name: runtime-clojure-state-machine
#+begin_src clojure :tangle no
  (defmacro defmachine [name states transitions]
    (let [transitions
          (->> transitions
               rest
               (map (fn [x]
                      (let [[state & states] x
                            states (->> (partition 2 states)
                                        (map #(list (list (first %)) (second %))))
                            states (->> (clojure.core.protocols/coll-reduce
                                         states (fn [h v]
                                                  (conj h (second v) (first v))) (list))
                                        (cons 'cond))]
                        [(list '= 'state state) (concat states [true state])]))))
          start-state (-> transitions first first last)
          transitions (clojure.core.protocols/coll-reduce
                       transitions (fn [h v] (conj h (first v) (second v))) ['cond])
          states (->> (rest states)
                      (map (fn [x]
                             [(first x)
                              (->> (rest x)
                                   (cons [])
                                   (cons 'fn*))])))
          states (clojure.core.protocols/coll-reduce
                  states (fn [h v]
                           (conj h (first v) (second v))) [])
          state-names (->> states
                           (partition 2)
                           (map first))
          state-symbols (->> states
                             (partition 2)
                             (map second))
          func (list 'fn (into [] state-names)
                     (list
                      (list 'fn [(symbol (str name "-state"))]
                            `~(list 'fn* []
                                    (list
                                     (list 'fn* []
                                           `~(list 'swap! (symbol (str name "-state"))
                                                   (list 'fn* ['state]
                                                         (list 'state)
                                                         `(~@transitions)))))))
                      (list 'atom start-state)))]
      (list 'def name (cons func state-symbols))))
#+end_src

** Arduino

Some wrappers for the Arduino platform.

#+name: runtime-clojure-arduino
#+begin_src clojure :tangle no
  (defn pin-mode [pin mode]
    "if (mode.equals(obj<Keyword>(618)) == true) // :input
        pinMode(pin.cast<Number>()->as<int>(), INPUT);
     else
        pinMode(pin.cast<Number>()->as<int>(), OUTPUT);")

  (defn digital-write [pin mode]
    "if (mode.equals(obj<Keyword>(474))  == true) // :high
        digitalWrite(pin.cast<Number>()->as<int>(), HIGH);
     else
        digitalWrite(pin.cast<Number>()->as<int>(), LOW);")
#+end_src

** Testing

#+name: runtime-clojure-testing
#+begin_src clojure :tangle no
  (defn assert-aux [f msg]
    (when (not (f))
      (println "Assertion Failed ==>" msg)
      ((fn [] "std::abort();"))))

  (defn assert-aux-callback [f callback]
    (when (not (f)) (callback)))

  (defmacro assert
    ([exp]
     (list 'assert-aux
           (cons 'fn `( [] ~exp)) (pr-str exp)))
    ([exp callback]
     (list 'assert-aux-callback
           (cons 'fn `( [] ~exp)) (cons 'fn `( [] ~callback)))))
#+end_src

* Tests
  :PROPERTIES:
  :noweb-ref: ferret-unit-tests
  :END:

All tests are compiled using,

 - *-std=c++11*
 - *-pedantic*
 - *-Werror*
 - *-Wall*
 - *-Wextra*
 - *-Woverloaded-virtual*
 - *-Wuninitialized*
 - *-Wmissing-declarations*
 - *-Winit-self*

** Compiler
*** Internal

#+begin_src clojure
  (deftest compiler-transformation
    (is (= (symbol-conversion '(make-adder 2)) '(make_adder 2)))
    (is (= (symbol-conversion '(make-adder* 2)) '(make_adder_star_ 2)))

    (let [form (->> '((def make-adder (fn [n] (fn [x] (+ x n)))))
                    expand-macros-all
                    closure-conversion)]
      (is (= (first (second form)) 'fir-define-lambda))
      (is (= (last (second form)) '(+ x n)))
      (is (= (second (first form)) 'make-adder))
      (is (= (first (first form)) 'def))))
#+end_src

*** Macros

#+begin_src clojure
  (deftest compiler-macro
    (is (= "1 1 1 true false true true true (3 3)012343 5"
           (capture-output '((defmacro my-when [test & body]
                               (list 'if test (cons 'do body)))

                             (defmacro some-list [a]
                               (let [a (inc a)]
                                 (list 'list a a)))
                             
                             (print (my-when (< 2 3) 1)
                                    (when (< 2 3) 1)
                                    (when (< 2 3) 1)
                                    (let [a 1]  (and (> a 0) (< a 10)))
                                    (let [a 11] (and (> a 0) (< a 10)))
                                    (and true true)
                                    (or true false)
                                    (let [a 11] (or (> a 0) (< a 10)))
                                    (some-list 2))
                             
                             (dotimes [i 5] (print i))
                             (let [a 1]
                               (defn adder [x]
                                 (+ a x)))
                             (defn my-inc [x] (+ 1 (adder x)))
                             (print (my-inc 1))

                             (print " ")
                             (let [x 2
                                   y (->> x (+ 1) (+ 2))]
                               (print y)))))))
#+end_src

*** Reader Macros

#+begin_src clojure :tangle no
  (deftest compiler-reader-macro
    (is (= "1 3"
           (capture-output '((print @(atom 1))
                             (print " ")
                             (print (#(+ 1 2))))))))
#+end_src

*** Special Forms

#+begin_src clojure
  (deftest compiler-special-forms
    (is (= "10 89 11 3 1 5 51111111111"
           (capture-output '((def make-adder
                               (fn [n] (fn [x] (+ x n))))
                             (def adder
                               (make-adder 1))

                             (def fibo (fn [n]
                                         (if (< n 2)
                                           1
                                           (+ (fibo (- n 1))
                                              (fibo (- n 2))))))

                             (def adder-let (let [a 1
                                                  b 2]
                                              (fn [n] (+ a b n))))

                             (def adder-let-2 (fn [n]
                                                (let [a 1
                                                      b 2]
                                                  (+ a b n))))

                             (native-declare "int i = 0;")
                             (defn inc-int [] "__result =  obj<Number>(i++);")
                             
                             (print (adder 9)
                                    (fibo 10)
                                    ((fn [n] (+ n 1)) 10)
                                    (((fn [n] (fn [n] n)) 3) 3)
                                    (if (< 2 3 4 5 6)
                                      (do 1)
                                      (do 2))
                                    (adder-let 2)
                                    (adder-let-2 2))
                             (while (< (inc-int) 10)
                               (print 1)))))))
#+end_src

*** Destructuring

#+begin_src clojure :tangle no
  (deftest compiler-destructure
    (is (= "(1 2 3) 2 3 ((1 2 3)) 1 2 (3 4) 1 2 4 (5) (3) 1 2 3 3 3 5 1 2 3 nil nil nil"
           (capture-output '((defn destructure-test-1 [[a b c]]
                               (list a b c))
                             (defn destructure-test-2 [[a [b] c]]
                               b)
                             (defn destructure-test-3 [[a [_ b] c]]
                               b)
                             (defn destructure-test-4 [& a]
                               a)
                             (defn destructure-test-5 []
                               (let [[a b c] (list 1 2 3)]
                                 (print a b c)))
                             (defn destructure-test-6 []
                               (let [[_ _ a] (list 1 2 3)]
                                 (print a)))
                             (print (destructure-test-1 (list 1 2 3))
                                    (destructure-test-2 (list 1 (list 2) 3))
                                    (destructure-test-3 (list 1 (list 2 3) 3))
                                    (destructure-test-4 (list 1 2 3)))
                             (print " ")
                             (let [a (list 1 2 3 4)
                                   [b c & r] a]

                               (print b c r))
                             (let [a 1 b 2
                                   [c & r] (list 4 5)]
                               (print " ")
                               (print a b c r))
                             (let [[a & r] (list 1 2 3)
                                   rr (rest r)]
                               (print " ")
                               (print rr))
                             (print " ")
                             (destructure-test-5)
                             (print " ")
                             (destructure-test-6)
                             (print " ")
                             (let [[_ _ a] (list 1 2 3)
                                   [_ b] (list 4 5 6)]
                               (print a b))
                             (print " ")
                             (let [a (list 1 2 3)
                                   [b c d e f g] a]
                               (print b c d e f g)))))))
#+end_src

*** Program Main

#+begin_src clojure
  (deftest compiler-program-main
    (is (= "Hello World"
           (capture-output '((configure-runtime! FERRET_PROGRAM_MAIN greet)
                             (defn hello []
                               (print "Hello World"))
                             (def greet hello))))))
#+end_src

** Native Core
*** Memory Pool

#+begin_src clojure
  (deftest native-core-memory-pool
    (is (= "0 2 6 2 1 1 1 1 1 "
           (capture-output
            '((native-define "#define FERRET_MEMORY_POOL_SIZE 2048")
              (native-declare "ferret::MemoryPool<size_t,10,size_t> mem;")
              (native-declare "void* ptr;")
              ((fn [] "std::cout << mem.nextAvaliblePage(0) << \" \";"))
              ((fn [] "mem.allocate(sizeof(size_t)*2);"))
              ((fn [] "std::cout << mem.nextAvaliblePage(0) << \" \";"))
              ((fn [] "ptr = mem.allocate(sizeof(size_t)*4);"))
              ((fn [] "std::cout << mem.nextAvaliblePage(2) << \" \";"))
              ((fn [] "mem.free(ptr);"))
              ((fn [] "std::cout << mem.nextAvaliblePage(2) << \" \";"))
              ((fn [] "std::cout << (nullptr == mem.allocate(sizeof(size_t)*40)) << \" \";"))
              ((fn [] "std::cout << (nullptr != mem.allocate(sizeof(size_t)*6)) << \" \";"))
              ((fn [] "std::cout << (nullptr != mem.allocate(sizeof(size_t)*1)) << \" \";"))
              ((fn [] "std::cout << (nullptr != mem.allocate(sizeof(size_t)*1)) << \" \";"))
              ((fn [] "std::cout << (nullptr == mem.allocate(sizeof(size_t)*10)) << \" \";")))))))
#+end_src

*** Object System
**** Keyword

#+begin_src clojure
  (deftest native-core-keyword
    (is (= "true false true"
           (capture-output '((print (= :test :test)
                                    (= :test :other_test)
                                    ((fn [keyword]
                                       "__result = obj<Boolean>(keyword.equals(obj<Keyword>(\":space\")))")
                                     :space)))))))
#+end_src

**** Sequence

#+begin_src clojure :tangle no
  (deftest native-core-sequences
    (is (= "false false true false false"
           (capture-output '((print (= (list ) (list 1 2 3))
                                    (= (list 1 2) (list 1 2 3))
                                    (= (list 1 2 3) (list 1 2 3))
                                    (= (list 1 2 3) (list 1 2 4))
                                    (= (list 1 1 3) (list 1 2 3)))))))
    (is (= "(1 2 3 4) 1 (2 3 4) (3 4) (3 3 4) 3 4 (4 3 2 1 1 2) (4 3 2 1) 21 21 (nil) (1) () nil 0"
           (capture-output '((print (list 1 2 3 4)
                                    (first (list 1 2 3 4))
                                    (rest (list 1 2 3 4))
                                    (rest (rest (list 1 2 3 4)))
                                    (cons 3 (rest (rest (list 1 2 3 4))))
                                    (first (cons 3 (rest (rest (list 1 2 3 4)))))
                                    (count (list 1 2 3 4))
                                    (conj (list 1 2) 1 2 3 4)
                                    (conj nil 1 2 3 4)
                                    (reduce + (list 1 2 3 4 5 6))
                                    (apply + (list 1 2 3 4 5 6))
                                    (cons nil nil)
                                    (cons 1 nil)
                                    (rest (list))
                                    (first (rest (rest (list))))
                                    (count (list )))))))
    (is (= "(6 5 4 3 2 1) (6 5 4 3 2) (4 3 2 1 0) true"
           (capture-output '((print (reverse (list 1 2 3 4 5 6))
                                    (reduce (fn [h v]
                                              (conj h (inc v))) (list) (list 1 2 3 4 5))
                                    (reduce (fn [h v]
                                              (conj h (dec v))) (list) (list 1 2 3 4 5))
                                    (= (list ) (list )))))))

    (is (= "(1 2 3 4 5 6) (7 6 5 4 3 2) (1 7 6 5 4 3 2) true"
           (capture-output '((let [l1 (list 1 2 3 4 5 6)
                                   l2 (reduce (fn[h v] (conj h (inc v))) (list) l1)
                                   l3 (cons 1 l2)]
                               (print l1 l2 l3 (empty? (rest nil))))))))
    (is (= "(2 3 4) (0 1 2) (4 5 6) 3 (0 1 2 3 4) 5 (0 1 2 3 4 5 6 7 8 9) (2 3) (2 3 4) (1 2 3 4 5 6 7) 21"
           (capture-output '((print (map inc (list 1 2 3))
                                    (map dec (list 1 2 3))
                                    (map (fn [x] (+ 3 x)) (list 1 2 3))
                                    (count (map inc (list 1 2 3)))
                                    (range 5)
                                    (count (range 5))
                                    (range 0 10)
                                    (take 2 (map inc (list 1 2 3)))
                                    (take 20 (map inc (list 1 2 3)))
                                    (concat (list 1 2 3) (list 4 5 6 7))
                                    (reduce + (concat (list 1 2 3) (list 4 5 6))))))))
    (is (= "1 2 3 nil nil"
           (capture-output '((print (nth (list 1 2 3) 0)
                                    (nth (list 1 2 3) 1)
                                    (nth (list 1 2 3) 2)
                                    (nth (list 1 2 3) 10)
                                    (nth (list 1 2 3) -10)))))))
#+end_src

**** Lazy Sequence

#+begin_src clojure
  (deftest native-core-lazy-sequence
    (is (= "10 11 12 (10 9 8 7 6 5 4 3 2 1 0)"
           (capture-output '((let [a 1]
                               (defn lazy-countdown [n]
                                 (if (>= n 0)
                                   (cons n (lazy-seq (lazy-countdown (- n 1))))))
                               
                               (defn ints-from [n]
                                 (cons n (lazy-seq (ints-from (inc n))))))
                             
                             (print (first (ints-from 10))
                                    (first (rest (ints-from 10)))
                                    (first (rest (rest (ints-from 10))))
                                    (lazy-countdown 10)))))))
#+end_src

**** String

#+begin_src clojure
  (deftest native-core-string
    (is (= "Some String false true false true"
           (capture-output
            '((print "Some String"
                     (= "Some String" "Other String")
                     (= "Some String" "Some String")
                     (= "Some String" 1)
                     ((fn [str] "__result = obj<Boolean>((str.cast<String>()->toString() == \"String\"))")
                      "String")
                     ))))))
#+end_src

**** Atom

#+begin_src clojure
  (deftest native-core-atom
    (is (= "nil12(1 2 3)6truefalsefalse"
           (capture-output '((let [a (atom nil)
                                   b (atom nil)]
                               (print (deref a))
                               (reset! a 1)
                               (print (deref a))
                               (swap! a inc)
                               (print (deref a))
                               (reset! a (list 1 2 3))
                               (print (deref a))
                               (swap! a (fn [l] (reduce + l)))
                               (print (deref a))
                               (print (= a a))
                               (print (= a b))
                               (print (= a 1))))))))
#+end_src

**** Lambda

#+begin_src clojure
  (deftest native-core-lambda
    (is (= "true false true false 1 2 3 4"
           (capture-output '((let [f1 (fn [])
                                   f2 (fn [])
                                   m-func (fn
                                            ([a] 1)
                                            ([a b] 2)
                                            ([a b & c] 3)
                                            ([a b [c d] & e] 4))]
                               (print (= f1 f1)
                                      (= f1 f2)
                                      (= f1 (do f1))
                                      (= f2 (do f1)))
                               (print " ")
                               (print (m-func 1)
                                      (m-func 1 2)
                                      (m-func 1 2 3)
                                      (m-func 1 2 (list 3 3) 4))))))))
#+end_src

** Clojure Core
*** Conditionals

#+begin_src clojure
  (deftest clojure-core-conditionals
    (is (= "2 1 -1 2 2 2 1 2 nil 5"
           (capture-output '((print (if 1 2)
                                    (if (zero? 0) 1 -1)
                                    (if (zero? 1) 1 -1)
                                    (when true 2)
                                    (when (integer? 2) 2)
                                    (cond (float? 2.1) 2
                                          (integer? 2) 4
                                          true 1)
                                    (cond (float? 2) 2.1
                                          (integer? 2.1) 4
                                          true 1)
                                    (if nil 1 2)
                                    (if-let [a nil]
                                      a)
                                    (if-let [a 5]
                                      a)))))))
#+end_src

*** Logical Operators

#+begin_src clojure
  (deftest clojure-core-logical-operators
    (is (= "true true false true false true true true false true true false true false true true"
           (capture-output '((print (< 2)
                                    (< 2 3 4 5)
                                    (< 2 3 6 5)
                                    (> 2)
                                    (> 2 3 4 5)
                                    (> 6 5 4 3)
                                    (>= 2)
                                    (>= 5 4 3 2 2 2)
                                    (>= 5 1 3 2 2 2)
                                    (<= 2)
                                    (<= 2 2 3 4 5)
                                    (<= 2 2 1 3 4)
                                    (= 2)
                                    (= 2 3)
                                    (= 2 2 2 2)
                                    (= 2 2.0 2))))))

    (is (= "false true false true false falsetrue false true true"
           (capture-output '((print (= 2 2 2 2 3 5)
                                    (= (list 1 2) (list 1 2))
                                    (= (list 1 2) (list 1 3))
                                    (= true true)
                                    (not (= true true))
                                    (not 1))
                             (let [a (fn [x] (+ 1 x))
                                   b (fn [x] (inc x))]
                               (print (= a a)
                                      (= a b)
                                      (= nil ((fn [] )))
                                      (= nil ((fn [x y] ) 1 2)))))))))
#+end_src

*** Math

#+begin_src clojure :tangle no
  (deftest clojure-core-arithmetic
    (is (= "3/5 0 1 10 10 -1 0 0 1 8 8 1 1/2 1 1 1 1 1 0 0 1 1"
           (capture-output '((print (+ 0.3 0.3)
                                    (+ )
                                    (+ 1)
                                    (+ 1 2 3 4)
                                    (+ 1 2.0 3 4)

                                    (- 1)
                                    (- 4 2 2)
                                    (- 4 2 2.0)
                                    
                                    (* )
                                    (* 2 2 2)
                                    (* 2.0 2 2)
                                    
                                    (/ 1)
                                    (/ 2)
                                    (/ 4 2 2)
                                    (/ 4 2 2.0)

                                    (floor 1.1)
                                    (floor 1.5)
                                    (floor 1.9)

                                    (mod 2 2)
                                    (mod 4 2)
                                    (mod 5 2)
                                    (mod 8 7))))))

    (is (= "true true false false true true false true true true"
           (capture-output '((print (pos? 1)
                                    (pos? 0.2)
                                    (pos? 0)
                                    (neg? 1)
                                    (neg? -1)
                                    (zero? 0)
                                    (zero? 10)
                                    (zero? (- 1 1))
                                    (zero? (- 1.2 1.2))
                                    (zero? (+ 1.2 -1.2)))))))

    (is (= "1 21 21 21 2"
           (capture-output '((let [a 1
                                   b 2]
                               (+ 1 a)
                               (+ b a)
                               (print a b)
                               (* 2 a)
                               (* b a)
                               (print a b)
                               (/ 2 a)
                               (/ b a)
                               (print a b)
                               (- 2 a)
                               (- b a)
                               (print a b)))))))
#+end_src

#+begin_src clojure :tangle no
  (deftest clojure-core-math
    (is (= "100 50 0 5 10 0 -10"
           (capture-output '((print (scale 10 0 10 0 100)
                                    (scale 5 0 10 0 100)
                                    (scale 0 0 10 0 100)
                                    (clamp 10 0 5)
                                    (clamp 10 0 20)
                                    (clamp 10 -10 0)
                                    (clamp -100 -10 0)))))))
#+end_src

*** Module System

Run import tests. 

#+begin_src clojure :tangle no
  (deftest import-module-test
    (is (= "Module AModule C 10 11 1 42"
           (capture-output '((require '[test.modules.module-a :as mod-a])
                             (require '[test.modules.module-b :as mod-b])
                             (mod-a/helper-a)
                             (mod-b/helper-b)
                             (print " ")
                             (print ((mod-a/ten-fn))
                                    ((mod-b/eleven-fn))
                                    (mod-a/helper-c)
                                    (mod-b/macro-call)))))))
#+end_src

**** Dummy Modules
     :PROPERTIES:
     :noweb-ref: ferret-tests-modules-no-export
     :END:  

Create some dummy libs under /test/modules/,

#+begin_src clojure :mkdirp yes :tangle src/test/modules/module-a.clj
  (defn helper-a []
    (print "Module A"))

  (defmacro ten-fn []
    (list 'fn [] 10))

  (defmacro helper-b []
    (reduce (fn [a b] (+ a b)) (list 1 2 3))
    1)

  (defn helper-c []
    (helper-b))
#+end_src 

#+begin_src clojure :mkdirp yes :tangle src/test/modules/module-b.clj
  (require '[test.modules.module-c :as mod-c])

  (defn helper-b []
    (mod-c/helper-c))

  (defn eleven-fn []
    (mod-c/eleven-fn))

  (defnative macro-aux []
    (on "defined FERRET_STD_LIB"
        "__result = obj<Number>(42);"))

  (defmacro macro-call []
    (list 'do
          (list 'macro-aux)))
#+end_src 

#+begin_src clojure :mkdirp yes :tangle src/test/modules/module-c.clj
  (defn helper-c []
    (print "Module C"))

  (defmacro eleven-fn []
    (list 'fn [] 11))
#+end_src 

*** Misc

#+begin_src clojure :tangle no
  (deftest bit-operations-test
    (is (= "-5 -1 7 1 0 0 0 1 8 16 2 1"
           (capture-output '((print (bit-not  4)
                                    (bit-not  0)
                                    (bit-or   4 3)
                                    (bit-or   0 1)
                                    (bit-and  4 3)
                                    (bit-and  0 1)
                                    (bit-xor  4 4)
                                    (bit-xor  1 0)
                                    (bit-shift-left 4 1)
                                    (bit-shift-left 4 2)
                                    (bit-shift-right 4 1)
                                    (bit-shift-right 4 2)))))))
#+end_src

#+begin_src clojure :tangle no
  (deftest thread-test
    (is (= "Thread-1Thread-2"
           (capture-output '((defn print-some [y x]
                               (fn []
                                 (sleep y)
                                 (print x)))
                             (thread (print-some 0 "Thread-1"))
                             (thread (print-some 1 "Thread-2"))
                             (sleep 3))))))
#+end_src

#+begin_src clojure :tangle no
  (deftest state-machine-test
    (is (= "10 0 10"
           (capture-output '((def state (atom 0))
                             (defmachine two-state-machine
                               (states
                                (off (swap! state inc))
                                (on (swap! state inc)))
                               (transitions
                                (off
                                 (fn [] true) on)
                                (on
                                 (fn [] true) off)))
                             (dotimes [_ 10]
                               (two-state-machine))
                             (print (deref state))
                             (print " ")
                             (reset! state 0)
                             (print (deref state))

                             (defmachine three-state-machine
                               (states
                                (a (swap! state inc))
                                (b (swap! state inc))
                                (c (swap! state inc))
                                (no-op (swap! state inc)))
                               (transitions
                                (a
                                 (fn [] false) no-op
                                 (fn [] true) b)
                                (b
                                 (fn [] true) c)
                                (c
                                 (fn [] false) no-op
                                 (fn [] false) no-op
                                 (fn [] true) a
                                 (fn [] false) no-op)))
                             (dotimes [_ 10]
                               (three-state-machine))
                             (print " ")
                             (print (deref state)))))))
#+end_src

*** Testing

#+begin_src clojure :tangle no
  (deftest testing-test
    (is (= "Assertion Failed ==> false\n"
           (capture-output '((assert true)
                             (assert false)))))
    (is (= "Assertion Failed ==> (= 2 3)\n"
           (capture-output '((assert (= 2 2))
                             (assert (= 2 3))))))
    (is (= "Assertion Failed ==> (= a b)\n"
           (capture-output '((let [a 1
                                   b 2]
                               (assert (= a a))
                               (assert (= a b)))))))
    (is (= "CB"
           (capture-output '((assert true)
                             (assert false (print "CB"))))))
    (is (= "CB"
           (capture-output '((assert (= 2 2))
                             (assert (= 2 3) (print "CB"))))))
    (is (= "CB"
           (capture-output '((let [a 1
                                   b 2]
                               (assert (= a a))
                               (assert (= a b) (print "CB"))))))))
#+end_src

* Roadmap
** Core

  - *Lazy Sequence* - Should cache the result of *rest* and return it
    on subsequent calls.
  - *Unit Testing*
    - [[http://www.jera.com/techinfo/jtns/jtn002.html][JTN002 - MinUnit -- a minimal unit testing framework for C]]
  - *Pre/Post conditions* for functions.
    - By default print error and abort. 
    - Let user define a callback function.
  - *Compile Time Interfaces*
    Load different module implementations for different config
    options.
  - *Association Lists* as an alternative to maps. More suited to
    embedded systems. Quoted from Wikipedia, for quite small values of
    n it is more efficient in terms of time and space than more
    sophisticated strategies such as hash tables.
  - *Unbounded Precision Integers*
    - [[https://web.archive.org/web/20101208222557/http://www.mactech.com/articles/mactech/Vol.08/08.03/BigNums/index.html][Arbitrarily Large Bignums]]
    From p.11: PICOBIT: A Compact Scheme System for Microcontrollers
    - Larger values are needed in some embedded applications.
      - 48 bit integers to store MAC addresses.
      - SHA family of cryptographic hashing functions, which need
        values up to 512 bits wide.
      - If an application keeps track of time at the microsecond level
        using a 32-bit value, a wraparound will occur every hour or
        so.
    - Unbounded precision integers are encoded in PICOBIT as linked
      lists of 16 bit values. At the end of each list is either the
      integer 0 or -1, to represent the sign. 0, -1 and other small
      integers have dedicated encodings and do not need to be
      represented as linked lists. The use of this “little-endian”
      representation simplifies the bignum algorithms in particular
      for numbers of different lengths.
    - On versions of PICOBIT which do not support unbounded precision
      integers (including PICOBIT Light), integers are limited to 24
      bits, and encoded directly in the object.
  - *How to propagate errors* - No Exceptions on embedded systems.
    Quoted from Bjarne's C++ FAQ - JSF++ is for hard-real time and
    safety-critical applications (flight control software). If a
    computation takes too long someone may die. For that reason, we
    have to guarantee response times, and we can't - with the current
    level of tool support - do that for exceptions. In that context,
    even free store allocation is banned! Actually, the JSF++
    recommendations for error handling simulate the use of exceptions
    in anticipation of the day where we have the tools to do things
    right, i.e. using exceptions.
  - *MemoryPool* - Out Of Memory should not be fatal.
    - Seperate static critical data structures to a seperate pool.
  - *Ranged Numbers* - This type is an int but can only be 1-12.
  - *Safety when used in ISR*.
  - *Escape Analysis* for other types. Escape analysis is only used
    for functions.
  - *Readbility* - Add context to auto generated symbols in compiled
    code.
  - *Core.typed* - Attach type information to the program.

*** Libraries

  - RPi GPIO
    - http://elinux.org/RPi_Low-level_peripherals
    - http://elinux.org/RPi_GPIO_Code_Samples
  - Sqlite Wrapper.
  - Web Framework.
    - [[https://github.com/ipkn/crow][crow]]
    - [[http://siliconframework.org/][Silicon]]

** The Rearview
*** Core
  - *assert* - https://clojuredocs.org/clojure.core/assert
* Files                                                            :noexport:
** project.clj
#+begin_src clojure :mkdirp yes :tangle src/project.clj
  (defproject ferret "1.0.0-SNAPSHOT"
    :dependencies [[org.clojure/clojure "1.7.0"]
                   [org.clojure/tools.cli "0.3.3"]
                   [org.bituf/clj-stringtemplate "0.2"]
                   [org.clojars.amit/commons-io "1.4.0"]
                   [watchtower "0.1.1"]]
    :repl-options {:host "0.0.0.0"
                   :port 7888
                   :init-ns ferret.core}
    :main ferret.core
    :aot [ferret.core]
    :jar-name "interim.jar"
    :uberjar-name "ferret.jar")
#+end_src 
** src/ferret/core.clj
#+begin_src clojure :noweb yes :mkdirp yes :tangle src/src/ferret/core.clj
  (ns ferret.core
    (:refer-clojure :exclude [compile])
    (:gen-class)
    (:use [clojure.java.io])
    (:require [clojure.set :as set]
              [clojure.zip :as zip]
              [clojure.walk :as walk]
              [clojure.pprint :as pprint]
              [clojure.tools.cli :refer [parse-opts]]
              [watchtower.core :as watcher])
    (:use [ferret.string-template]
          [ferret.template]
          [clojure.java.shell])
    (:import (org.apache.commons.io FileUtils)))

  <<core-code-generation-misc>>
  <<core-compilation-form-fns>>
  <<core-compilation-reader-macros>>
  <<core-compilation-expand-macros>>
  <<core-compilation-shake-concat>>
  <<core-compilation-add-built-in>>
  <<core-compilation-closure-conversion>>
  <<core-compilation-symbol-conversion>>
  <<core-compilation-do-fn>>
  <<core-compilation-let-fn>>
  <<core-compilation-process>>
  <<core-code-generation-emit>>
  <<core-code-generation-emit-source-methods>>
  <<core-code-generation-emit-source>>
  <<core-code-compile-code>>
#+end_src 
** src/ferret/template.clj
#+begin_src clojure :mkdirp yes :noweb yes :tangle src/src/ferret/template.clj
  (ns ferret.template
    (:use [ferret.string-template])
    (:import (java.io BufferedReader InputStreamReader)))

  (defn read-from-url [f]
    (with-open [in (.getResourceAsStream (ClassLoader/getSystemClassLoader) f)
                rdr (BufferedReader. (InputStreamReader. in))]
      (apply str (interpose \newline (line-seq rdr)))))

  (defn indexed
    "Returns a lazy sequence of [index, item] pairs, where items come
    from 's' and indexes count up from zero.

    (indexed '(a b c d))  =>  ([0 a] [1 b] [2 c] [3 d])"
    [s]
    (map vector (iterate inc 0) s))

  <<code-templates>>
#+end_src 
** src/ferret/string_template.clj
#+begin_src clojure :noweb yes :mkdirp yes :tangle src/src/ferret/string_template.clj
  (ns ferret.string-template
    (:import org.antlr.stringtemplate.StringTemplateGroup)
    (:import org.antlr.stringtemplate.StringTemplate)
    (:use ferret.string-template-internal))


  (defn create-view "Return new view template - useful as mentioned here:
    http://hardlikesoftware.com/weblog/2006/12/12/using-json-with-stringtemplate/"
    ([]
      (StringTemplate.))
    ([^String template]
      (StringTemplate. template)))


  (defn get-view-from-classpath "Return the view template from classpath"
    [^String view-name]
    (let [st-group (StringTemplateGroup. "default")]
      (.getInstanceOf st-group view-name)))


  (defn get-view-from-dir "Return the view template from specified directory"
    [^String view-name ^String root-dir]
    (let [st-group (StringTemplateGroup. "default" root-dir)]
      (.getInstanceOf st-group view-name)))


  (defn reset-view! "Reset view template with supplied content"
    [^StringTemplate view ^String template]
    (.setTemplate view template))


  (defn fill-view! "Fill view template with key/value pairs"
    ;;;
    ;; Fill template with key and value
    ([^StringTemplate template k v]
      (.setAttribute template (stringify k) (each-kv-to-sv v))
      template)
    ;;;
    ;; Fill template with key/value from map
    ([^StringTemplate template kv-map]
      (.setAttributes template (kv-to-sv kv-map))
      template))


  (defn render-view "Return rendered view for the template"
    [^StringTemplate template]
    (.toString template))
#+end_src

#+begin_src clojure :noweb yes :mkdirp yes :tangle src/src/ferret/string_template_internal.clj
  (ns ferret.string-template-internal)


  (defn stringify [any]
    (if (keyword? any)
      (name any)
      (str any)))


  (declare kv-to-sv)
  (declare scan-kv-to-sv)


  (defn each-kv-to-sv "If element is a collection type, do deep transformation"
    [each]
    (if (map? each)
      (kv-to-sv each)
      (if (or (vector? each) (list? each) (seq? each) (set? each))
        (scan-kv-to-sv each)
        each)))


  (defn scan-kv-to-sv
    "Scans a collection and turns any contained map within from kv to sv"
    [coll]
    (map each-kv-to-sv coll))


  (defn kv-to-sv
    "Transforms keyword-value map {:a 10 :b 20 :c 30}
     to string-value map {\"a\" 10 \"b\" 20 \"c\" 30}"
    [mp]
    (let [m (into {} mp)
          k (keys m)
          v (vals m)]
      (zipmap
        (map stringify k)
        (scan-kv-to-sv v))))

#+end_src

** test/ferret/test/core.clj
#+begin_src clojure :noweb yes :mkdirp yes :tangle src/test/ferret/test/core.clj
    (ns ferret.test.core
      (:refer-clojure :exclude [compile])
      (:use [ferret.core] :reload)
      (:use [clojure.test]
            [clojure.java.shell]))

  (defn capture-output [form]
    (let [options (compile-options
                   {:compiler-options
                    ["-std=c++11" "-pedantic"
                     "-Werror" "-Wall" "-Wextra"
                     "-Woverloaded-virtual" "-Wuninitialized"
                     "-Wmissing-declarations" "-Winit-self"]})]
      (compile->cpp form options)
      (compile->binary options [])
      (with-sh-dir "./"
        (let [r (sh "./a.out")]
          (sh "rm" "-f" "a.out")
          (sh "rm" "-f" "solution.cpp")
          (:out r)))))

    <<ferret-unit-tests>>
#+end_src 

** resources/Object.cpp

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/resources/Object.cpp
  <<runtime-native-math-config-macros>>

  <<runtime-native-program-header>>
  <<runtime-native-memory-management-macros>>
  <<runtime-native-macros>>

  namespace ferret{
    class var;
    <<runtime-native-memory-pool>>
    <<runtime-native-object>>
    <<runtime-native-var>>
  }
#+end_src 

** resources/runtime.clj

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/resources/runtime.clj
  <<runtime-clojure-misc-thread-macro>>
  <<runtime-clojure-boolean-object>>
  <<runtime-clojure-pointer-object>>
  <<runtime-clojure-number-object>>
  <<runtime-clojure-seekable-interface>>
  <<runtime-clojure-lambda-interface>>
  <<runtime-clojure-keyword-object>>
  <<runtime-clojure-sequence-object>>
  <<runtime-clojure-string-object>>
  <<runtime-clojure-atom-object>>
  <<runtime-clojure-defn>>
  <<runtime-clojure-looping>>
  <<runtime-clojure-first>>
  <<runtime-clojure-sequence>>
  <<runtime-clojure-logical-operators>>
  <<runtime-clojure-conditionals>>
  <<runtime-clojure-math>>
  <<runtime-clojure-sequence-lazy>>
  <<runtime-clojure-bit-operations>>
  <<runtime-clojure-console-io>>
  <<runtime-clojure-misc>>
  <<runtime-clojure-state-machine>>
  <<runtime-clojure-arduino>>
  <<runtime-clojure-testing>>
#+end_src

** resources/bash_executable_stub.sh

#+begin_src sh :mkdirp yes :tangle src/resources/bash_executable_stub.sh
  #!/bin/sh
  MYSELF=`which "$0" 2>/dev/null`
  [ $? -gt 0 -a -f "$0" ] && MYSELF="./$0"
  java=java
  if test -n "$JAVA_HOME"; then
      java="$JAVA_HOME/bin/java"
  fi
  exec "$java" $java_args -jar $MYSELF "$@"
  exit 1 
#+end_src
